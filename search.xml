<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ Study</title>
    <url>/Blog/2024/02/14/C++%20Study/</url>
    <content><![CDATA[<h1 id="1-C-基础"><a href="#1-C-基础" class="headerlink" title="1.C++基础"></a>1.C++基础</h1><h2 id="1-1-C-运行原理"><a href="#1-1-C-运行原理" class="headerlink" title="1.1.C++运行原理"></a>1.1.C++运行原理</h2><ul>
<li>C++如何工作<br>编译器先处理预处理，即在编译前处理；<br>所有cpp文件被编译后，生成.obj文件，linker将这些文件整合成一个二进制可执行文件，也就是.exe 文件</li>
<li>C++编译器如何工作<br>预处理的处理-&gt;生成语法树<br>预处理，实际上就是将预处理的文件全数复制粘贴到当前文件<br>对于编译器来说，文件没有任何意义，只需要告知是什么文件即可</li>
<li>C++链接器如何工作<br>需要一个入口，一般是main函数，但也可以是其他函数<br>链接器会链接可能需要使用到的函数，所以如果函数仅仅在自己的文件里可能被使用到，并且在本文件不会被使用到，那么在最前面加上static就可以使它不被链接。static使其成为内部函数</li>
</ul>
<h2 id="1-2-C-变量、函数"><a href="#1-2-C-变量、函数" class="headerlink" title="1.2.C++变量、函数"></a>1.2.C++变量、函数</h2><ul>
<li>变量<br>int,string,long,long long,bool</li>
<li>函数的创建原则：避免过多重复代码</li>
<li>sizeof(),可以查看变量的大小</li>
</ul>
<h2 id="1-3-头文件"><a href="#1-3-头文件" class="headerlink" title="1.3.头文件"></a>1.3.头文件</h2><ul>
<li>头文件通过#include进行复制</li>
<li>#pragma once确保头文件仅被复制一次</li>
<li>“”用于文件路径，&lt;&gt;用于文件夹路径</li>
</ul>
<h2 id="1-4-条件、分支和循环"><a href="#1-4-条件、分支和循环" class="headerlink" title="1.4.条件、分支和循环"></a>1.4.条件、分支和循环</h2><h3 id="1-4-1-条件语句"><a href="#1-4-1-条件语句" class="headerlink" title="1.4.1.条件语句"></a>1.4.1.条件语句</h3><ul>
<li>本质上是给CPU不同的指令（机器代码），在不同的内存进行运作</li>
</ul>
<h3 id="1-4-2-循环语句"><a href="#1-4-2-循环语句" class="headerlink" title="1.4.2.循环语句"></a>1.4.2.循环语句</h3><ul>
<li>for循环</li>
<li>while循环</li>
<li>do while循环</li>
</ul>
<h3 id="1-4-3-控制流语句"><a href="#1-4-3-控制流语句" class="headerlink" title="1.4.3.控制流语句"></a>1.4.3.控制流语句</h3><ul>
<li>continue,进行下一次循环</li>
<li>break，跳出循环，终止循环</li>
<li>return，完全退出函数，并且返回</li>
</ul>
<h2 id="1-5-指针和引用"><a href="#1-5-指针和引用" class="headerlink" title="1.5.指针和引用"></a>1.5.指针和引用</h2><h3 id="1-5-1-指针"><a href="#1-5-1-指针" class="headerlink" title="1.5.1.指针"></a>1.5.1.指针</h3><ul>
<li>指针用于管理和操纵内存，指针是一种存储内存地址的整数</li>
<li>指针的类型是告诉计算机，对应地址的值是什么类型，对于地址本身没有影响，地址始终是整数</li>
<li>指针可以指向指针，例如：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptn = &amp;var; <span class="comment">//&amp;取了var地址</span></span><br><span class="line"><span class="type">int</span>** ptnd = &amp;ptn;</span><br></pre></td></tr></table></figure></div></li>
<li>指针的指向对象可以修改<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* ref = &amp;a;</span><br><span class="line">*ref = <span class="number">1</span>; <span class="comment">//逆向指针，即取地址的值并且修改</span></span><br><span class="line">ref = &amp;b;</span><br><span class="line">*ref = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-5-2-引用"><a href="#1-5-2-引用" class="headerlink" title="1.5.2.引用"></a>1.5.2.引用</h3><ul>
<li>引用只是引用现有的变量，并没有在内存中占用资源，仅仅出现在源代码中。相当于给已有变量取别名<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = var;</span><br><span class="line">ref = <span class="number">9</span>; <span class="comment">//通过引用改变了var的实际值</span></span><br></pre></td></tr></table></figure></div></li>
<li>函数引用举例：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">9</span>;</span><br><span class="line">	<span class="built_in">Add</span>(var);</span><br><span class="line">	std::cout &lt;&lt; var &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>引用之后不能修改引用的对象</li>
</ul>
<h2 id="1-6-C-类"><a href="#1-6-C-类" class="headerlink" title="1.6.C++类"></a>1.6.C++类</h2><h3 id="1-6-1-C-类"><a href="#1-6-1-C-类" class="headerlink" title="1.6.1.C++类"></a>1.6.1.C++类</h3><ul>
<li>类的创建<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;; <span class="comment">//注意这里需要一个分号</span></span><br></pre></td></tr></table></figure></div></li>
<li>类的属性默认都是私有的<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//这里使用public，就可以使得这些属性为公有的</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">int</span> speed;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;; <span class="comment">//注意这里需要一个分号</span></span><br></pre></td></tr></table></figure></div></li>
<li>类的两种实例创建<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Example e_1; <span class="comment">//在栈上创建的，离开作用域后就自动销毁</span></span><br><span class="line">	Example* e_2 = <span class="keyword">new</span> Example; <span class="comment">//在堆上创建的，需要手动销毁（new关键字返回的是指针）</span></span><br><span class="line">	<span class="keyword">delete</span> e_2; <span class="comment">//用new关键字创建在堆上的，需要使用delete删除</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果new创建数组，delete也要加上数组</span></span><br><span class="line">	<span class="type">int</span>* nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-2-静态（static）"><a href="#1-6-2-静态（static）" class="headerlink" title="1.6.2.静态（static）"></a>1.6.2.静态（static）</h3><ul>
<li>类或者结构体外的static可以确保静态函数或者变量只在当前翻译单元（cpp文件）被链接。<br>类中的static，使得该变量或者函数仅仅只有一个实例；假设一个类的许多实例对该变量进行改变，改变的始终只有这一个变量；所有实例的这些变量或者函数都指向同一个内存<br>静态方法不能访问非静态变量</li>
<li>局部静态（local static）：在函数中，不会被函数以外调用到，但是有记忆，生存期永远  <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//static使得变量i只能被Function函数修改，但是这个i是有记忆的</span></span><br><span class="line">	i++;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>(); <span class="comment">//打印1</span></span><br><span class="line">	<span class="built_in">Function</span>(); <span class="comment">//打印2</span></span><br><span class="line">	<span class="built_in">Function</span>(); <span class="comment">//打印3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-3-枚举"><a href="#1-6-3-枚举" class="headerlink" title="1.6.3.枚举"></a>1.6.3.枚举</h3><ul>
<li>枚举将某些数字赋予名词,一定是整数，并且调用形式为：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	A, B, C <span class="comment">//默认情况下，A，B，C，从0递增</span></span><br><span class="line">&#125;; <span class="comment">//需要一个分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; Entity::A &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-4-构造函数"><a href="#1-6-4-构造函数" class="headerlink" title="1.6.4.构造函数"></a>1.6.4.构造函数</h3><ul>
<li>构造函数起到一个初始化类的作用，可以对类属性等等进行初始化<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//初始化代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">float</span> x) <span class="comment">//可以进行函数重载，即同名函数，因为不同参数而有的不同函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//对x进行操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>构造函数可以被两种方法删除：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将构造函数删除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>() = <span class="keyword">delete</span>; <span class="comment">//这样类就不能被创建实例</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将构造函数private</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Entity</span>(); <span class="comment">//这样类就不能被创建实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-5-析构函数"><a href="#1-6-5-析构函数" class="headerlink" title="1.6.5.析构函数"></a>1.6.5.析构函数</h3><ul>
<li>析构函数在对象被销毁的时候调用<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	~<span class="built_in">Entity</span>() <span class="comment">//类名前添加一个~</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//对象被删除时的操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-6-类的继承"><a href="#1-6-6-类的继承" class="headerlink" title="1.6.6.类的继承"></a>1.6.6.类的继承</h3><ul>
<li>继承使得子类继承了父类的所有属性、方法等<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> A = <span class="number">3</span>, B =<span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Plus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; A + B &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Entity <span class="comment">//继承类Entity的所有public属性和方法&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> C = <span class="number">5</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">cPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; A + B + C &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
在以上的例子中，类Son的实例，实际上也是Entity的实例</li>
</ul>
<h3 id="1-6-7-虚函数"><a href="#1-6-7-虚函数" class="headerlink" title="1.6.7.虚函数"></a>1.6.7.虚函数</h3><ul>
<li>允许我们在子类中重写方法</li>
<li>引入V表（虚函数表），包含基类中所有虚函数映射<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> A = <span class="number">3</span>, B =<span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Plus</span><span class="params">()</span> <span class="comment">//添加上virtual标记为虚函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; A + B &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Entity <span class="comment">//继承类Entity的所有public属性和方法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> C = <span class="number">5</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Plus</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">//添加override表明重载函数</span></span><br><span class="line">		std::cout &lt;&lt; A + B + C &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>虚函数的两个缺点</li>
</ul>
<ol>
<li>需要在基类中创造一个指针</li>
<li>需要对V表遍历，从而确定映射的目标函数</li>
</ol>
<h3 id="1-6-8-C-接口（纯虚函数）"><a href="#1-6-8-C-接口（纯虚函数）" class="headerlink" title="1.6.8.C++接口（纯虚函数）"></a>1.6.8.C++接口（纯虚函数）</h3><ul>
<li>父类中的接口只包含未实现的方法作为模板，纯虚函数必须被实现，才可以创建这个子类的实例<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//创建纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintableSon</span> :<span class="keyword">public</span> Printable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;PrintableSon&quot;</span>; &#125; <span class="comment">//重载了纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> :<span class="keyword">public</span> Printable, PrintableSon</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125; <span class="comment">//重载了纯虚函数</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Printable* Instate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//A-&gt;B，意味着A是指针，-&gt;是成员提取。A必须是指向类、结构、联合的指针</span></span><br><span class="line">	std::cout &lt;&lt; Instate-&gt;<span class="built_in">GetName</span>()&lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PrintName</span>(<span class="keyword">new</span> <span class="built_in">Player</span>()); <span class="comment">//new Player()返回的是Player实例的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="1-7-一些深入探讨"><a href="#1-7-一些深入探讨" class="headerlink" title="1.7.一些深入探讨"></a>1.7.一些深入探讨</h2><h3 id="1-7-1-C-数组"><a href="#1-7-1-C-数组" class="headerlink" title="1.7.1.C++数组"></a>1.7.1.C++数组</h3><ul>
<li>数组就是表示一堆变量组成的集合  </li>
<li>如果访问数组范围外索引，则会Memory access violation（内存范文违规）  </li>
<li>数组实质上是指针<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> example[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* ptr = example; <span class="comment">//不会报错</span></span><br></pre></td></tr></table></figure></div></li>
<li>数组是指针<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">*(<span class="type">int</span>*)((<span class="type">char</span>*)ptr+<span class="number">8</span>)=<span class="number">6</span>； <span class="comment">//将数组是指针的原理展现的很清晰</span></span><br></pre></td></tr></table></figure></div>
首先，ptr是int指针，所以被定义4字节是一个索引；当（char* ）转化的时候，被定义为了8字节为一个索引；所以加8就是加了一个索引，而（int*）就是将其重新转化为int指针，并且赋值为6</li>
</ul>
<h3 id="1-7-2-C-字符串"><a href="#1-7-2-C-字符串" class="headerlink" title="1.7.2.C++字符串"></a>1.7.2.C++字符串</h3><ul>
<li>char是一个字节，char不是在堆，而是在栈上建立</li>
<li>char默认以单引号，char*默认以双引号<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">//编译器自动分配一个字符数组，其中包含一个额外的空字符表示字符串的结束</span></span><br><span class="line"><span class="type">char</span> *ptr = <span class="string">&quot;Hello&quot;</span>; <span class="comment">//这样ptr直接指向字符串的首地址</span></span><br><span class="line"><span class="type">char</span>* ptr = str; <span class="comment">//str数组名本身也就是字符串的首地址</span></span><br><span class="line"></span><br><span class="line">此外，添加<span class="type">const</span>说明不可修改</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;i am ztl&quot;</span>;</span><br></pre></td></tr></table></figure></div></li>
<li>字符串数组的工作原理：在指针末尾有一个空终止字符00</li>
<li>一个””双引号包括的文本，一般默认为一个char数组</li>
<li>std::string是一个类，用来表示字符串，会动态地分配内存以容纳字符串的长度</li>
</ul>
<h3 id="1-7-3-CONST"><a href="#1-7-3-CONST" class="headerlink" title="1.7.3.CONST"></a>1.7.3.CONST</h3><ul>
<li>const承诺某些东西的不变性<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> age = <span class="number">90</span>;	</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//将指针指向地址内的值设为常量</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//将指针指向地址内的值设为常量</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//将指针指向的地址内设为常量，即不能改变指针指向</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//两者都不能修改</span></span><br></pre></td></tr></table></figure></div></li>
<li>const可以使类里面的函数不能修改类<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> var;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//第一个const表示返回值不可改变，这里的第二个const就使得函数不可以修改类，只能读取类的值</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> var;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>mutable修饰，可以使被const的函数去修改类<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> var;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> var2；</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//这里的const就使得函数不可以修改类，只能读取类的值</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">mutable</span> var2 = <span class="number">2</span>； <span class="comment">//因为是mutable修饰的变量，所以const函数里面可以将它修改 </span></span><br><span class="line">		<span class="keyword">return</span> var;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-4-类的初始化成员列表"><a href="#1-7-4-类的初始化成员列表" class="headerlink" title="1.7.4.类的初始化成员列表"></a>1.7.4.类的初始化成员列表</h3><ul>
<li>在类的构造函数括号后面紧接着：并将变量赋值：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_number;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Example</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is Example_1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Example</span>(<span class="type">int</span> num)</span><br><span class="line">		:<span class="built_in">m_number</span>(num) <span class="comment">//将变量用括号内值赋值</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is Example_2 with&quot;</span> &lt;&lt; m_number &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>有一种减少性能消耗的方式<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_number;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Example</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is Example_1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Example</span>(<span class="type">int</span> num)</span><br><span class="line">		:<span class="built_in">m_number</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is Example_2 with&quot;</span> &lt;&lt; m_number &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Example m_example;</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">int</span> num)</span><br><span class="line">		: <span class="built_in">m_example</span>(num) <span class="comment">//这里就可以防止生成额外的实例</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//m_example = Example(num); //这就导致产生了两个Example实例，而有一个只是创建了没有被实际使用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-5-三元操作符"><a href="#1-7-5-三元操作符" class="headerlink" title="1.7.5.三元操作符"></a>1.7.5.三元操作符</h3><ul>
<li>实际上就是if-else的语法糖</li>
<li>将要赋值的变量 &#x3D; 判定条件？ 赋值1：赋值2;<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> curNum = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> comNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是正常写法</span></span><br><span class="line"><span class="keyword">if</span> (curNum &gt; comNum)</span><br><span class="line">&#123;</span><br><span class="line">	curNum = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	curNum = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是三元操作符写法</span></span><br><span class="line">curNum = curNum &gt; comNum ? <span class="number">20</span> : <span class="number">30</span>; </span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-6-隐式转换和explicit"><a href="#1-7-6-隐式转换和explicit" class="headerlink" title="1.7.6.隐式转换和explicit"></a>1.7.6.隐式转换和explicit</h3><h4 id="1-7-6-1-隐式构造函数以及转换"><a href="#1-7-6-1-隐式构造函数以及转换" class="headerlink" title="1.7.6.1.隐式构造函数以及转换"></a>1.7.6.1.隐式构造函数以及转换</h4><ul>
<li>构造函数相同，只是在创建实例的时候有一些不同<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	std::string m_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个不同构造函数</span></span><br><span class="line">	<span class="built_in">Example</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">	:m_name = name</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="built_in">Example</span>(<span class="type">int</span> age):<span class="built_in">m_number</span>(num)</span><br><span class="line">	:m_age = age</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Example <span class="title">a</span><span class="params">(<span class="string">&quot;ztl&quot;</span>)</span></span>;</span><br><span class="line">	Example a = <span class="string">&quot;ztl&quot;</span>; <span class="comment">//直接赋值，编译器自动转换为Example（&quot;ztl&quot;）</span></span><br><span class="line">	<span class="function">Example <span class="title">b</span><span class="params">(<span class="number">21</span>)</span></span>;</span><br><span class="line">	Example b = <span class="number">21</span>; <span class="comment">//直接赋值，编译器自动转换21为Example（21）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>将explicit写在构造函数之前，那么就不能隐式转换</li>
</ul>
<h3 id="1-7-7-运算符及其重载"><a href="#1-7-7-运算符及其重载" class="headerlink" title="1.7.7.运算符及其重载"></a>1.7.7.运算符及其重载</h3><h4 id="1-7-7-1-运算符"><a href="#1-7-7-1-运算符" class="headerlink" title="1.7.7.1.运算符"></a>1.7.7.1.运算符</h4><p>+，-，*，&#x2F;，new，delete，逗号，括号等也是运算符，运算符实际上就是函数</p>
<h4 id="1-7-7-2-重载"><a href="#1-7-7-2-重载" class="headerlink" title="1.7.7.2.重载"></a>1.7.7.2.重载</h4><ul>
<li>重载就是赋予新的定义和作用<br>以+为例<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载加法运算符</span></span><br><span class="line">    Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(x + v.x, y + v.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出向量的坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Vector result = v1 + v2; <span class="comment">// 调用重载的加法运算符</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Resultant vector: &quot;</span>;</span><br><span class="line">    result.<span class="built_in">display</span>(); <span class="comment">// 输出结果向量的坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
<li>除了类属关系运算符”.”、成员指针运算符”.*”、作用域运算符”::”、sizeof运算符和三目运算符”?:”以外，C++中的所有运算符都可以重载但是&#x3D;、()、[]、-&gt;这四个不能重载为类的友元函数。</li>
</ul>
<h3 id="1-7-8-关于this"><a href="#1-7-8-关于this" class="headerlink" title="1.7.8.关于this"></a>1.7.8.关于this</h3><ul>
<li>this是一个指向当前对象的指针，它是每个非静态成员函数的隐含参数</li>
<li>this返回的是指针，所以不是一个对象，而是对象地址，对于对象的变量引用应该是间接的，例如：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;x; <span class="comment">//意思是this指针所指向的对象，对这个对象的x变量修改</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-9-关于作用域"><a href="#1-7-9-关于作用域" class="headerlink" title="1.7.9.关于作用域"></a>1.7.9.关于作用域</h3><ul>
<li>当变量是在栈上创建的，脱离了作用域就会自动销毁</li>
<li>当是在堆上创建，脱离了作用域不会自动销毁</li>
<li>一个自动销毁的例子<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Create!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Destroy!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Entity* m_ptr;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//构造函数必须要是public，否则不能创建实例</span></span><br><span class="line">	<span class="built_in">Example</span>(Entity* ptr)</span><br><span class="line">	:<span class="built_in">m_ptr</span>(ptr) <span class="comment">//构造的时候，传递指针</span></span><br><span class="line">	&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	~<span class="built_in">Example</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr; <span class="comment">//析构的时候，将指针删除</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Example e = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">//隐式转换；虽然是栈上创建的Example，但是Entity实例会自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-8-1-智能指针（-include-）"><a href="#1-8-1-智能指针（-include-）" class="headerlink" title="1.8.1.智能指针（#include &lt;memory&gt;）"></a>1.8.1.智能指针（#include &lt;memory&gt;）</h3><ul>
<li>unique_ptr指针（默认不能隐式构造，也不能拷贝构造和拷贝赋值，并且同一时间有独占所有权语义）<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>; <span class="comment">//默认不能使用隐式转换，需要手动管理内存;先创建一个Entity，然后传给shared_ptr分配内存</span></span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;; <span class="comment">//更加安全（处理异常）,会自动管理内存，否则造成内存泄漏</span></span><br></pre></td></tr></table></figure></div></li>
<li>shared_ptr指针（存在引用计数）<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>; <span class="comment">//先创建Entity，然后share_ptr分配一个内存控制空间，用作引用计数</span></span><br><span class="line">std::shared_ptr&lt;Entity&gt; entity = std::make_shared&lt;Entity&gt;; <span class="comment">//组合一次性创建，性能强大</span></span><br></pre></td></tr></table></figure></div></li>
<li>还有一个weak_ptr，与shared_ptr一同使用，不会增加引用计数<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;Entity&gt; weakEntity = sharedEntity; <span class="comment">//将一个shared_ptr给weak_ptr弱指针</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-8-2-复制与拷贝构造函数"><a href="#1-8-2-复制与拷贝构造函数" class="headerlink" title="1.8.2.复制与拷贝构造函数"></a>1.8.2.复制与拷贝构造函数</h3><ul>
<li>C++的类默认有拷贝构造函数，用于将</li>
<li>浅拷贝和深拷贝：<br>浅拷贝（Shallow Copy）：<br>浅拷贝是指将一个对象的值复制到另一个对象，而不复制内存地址。换句话说，浅拷贝只复制了对象的引用，而没有复制对象的内容。<br>在浅拷贝中，如果对象内部包含指针或动态分配的内存，那么只会复制指针的值，而不会复制指针所指向的内容。因此，多个对象可能会共享同一块内存，这就可能导致一旦其中一个对象修改了内存中的数据，其他对象也会受到影响。<br>浅拷贝通常是通过对象的复制构造函数或赋值运算符实现的。<br>深拷贝（Deep Copy）：<br>深拷贝是指在复制对象时，会递归地复制对象及其包含的所有数据，而不仅仅是复制对象的引用。这意味着每个对象都有自己独立的内存空间存储数据，彼此之间互不影响。<br>在深拷贝中，对象的所有成员变量以及动态分配的内存都会被复制，因此每个对象都拥有自己的一份数据副本。<br>深拷贝通常需要自定义对象的复制构造函数和赋值运算符，确保在复制过程中进行适当的内存分配和数据复制。</li>
<li>拷贝构造函数：<br>用于创建一个新对象，该对象的内容是另一个同类对象的副本<br>被调用的条件：</li>
</ul>
<ol>
<li>对象初始化，使用一个已经存在的对象来创建另一个新的对象</li>
<li>作为参数传递的时候，会用拷贝构造函数创建一个副本</li>
<li>作为函数的返回值，返回的时候同样创建一个副本<br>如果将拷贝函数 &#x3D; delete;，那么类禁止拷贝</li>
</ol>
<h3 id="1-8-3-箭头操作符"><a href="#1-8-3-箭头操作符" class="headerlink" title="1.8.3.箭头操作符"></a>1.8.3.箭头操作符</h3><ul>
<li>通常用于访问类或结构体对象的成员，特别是在对象是指针类型时<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">printfa</span>()</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">	(*e).<span class="built_in">printfa</span>(); <span class="comment">//需要逆向引用才可以使用.进行调用函数</span></span><br><span class="line">	e-&gt;<span class="built_in">printfa</span>(); <span class="comment">//箭头可以直接对指针的成员进行访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>还可以获取类中或者结构体中数据的偏移量</li>
</ul>
<h1 id="2-C-标准库"><a href="#2-C-标准库" class="headerlink" title="2.C++标准库"></a>2.C++标准库</h1><h2 id="2-1-C-标准库"><a href="#2-1-C-标准库" class="headerlink" title="2.1.C++标准库"></a>2.1.C++标准库</h2><h3 id="2-1-1-C-动态数组Vector"><a href="#2-1-1-C-动态数组Vector" class="headerlink" title="2.1.1.C++动态数组Vector"></a>2.1.1.C++动态数组Vector</h3><ul>
<li>动态数组与原始数组不同的是，它可以不设定原始大小，可以动态增加数组大小<br>原理是，创建一个新的更大的数组，将原本小的数组复制到这个大数组里面，然后删除原有数组<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VectoX</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> VectoX&amp; vectox)</span><br><span class="line">&#123;</span><br><span class="line">	stream &lt;&lt; vectox.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vectox.y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vectox.z;</span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;VectoX&gt; list;</span><br><span class="line">	list.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">//push_back可以将元素加入动态数组中</span></span><br><span class="line">	list.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;);</span><br><span class="line">	list.<span class="built_in">push_back</span>(&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++)</span><br><span class="line">		std::cout &lt;&lt; list[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; list.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">//获取数组长度</span></span><br><span class="line">	list.<span class="built_in">erase</span>(list.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">//erase()可以进行索引删除，begin()得到数组第一个索引</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (VectoX&amp; v : list) <span class="comment">//循环方法</span></span><br><span class="line">		std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	list.<span class="built_in">clear</span>(); <span class="comment">//清空数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>一些优化，避免过多复制<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">list.<span class="built_in">reserve</span>(num); <span class="comment">//让Vector预留三个位置，从而不用创建新数组，删除旧数组</span></span><br><span class="line">list.<span class="built_in">emplace_back</span>(); <span class="comment">//直接在Vector里面添加新的元素，而不是在main栈帧里面创建然后复制</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-1-2-C-动态库（处理二进制库）"><a href="#2-1-2-C-动态库（处理二进制库）" class="headerlink" title="2.1.2.C++动态库（处理二进制库）"></a>2.1.2.C++动态库（处理二进制库）</h3><ul>
<li>可执行文件被执行的时候，动态链接库才开始加载</li>
<li>.dll和.dll.lib文件，其中.lib要配置，而.dll应该要放到可执行文件目录下</li>
</ul>
<h3 id="2-1-3-C-静态库（源代码实际编译）"><a href="#2-1-3-C-静态库（源代码实际编译）" class="headerlink" title="2.1.3.C++静态库（源代码实际编译）"></a>2.1.3.C++静态库（源代码实际编译）</h3><ul>
<li>头文件(.h)告诉编译器哪些函数可以用，库文件(.lib)提供定义，然后链接器链接到那些函数</li>
<li>静态链接允许更多的优化</li>
</ul>
<h3 id="2-1-4-C-返回多个值"><a href="#2-1-4-C-返回多个值" class="headerlink" title="2.1.4.C++返回多个值"></a>2.1.4.C++返回多个值</h3><ul>
<li>tuple以及pair（两者相差不大，就是使用上面的区别）<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>...&gt; <span class="title">Function</span><span class="params">()</span> <span class="comment">//自定义返回的数量以及类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_pair</span>(string, <span class="type">int</span>); <span class="comment">//将实参传入return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> a = <span class="built_in">Function</span>();</span><br><span class="line">	std::get&lt;<span class="number">0</span>&gt;a; <span class="comment">//tuple的使用</span></span><br><span class="line">	a.first; <span class="comment">//pair的使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>struct<br>可以通过命名，并且return {}；非常简单</li>
<li>C++17之后，可以通过结构化绑定进行获取<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>[a, b] = <span class="built_in">Function</span>(); <span class="comment">//自动获取a,b的类型（根据返回的顺序）</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-1-5-C-模板、泛型（templates）"><a href="#2-1-5-C-模板、泛型（templates）" class="headerlink" title="2.1.5.C++模板、泛型（templates）"></a>2.1.5.C++模板、泛型（templates）</h3><ul>
<li>基于给定编译器的规则，编译器自动写出代码（并且是函数调用的时候，才根据传递类型自动生成代码）<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//typename也可以是class，T可以是任意自取命名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span> <span class="comment">//T就是类型，value就是参数名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">print</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">20</span>); <span class="comment">//隐式转换</span></span><br><span class="line">	<span class="built_in">print</span>&lt;std::string&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>也可以对类进行模板<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T array[N]; <span class="comment">//这个类型也可以自行定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Array&lt;std::string, <span class="number">20</span>&gt; array;</span><br><span class="line">	std::cout &lt;&lt; array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2-2-C"><a href="#2-2-C" class="headerlink" title="2.2.C++"></a>2.2.C++</h2><h3 id="2-2-1-内存区域"><a href="#2-2-1-内存区域" class="headerlink" title="2.2.1.内存区域"></a>2.2.1.内存区域</h3><ul>
<li>五大内存区域<br>1.栈（stack）：用于存储函数的局部变量、函数的参数值等。在程序执行期间，栈的大小是动态变化的，每当调用函数时，会在栈上分配一块内存空间，函数执行结束时释放这些空间。<br>2.堆（heap）：用于动态分配内存，即通过 new 或 malloc 等操作来分配内存。在程序运行期间，堆的大小也是动态变化的，需要手动释放动态分配的内存，否则可能会导致内存泄漏。<br>3.全局&#x2F;静态存储区（Global&#x2F;Static Storage Area）：用于存储全局变量、静态变量等。这些变量在程序启动时被分配内存，在程序结束时释放。<br>4.常量存储区（Constant Storage Area）：用于存储常量值，例如字符串常量。这些值在程序编译时就已经确定，并存储在常量存储区中<br>5.代码区（Code Area）：用于存储程序的代码。这部分内存通常是只读的，并且在程序执行期间不会被修改</li>
<li>栈和堆的区别<br>栈：栈预定义为2M左右的内存空间，内存分配的是一段连续的空间，分配速度更快，未初始化的时候为cc<br>堆：堆大小会变化，内存分配为不同的地方，分配速度更慢，未初始化的时候为cd  </li>
<li>malloc and free ， new and delete<br>系统会维护空闲列表（free list），用于跟踪空闲内存块，并且跟踪他们的位置。当malloc调用时，需要动态内存时，浏览free list，找到合适内存空间，然后返回那片空间的指针，记录大小以及使用情况（避免再次使用）</li>
</ul>
<h3 id="2-2-2-宏"><a href="#2-2-2-宏" class="headerlink" title="2.2.2. 宏"></a>2.2.2. 宏</h3><ul>
<li>宏（Macros）是一种在编程中常用的预处理指令，用于在编译之前进行文本替换，从而实现代码重用和简化，C++中，宏以#define定义<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN int main()\	</span></span><br><span class="line">&#123;\</span><br><span class="line">	std::cin.<span class="built_in">get</span>();\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>一个例子<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> PR_DEBUG == 1 <span class="comment">//可以在属性里设置preprocessor Definitions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt;x&lt;&lt;std::endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div></li>
<li>宏中__Function__代表着函数的函数名</li>
</ul>
<h3 id="2-2-3-auto关键字"><a href="#2-2-3-auto关键字" class="headerlink" title="2.2.3.auto关键字"></a>2.2.3.auto关键字</h3><ul>
<li>auto可以自动通过编译器获取变量类型<br>auto自动获取变量的双刃剑：可以自动获取变量类型，但是也可能破坏代码结构</li>
<li>可以为已有类型名添加别名的两种方式<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> INT = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-4-C-静态数组（-include-）"><a href="#2-2-4-C-静态数组（-include-）" class="headerlink" title="2.2.4.C++静态数组（#include &lt;array&gt;）"></a>2.2.4.C++静态数组（#include &lt;array&gt;）</h3><ul>
<li>创建在栈上的数组类实例<br>array存在边界检查<br>array可以获取数组大小.size()<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::array&lt;Type, Num&gt; Array; <span class="comment">//Type是存储类型，Num是数组大小</span></span><br></pre></td></tr></table></figure></div></li>
<li>与vector的对比<br>1.array创建在栈上，vector创建在堆上；<br>2.array是静态数组，大小固定；vector是动态数组，大小可变</li>
</ul>
<h3 id="2-2-5-C-函数指针（原始函数指针，源自于C语言）"><a href="#2-2-5-C-函数指针（原始函数指针，源自于C语言）" class="headerlink" title="2.2.5.C++函数指针（原始函数指针，源自于C语言）"></a>2.2.5.C++函数指针（原始函数指针，源自于C语言）</h3><ul>
<li>函数指针存储着函数的内存地址，使得可以通过该指针调用函数<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">void</span>(*Zero)() = Hello; <span class="comment">//将函数指针指向Hello（这里有一个隐式转换，实际上是 = &amp;Hello）</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Zero</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*isZero)</span><span class="params">()</span></span>; <span class="comment">//创建类型别名，isZero是一个函数指针别名</span></span><br><span class="line">	isZero _zero = Hello;</span><br><span class="line"></span><br><span class="line">	_zero();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>函数指针调用的实例<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Value is : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetArray</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vector, <span class="type">void</span>(*func)(<span class="type">int</span>))</span> <span class="comment">//定义输入函数指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v : vector) <span class="comment">//遍历数组</span></span><br><span class="line">		<span class="built_in">func</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; vector = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span> &#125;; <span class="comment">//初始化列表</span></span><br><span class="line">	<span class="built_in">GetArray</span>(vector, Print); <span class="comment">//将Print函数的地址传入</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-6-lambda函数（匿名函数）"><a href="#2-2-6-lambda函数（匿名函数）" class="headerlink" title="2.2.6.lambda函数（匿名函数）"></a>2.2.6.lambda函数（匿名函数）</h3><ul>
<li>lambda通常和函数指针放在一起使用，可以简洁地定义一个函数<br>语法为<a href="parameters">capture</a> -&gt; return_type { body }<br>capture:捕获，可以是&#x3D;，表示捕获所有值；&amp;，表示捕获引用；也可以是具体变量a,&amp;b；<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> lambda = [](<span class="type">int</span> a) &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="built_in">Print</span>(lambda);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-7-namespace-名称空间、命名空间"><a href="#2-2-7-namespace-名称空间、命名空间" class="headerlink" title="2.2.7.namespace(名称空间、命名空间)"></a>2.2.7.namespace(名称空间、命名空间)</h3><ul>
<li>为了避免同样的函数，引入命名空间<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line">	<span class="built_in">function</span>(); <span class="comment">//可以直接调用</span></span><br><span class="line">	<span class="keyword">namespace</span> a = apple;</span><br><span class="line">	a::<span class="built_in">function</span>(); <span class="comment">//通过作用域使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-8-线程（-include-）"><a href="#2-2-8-线程（-include-）" class="headerlink" title="2.2.8.线程（#include &lt;thread&gt;）"></a>2.2.8.线程（#include &lt;thread&gt;）</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> is_waiting = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals; <span class="comment">//让线程暂停的命名空间</span></span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt;<span class="string">&quot;this thread is&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; <span class="comment">//获取当前线程的id</span></span><br><span class="line">	<span class="keyword">while</span> (!is_waiting)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Waiting...\n&quot;</span>;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s); <span class="comment">//每次停顿一秒</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;this thread is&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; <span class="comment">//获取当前线程的id</span></span><br><span class="line">	<span class="function">std::thread <span class="title">worker</span><span class="params">(Print)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">	is_waiting = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	worker.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-2-9-计时（-include-）"><a href="#2-2-9-计时（-include-）" class="headerlink" title="2.2.9.计时（#include &lt;chrono&gt;）"></a>2.2.9.计时（#include &lt;chrono&gt;）</h3><ul>
<li>可以对函数线程等等进行的时间进行计算<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals; <span class="comment">//引用这个命名空间，以便使用其中的函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); <span class="comment">//获取当前时间</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">	<span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); <span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line">	std::chrono::duration&lt;<span class="type">float</span>&gt; duration = end - start; <span class="comment">//计算出两者时间间隔</span></span><br><span class="line">	std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>可以使用对象作用时间作为计时器原理</li>
<li>题外话：\n比std::endl;更优化</li>
</ul>
<h3 id="2-3-1-C-多维数组"><a href="#2-3-1-C-多维数组" class="headerlink" title="2.3.1.C++多维数组"></a>2.3.1.C++多维数组</h3><ul>
<li>数组本质上是指针，所以一些元素的指针的集合就是指针数组，以此为原理创建多维数组<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>*** a3d = <span class="keyword">new</span> <span class="type">int</span>** [<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a3d[i] = <span class="keyword">new</span> <span class="type">int</span>* [<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a3d[i][j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				a3d[i][j][k] = (i + <span class="number">1</span>) * (j + <span class="number">1</span>) + k;</span><br><span class="line">				std::cout &lt;&lt; a3d[i][j][k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			std::cout&lt;&lt;std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>delete数组需要将所有释放，否则导致内存泄漏<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] a3d[i][j];	<span class="comment">//将每一个整型数组删除，删除并不会影响到后面的数组，因为是一一映射的</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] a3d[i]; <span class="comment">//将每一个指向整型数组的指针删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] a3d; <span class="comment">//将指向数组的指针的三维数组指针删除</span></span><br></pre></td></tr></table></figure></div></li>
<li>一维数组同样可以做到二维数组的事情，因为内存分配是在一个连续的内存块，因此速度会更快，是一种优化的方法<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[j + i * <span class="number">5</span>] = j + i * <span class="number">5</span>;</span><br><span class="line">		std::cout &lt;&lt; a[j + i * <span class="number">5</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-3-2-C-排序-std-sort，-include"><a href="#2-3-2-C-排序-std-sort，-include" class="headerlink" title="2.3.2.C++排序(std::sort，#include &lt;algorithm&gt;)"></a>2.3.2.C++排序(std::sort，#include &lt;algorithm&gt;)</h3><ul>
<li>C++库中内置的排序函数</li>
<li>可以对各种数据结构进行排序，也可以用不同的函数或者说方式进行排序<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) <span class="comment">//可以传入函数或者lambda</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> a &lt; b;</span><br><span class="line">		&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v : values)</span><br><span class="line">		std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-3-3-C-类型双关"><a href="#2-3-3-C-类型双关" class="headerlink" title="2.3.3.C++类型双关"></a>2.3.3.C++类型双关</h3><ul>
<li>想要将一个数据当作另外一个类型，只需要得到它的指针并且转换指针类型<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a =<span class="number">2</span>, b=<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">	<span class="type">int</span>* pos = (<span class="type">int</span>*) &amp; e; <span class="comment">//获取地址并且转换为int指针</span></span><br><span class="line">	pos[<span class="number">0</span>] = <span class="number">6</span>; <span class="comment">//可以将其当作数组处理</span></span><br><span class="line">	pos[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">	std::cout &lt;&lt; e.a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; e.b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>结构体如果为空，那么它是一个字节用于寻址，如果是有例如int a, int b，那么就只有这两者大小。并且是在一段连续内存中</li>
</ul>
<h3 id="2-3-4-C-联合体"><a href="#2-3-4-C-联合体" class="headerlink" title="2.3.4.C++联合体"></a>2.3.4.C++联合体</h3><ul>
<li>联合体内的东西是同一个内存指向<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Union</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">float</span> a;</span><br><span class="line">		<span class="type">int</span> b;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Union u;</span><br><span class="line">	u.a = <span class="number">2.0f</span>;</span><br><span class="line">	std::cout &lt;&lt; u.a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; u.b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>可以作为类型转换的一个技巧</li>
</ul>
<h3 id="2-3-5-虚析构函数"><a href="#2-3-5-虚析构函数" class="headerlink" title="2.3.5.虚析构函数"></a>2.3.5.虚析构函数</h3><ul>
<li>析构函数加上virtual与其他类中的函数加上virtual不一样，而是对析构函数加上一个功能，如果没有加上virtual,那么只能调用基类的析构函数<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A Destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">B</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B Destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	B* b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">	<span class="keyword">delete</span> b;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	A* c = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">	<span class="keyword">delete</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>派生类指针不能指向基类对象，因为基类没有派生类的元素，所以指向基类的话导致不能对成员变量访问。默认可以上行转换（up_cast），想要下行可以进行dynamic_cast转换</li>
</ul>
<h3 id="2-3-5-类型转换"><a href="#2-3-5-类型转换" class="headerlink" title="2.3.5.类型转换"></a>2.3.5.类型转换</h3><ul>
<li>C语言型转换<br>隐式转换和显式转换<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="type">float</span> b = a; <span class="comment">//这样就会自动隐式转换为float类型</span></span><br><span class="line">	<span class="type">float</span> b = (<span class="type">float</span>)a; <span class="comment">//(float)就是一个显式转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>C++语言型转换(cast)<br>static_cast：用于在编译时进行类型转换<br>dynamic_cast：用于在运行时进行安全的向下转换，成功会返回指针，失败返回nullptr  <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> :<span class="keyword">public</span> Entity&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span>:<span class="keyword">public</span> Entity&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Player* player = <span class="keyword">new</span> <span class="built_in">Player</span>();</span><br><span class="line">	</span><br><span class="line">	Entity* acEnemy = <span class="keyword">new</span> <span class="built_in">Enemy</span>();</span><br><span class="line">	Entity* acPlayer = player;</span><br><span class="line"></span><br><span class="line">	Player* p0 = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(acPlayer); <span class="comment">//成功</span></span><br><span class="line">	Player* p1 = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(acEnemy); <span class="comment">//失败</span></span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; p0 &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
const_cast：用于从表达式中删除const或volatile修饰符<br>reinterpret_cast：用于进行指针类型之间的不安全转换，通常用于底层编程或与硬件交互</li>
</ul>
<h3 id="2-3-6-C-安全"><a href="#2-3-6-C-安全" class="headerlink" title="2.3.6.C++安全"></a>2.3.6.C++安全</h3><ul>
<li>关于内存泄漏、非法访问、降低崩溃</li>
<li>实际上归结为两大问题：内存问题、所有权问题</li>
</ul>
<h3 id="2-3-7-预编译头文件-pch"><a href="#2-3-7-预编译头文件-pch" class="headerlink" title="2.3.7.预编译头文件(.pch)"></a>2.3.7.预编译头文件(.pch)</h3><ul>
<li>就是防止某些库过多次被进行编译。预编译头文件是二进制文件，可以被编译器处理</li>
<li>将一些不会改变的库等等放入pch中，减少编译时间；但是对于依赖的可读性就没有那么高<br>将头文件放入.h中，然后将这个name.h #include到一个cpp文件，然后右键这个文件，选择properties-&gt;C&#x2F;C++-&gt;Precompiled Header-&gt;Precompiled Header中选择为creat；然后进入整个项目的properties，同样更改Precompiled Header里面为Use。</li>
</ul>
<h2 id="2-4-C-17特性"><a href="#2-4-C-17特性" class="headerlink" title="2.4.C++17特性"></a>2.4.C++17特性</h2><h3 id="2-4-1-处理optional数据（-include-）"><a href="#2-4-1-处理optional数据（-include-）" class="headerlink" title="2.4.1.处理optional数据（#include &lt;optional&gt;）"></a>2.4.1.处理optional数据（#include &lt;optional&gt;）</h3><ul>
<li>可以用于包装可能存在或者可能不存在的值<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; maybeValue; <span class="comment">// 声明一个可能不存在的 int 值</span></span><br><span class="line">    </span><br><span class="line">    maybeValue = <span class="number">42</span>; <span class="comment">// 现在 maybeValue 包含了一个值为 42 的 int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maybeValue.<span class="built_in">has_value</span>()) &#123; <span class="comment">//这里可以直接if(maybeValue)</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;maybeValue has value: &quot;</span> &lt;&lt; maybeValue.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;maybeValue has no value.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 maybeValue 的值（如果有的话）</span></span><br><span class="line">    <span class="type">int</span> value = maybeValue.<span class="built_in">value_or</span>(<span class="number">0</span>); <span class="comment">// 如果 maybeValue 为空，则返回默认值 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-4-2-单一变量存放多种数据（-include-）"><a href="#2-4-2-单一变量存放多种数据（-include-）" class="headerlink" title="2.4.2.单一变量存放多种数据（#include &lt;variant&gt;）"></a>2.4.2.单一变量存放多种数据（#include &lt;variant&gt;）</h3><ul>
<li>将可能的类型写入，variant会对每一种类型值进行存储<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var;</span><br><span class="line">    </span><br><span class="line">    var = <span class="number">42</span>; <span class="comment">// 存储一个 int 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    var = <span class="number">3.14</span>; <span class="comment">// 存储一个 double 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    var = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 存储一个 std::string 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-4-3-单一变量存储任意类型数据（-include-）"><a href="#2-4-3-单一变量存储任意类型数据（-include-）" class="headerlink" title="2.4.3.单一变量存储任意类型数据（#include &lt;any&gt;）"></a>2.4.3.单一变量存储任意类型数据（#include &lt;any&gt;）</h3><ul>
<li>可以存储任意类型数据<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a;</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">5</span>; <span class="comment">// 存储一个 int 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">3.14</span>; <span class="comment">// 存储一个 double 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(a) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 存储一个 std::string 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-4-4-any和variant的比较"><a href="#2-4-4-any和variant的比较" class="headerlink" title="2.4.4.any和variant的比较"></a>2.4.4.any和variant的比较</h3><ul>
<li>any可以存储任何类型数据，variant可以存储有限的已经设定的一些数据类型</li>
<li>any会进行动态分配，而variant不会，因此variant比any性能要好</li>
</ul>
<h2 id="2-5-C-优化"><a href="#2-5-C-优化" class="headerlink" title="2.5.C++优化"></a>2.5.C++优化</h2><h3 id="2-5-1-多线程（-include-）"><a href="#2-5-1-多线程（-include-）" class="headerlink" title="2.5.1.多线程（#include &lt;future&gt;）"></a>2.5.1.多线程（#include &lt;future&gt;）</h3><ul>
<li>利用核心加载东西，实时加载需要的东西</li>
<li>如果要引用传递参数，需要使用std::ref()<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行 foo 函数，并获取其结果</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result_future = std::<span class="built_in">async</span>(foo, <span class="number">10</span>); <span class="comment">//函数里面是异步的操作，出来又是同步的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步操作的结果</span></span><br><span class="line">    <span class="type">int</span> result = result_future.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-5-2-字符串优化-std-string-view，C-17里面才有的"><a href="#2-5-2-字符串优化-std-string-view，C-17里面才有的" class="headerlink" title="2.5.2.字符串优化(std::string_view，C++17里面才有的)"></a>2.5.2.字符串优化(std::string_view，C++17里面才有的)</h3><ul>
<li>字符串默认情况下是用new进行堆创建，因此对于性能有一些损耗，尤其是对字符串的部分截取。因此std::string_view提供了一种指针办法，不是重新创建一个堆分配，而是一个指针指向原本字符串<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::string name = <span class="string">&quot;ztl love lxy&quot;</span>;</span><br><span class="line"><span class="function">std::string_view <span class="title">ztl</span><span class="params">(name.c_str(), <span class="number">3</span>)</span></span>; <span class="comment">//c_str()返回该字符串的指针</span></span><br><span class="line"><span class="function">std::string_view <span class="title">lxy</span><span class="params">(name.c_str() + <span class="number">9</span>, <span class="number">3</span>)</span></span>; <span class="comment">//从起始位置开始，往后三个字符</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-5-3-可视化基准测试"><a href="#2-5-3-可视化基准测试" class="headerlink" title="2.5.3.可视化基准测试"></a>2.5.3.可视化基准测试</h3><ul>
<li>可以使用gogle chrome里面的可视化基准测试，搜索chrome:&#x2F;&#x2F;tracing即可</li>
</ul>
<h3 id="2-5-4-单例模式"><a href="#2-5-4-单例模式" class="headerlink" title="2.5.4.单例模式"></a>2.5.4.单例模式</h3><ul>
<li>单例有单一数据集以及一些功能，有着代表数据的类成员变量，成员函数（对特定数据集执行操作）</li>
<li>单例类形同命名空间，C++中的单例模式仅仅只是一种组织一堆全局变量和静态函数的方式<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">//删除复制构造函数，从而禁止实例的复制</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> <span class="comment">//用于获取单例实例</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> Singleton s_singleton; <span class="comment">//可以将声明放到这里，因为static修饰的变量，不论调用多少次，只会被实际调用一次</span></span><br><span class="line">		<span class="keyword">return</span> s_singleton;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Get</span>().<span class="built_in">IFloat</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">IFloat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.5f</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125; <span class="comment">//将构造函数设置为private，使得不能创建实例</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//static Singleton m_singleton; //这是一个静态实例，也就是唯一的单例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Singleton Singleton::m_singleton; //静态成员变量需要在类外进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> num1 = Singleton::<span class="built_in">Float</span>(); <span class="comment">//这里直接使用静态函数Float</span></span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> num2 = Singleton::<span class="built_in">Get</span>().<span class="built_in">Float</span>(); <span class="comment">//通过单例引用，然后去调用Float函数(适用于Float函数不是static修饰)</span></span><br><span class="line">	std::cout &lt;&lt; num1&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
以上确保单例模式的条件：<br>1.将构造函数设置为private<br>2.将复制构造函数删除<br>3.Get函数返回一个引用单例</li>
</ul>
<h3 id="2-5-5-小字符串优化（SSO）"><a href="#2-5-5-小字符串优化（SSO）" class="headerlink" title="2.5.5.小字符串优化（SSO）"></a>2.5.5.小字符串优化（SSO）</h3><ul>
<li>小于一定大小的字符串，C++自动在小栈内进行内存分配，从而不需要堆分配，做到自动化优化</li>
</ul>
<h3 id="2-5-6-内存跟踪方法"><a href="#2-5-6-内存跟踪方法" class="headerlink" title="2.5.6.内存跟踪方法"></a>2.5.6.内存跟踪方法</h3><ul>
<li>通过对new和delete的重载，以及断点的设置从而达到跟踪的效果<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocationMetrics</span> <span class="comment">//用于跟踪的计数结构体</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> TotalAllocated = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> TotalFreed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">uint32_t</span> <span class="title">CurrentUsage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TotalAllocated - TotalFreed; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TotalAllocatedAdd</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TotalAllocated += size;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TotalFreedAdd</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TotalFreed += size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> AllocationMetrics _Metricer; <span class="comment">//创建静态实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span>  <span class="comment">//重载new</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_Metricer.<span class="built_in">TotalAllocatedAdd</span>(size);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Allocating...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* memory, <span class="type">size_t</span> size)</span> <span class="comment">//重载delete</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_Metricer.<span class="built_in">TotalFreedAdd</span>(size);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Freeing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Current Usage:&quot;</span> &lt;&lt; _Metricer.<span class="built_in">CurrentUsage</span>() &lt;&lt; <span class="string">&quot;bytes\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PrintMemory</span>();</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	std::string name = <span class="string">&quot;ztl love lxy&quot;</span>;</span><br><span class="line">	<span class="built_in">PrintMemory</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">PrintMemory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-5-7-左值和右值"><a href="#2-5-7-左值和右值" class="headerlink" title="2.5.7.左值和右值"></a>2.5.7.左值和右值</h3><ul>
<li>左值(L-value):通常在等号左边，是可以被取地址的表达式。</li>
<li>右值(R-value):通常在等号右边，是一些不能被进一步引用的临时对象或字面量</li>
<li>但是有一些情况右值可以被引用：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="comment">//加上const，就可以对字面量或者临时变量进行引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(std::string&amp;&amp; name)</span> <span class="comment">//加上两个&amp;，就只可以引用右值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string name_1 = <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">	std::string name_2 = <span class="string">&quot;isZero&quot;</span>;</span><br><span class="line">	<span class="built_in">Function</span>(name_1);</span><br><span class="line">	<span class="built_in">Function</span>(name_2);</span><br><span class="line">	<span class="built_in">Function</span>(name_1 + name_2); <span class="comment">//这里name_1+name_2属于是临时变量</span></span><br><span class="line">	<span class="built_in">Function</span>(<span class="string">&quot;ztl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-5-8-移动语义"><a href="#2-5-8-移动语义" class="headerlink" title="2.5.8.移动语义"></a>2.5.8.移动语义</h3><ul>
<li>通过&amp;&amp;标记的引用类型，绑定到右值或者临时对象<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>() = <span class="keyword">default</span>; <span class="comment">//原始构造函数</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* name) <span class="comment">//创建构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">		m_size = <span class="built_in">strlen</span>(name);</span><br><span class="line">		m_name = <span class="keyword">new</span> <span class="type">char</span>[m_size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_name, name, m_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; string) <span class="comment">//复制构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">		m_size = string.m_size;</span><br><span class="line">		m_name = <span class="keyword">new</span> <span class="type">char</span>[m_size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_name, string.m_name, m_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(String&amp;&amp; name) <span class="keyword">noexcept</span> <span class="comment">//移动语义构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		m_size = name.m_size;</span><br><span class="line">		m_name = name.m_name; <span class="comment">//将指针传递给m_name，通过浅拷贝</span></span><br><span class="line"></span><br><span class="line">		name.m_size = <span class="number">0</span>;</span><br><span class="line">		name.m_name = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_name[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_name;</span><br><span class="line">	<span class="type">uint32_t</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">		:<span class="built_in">m_string</span>(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>(String&amp;&amp; name) <span class="comment">//移动语义</span></span><br><span class="line">		:<span class="built_in">m_string</span>(std::<span class="built_in">move</span>(name))&#123;&#125; <span class="comment">//这里std::move()也可以是(String&amp;&amp;)name。</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;m_string.<span class="built_in">print</span>();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	String m_string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Entity <span class="title">e</span><span class="params">(<span class="string">&quot;ztl&quot;</span>)</span></span>;</span><br><span class="line">	e.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>std::move就是将一个已经存在的变量，转换成一个临时变量，从而作为移动语义函数或者移动赋值操作符</li>
</ul>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>.fbx文件使用</title>
    <url>/Blog/2024/02/02/FBX%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一、三个组成部分"><a href="#一、三个组成部分" class="headerlink" title="一、三个组成部分"></a>一、三个组成部分</h3><ul>
<li><strong>mesh</strong>：网格，定义物体形状</li>
<li><strong>meterial</strong>：材质，定义表面光学特性</li>
<li><strong>textures</strong>：贴图，定义表面像素颜色</li>
</ul>
<h3 id="二、-fbx使用方式"><a href="#二、-fbx使用方式" class="headerlink" title="二、.fbx使用方式"></a>二、.fbx使用方式</h3><h4 id="1、直接拖动"><a href="#1、直接拖动" class="headerlink" title="1、直接拖动"></a>1、直接拖动</h4><ul>
<li><strong>选择.fbx文件，直接拖到层级窗口</strong></li>
<li><strong>观察节点图标</strong></li>
<li><strong>选中节点，观察inspector中的操作按钮</strong></li>
</ul>
<h4 id="2、材质替换"><a href="#2、材质替换" class="headerlink" title="2、材质替换"></a>2、材质替换</h4><ul>
<li><strong>选择.fbx文件</strong></li>
<li><strong>在inspector里面切到materials属性-&gt;Use Embeded Materials-&gt;On Demand Remap:映射新的材质</strong></li>
<li><strong>Apply应用设置</strong></li>
</ul>
<h5 id="or……"><a href="#or……" class="headerlink" title="or……"></a>or……</h5><ul>
<li><strong>选中.fbx文件</strong></li>
<li><strong>Location：Use External Materials：使用外部材质</strong></li>
<li><strong>Apply，可以获得内嵌材质解压缩后的Materials目录</strong></li>
<li><strong>直接对解压缩后的材质文件进行修改</strong></li>
</ul>
<h4 id="3、分解重组"><a href="#3、分解重组" class="headerlink" title="3、分解重组"></a>3、分解重组</h4><ul>
<li><strong>将fbx文件中的材质单独拿出来使用</strong></li>
</ul>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>UI框架</title>
    <url>/Blog/2024/04/29/UI%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="框架要素（MVC模式）"><a href="#框架要素（MVC模式）" class="headerlink" title="框架要素（MVC模式）"></a>框架要素（MVC模式）</h1><ul>
<li>UIManager：将manager设置为单例模式</li>
<li>BasePanel：用于控制UI的一些函数，需要继承Monobehaviour以对其他节点进行控制</li>
<li>界面配置关系：UI名称、UI预制体路径等</li>
</ul>
<h2 id="1-UIManager"><a href="#1-UIManager" class="headerlink" title="1.UIManager"></a>1.UIManager</h2><ul>
<li>确保UIManager是单例模式</li>
<li>创建字典来分别保存路径、预制体、以及已经打开的UI</li>
<li>利用UIConst作为不同UI配置</li>
<li>调用BasePanel实例的open和close<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UIManager _uiManager;</span><br><span class="line">    <span class="comment">//预制体字典</span></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, GameObject&gt; prefabsLists;</span><br><span class="line">    <span class="comment">//路径字典</span></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pathLists;</span><br><span class="line">    <span class="comment">//已经打开的UI</span></span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, BasePanel&gt; panelLists;</span><br><span class="line">    <span class="keyword">private</span> Transform _uiRoot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_uiManager == <span class="literal">null</span>)</span><br><span class="line">                _uiManager = <span class="keyword">new</span> UIManager();</span><br><span class="line">            <span class="keyword">return</span> _uiManager;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitUI();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UI界面配置，名称与Prefabs路径等</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _uiRoot = UIRoot;</span><br><span class="line">        panelLists = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, BasePanel&gt;();</span><br><span class="line">        prefabsLists = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, GameObject&gt;();</span><br><span class="line">        pathLists = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; UIConst.MainPanel, <span class="string">&quot;Prefabs/UI/MainPanel&quot;</span> &#125;,</span><br><span class="line">            &#123; UIConst.SuccessPanel, <span class="string">&quot;Prefabs/UI/SuccessPanel&quot;</span> &#125;,</span><br><span class="line">            &#123; UIConst.FailPanel, <span class="string">&quot;Prefabs/UI/FailPanel&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取根节点</span></span><br><span class="line">    <span class="keyword">private</span> Transform UIRoot</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_uiRoot == <span class="literal">null</span>)</span><br><span class="line">                _uiRoot = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line">            <span class="keyword">return</span> _uiRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasePanel <span class="title">OpenPanel</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BasePanel panel = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (panelLists.TryGetValue(name, <span class="keyword">out</span> panel))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(name + <span class="string">&quot;界面已经打开&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!pathLists.TryGetValue(name, <span class="keyword">out</span> path))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(name + <span class="string">&quot;的UI路径出错！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        GameObject panelPrefabs = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prefabsLists.TryGetValue(name, <span class="keyword">out</span> panelPrefabs))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> realpath = path;</span><br><span class="line">            panelPrefabs = Resources.Load&lt;GameObject&gt;(realpath) <span class="keyword">as</span> GameObject;</span><br><span class="line">            prefabsLists.Add(name, panelPrefabs);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打开界面</span></span><br><span class="line">        GameObject panelObject = GameObject.Instantiate(panelPrefabs);</span><br><span class="line">        panel = panelObject.GetComponent&lt;BasePanel&gt;();</span><br><span class="line">        panel.OpenPanel(name);</span><br><span class="line">        panelLists.Add(name, panel);</span><br><span class="line">        <span class="keyword">return</span> panel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ClosePanel</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BasePanel panel = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!panelLists.TryGetValue(name, <span class="keyword">out</span> panel))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;界面未打开！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        panel.ClosePanel();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UI定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIConst</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> MainPanel = <span class="string">&quot;MainPanel&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> SuccessPanel = <span class="string">&quot;SuccessPanel&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> FailPanel = <span class="string">&quot;FailPanel&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2-BasePanel"><a href="#2-BasePanel" class="headerlink" title="2.BasePanel"></a>2.BasePanel</h2><ul>
<li>基本打开和关闭方法<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BasePanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="built_in">bool</span> isReMove = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">protected</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OpenPanel</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">this</span>._name = name;</span><br><span class="line">      gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ClosePanel</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">      isReMove = <span class="literal">true</span>;  </span><br><span class="line">      gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">      Destroy(gameObject);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UIManager.Instance.panelLists.ContainsKey(_name))</span><br><span class="line">      &#123;</span><br><span class="line">         UIManager.Instance.panelLists.Remove(_name);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="3-界面配置关系"><a href="#3-界面配置关系" class="headerlink" title="3.界面配置关系"></a>3.界面配置关系</h2><p>Unity中可以使用两种方式，一种是Excel导入，一种是使用Unity自带的</p>
]]></content>
  </entry>
  <entry>
    <title>Games101</title>
    <url>/Blog/2024/02/13/Games101/</url>
    <content><![CDATA[<h1 id="Games101"><a href="#Games101" class="headerlink" title="Games101"></a>Games101</h1><h2 id="1-变换（Transformation）"><a href="#1-变换（Transformation）" class="headerlink" title="1.变换（Transformation）"></a>1.变换（Transformation）</h2><h3 id="1-1MVP变换-将物体转化到-1-1-3的立方体上面"><a href="#1-1MVP变换-将物体转化到-1-1-3的立方体上面" class="headerlink" title="1.1MVP变换-&gt;将物体转化到[-1, 1]^3的立方体上面"></a>1.1MVP变换-&gt;将物体转化到[-1, 1]^3的立方体上面</h3><h2 id="2-光栅化（Rasterization）"><a href="#2-光栅化（Rasterization）" class="headerlink" title="2.光栅化（Rasterization）"></a>2.光栅化（Rasterization）</h2><ul>
<li>就是将MVP转化的结果，画到二维数组上面</li>
</ul>
<h3 id="2-1-屏幕（pixel）"><a href="#2-1-屏幕（pixel）" class="headerlink" title="2.1.屏幕（pixel）"></a>2.1.屏幕（pixel）</h3><ul>
<li>颜色表示：RGB</li>
<li>屏幕：二维数组，从左下角的(0, 0)开始，所以每一个像素(x, y)的中心在于(x+0.5, y+0.5)。</li>
</ul>
<h3 id="2-2-画到屏幕上"><a href="#2-2-画到屏幕上" class="headerlink" title="2.2.画到屏幕上"></a>2.2.画到屏幕上</h3><ul>
<li>[-1, 1]^3的立方体转化到[0, h]高度以及[0, w]宽度上面：<br>1.将立方体拉伸到h，w<br>2.将立方体移到中心<br>变换矩阵：</li>
</ul>
<h3 id="2-3-三角形作为Mesh"><a href="#2-3-三角形作为Mesh" class="headerlink" title="2.3.三角形作为Mesh"></a>2.3.三角形作为Mesh</h3><ul>
<li>为何选择三角形<br>1.最为基本的图形<br>2.任何图像都可以拆成三角形<br>3.三个顶点的属性定义之后，可以对三角形内部进行插值计算</li>
<li>采样（Sample）：从不同的位置取值,将函数离散化；重复频域</li>
<li>给定一个三角形，要对其采样，需要对每个屏幕空间中每个像素的中心进行一个判断，看是否在三角形内部<br>这里涉及到了叉积，三角形ABC，以及一个未知点Q，如果<strong>AB</strong> 和 <strong>AQ</strong>的叉积，与<strong>BC</strong> 和 <strong>BQ</strong>的叉积，以及<strong>CA</strong> 和 <strong>CQ</strong>的叉积方向一致（右手螺旋定则），说明点Q在三角形内部；否则Q点在三角形外部</li>
<li>如果点落在三角形上，有些定则是：计上不计下，计左不计右</li>
<li>三角形包围盒（BoundingBox）：不需要将所有像素进行判断，只需要将三个顶点，MAX&#x2F;MIN(A.x&#x2F;y,B.x&#x2F;y,C.x&#x2F;y)分别求出来</li>
<li>现实生活中LCD<br>BayerPattern：红绿蓝组成图案，绿色偏多（人眼对于绿色更为敏感）</li>
</ul>
<h3 id="2-4-走样（Aliasing，Jaggies）"><a href="#2-4-走样（Aliasing，Jaggies）" class="headerlink" title="2.4.走样（Aliasing，Jaggies）"></a>2.4.走样（Aliasing，Jaggies）</h3><ul>
<li>因为采样率有限，所以导致走样</li>
<li>Artifacts：图形学中的瑕疵  </li>
<li>由于走样产生的瑕疵：锯齿（Jaggies）、摩尔纹（Moire）、滚轮（Wagon Wheel Effect）</li>
<li>走样原理：信号改变太快，但是采样太慢了</li>
<li>频域（Frequency Domain）<br>频谱中高频意味着图像的边界，低频意味着图像的平坦区域，大块背景；两条亮白色线意味着时域图的边界发生剧烈频域变化</li>
<li>反走样（Anti Aliasing）：<br>1.滤波（模糊，卷积）：模糊处理，也就是低通滤波，然后进行采样。不能反过来，因为先采样已经走样了，然后对走样的信号进行模糊处理<br>2.多重采样抗锯齿（MSAA）：将每一个像素取不同采样点，计算更精确一些的图像属性，并没有实际增大分辨率。但是增大计算量，消耗性能</li>
<li>其他反走样：<br>FXAA（Fast Approximate AA）：图像后处理，与采样无关，速度很快<br>TAA（Temporal AA）：采用上一帧的像素值</li>
</ul>
<h3 id="2-5-深度缓存（Z-buffering）"><a href="#2-5-深度缓存（Z-buffering）" class="headerlink" title="2.5.深度缓存（Z-buffering）"></a>2.5.深度缓存（Z-buffering）</h3><ul>
<li>画家算法：先绘制背景，然后逐一绘制前景中的物体，后画的会覆盖前画的物体。局限：多个物体相互遮挡，导致不能判断深度，复杂度为O(nlogn)</li>
<li>z-buffer算法：通过对每一个像素进行值替换，与顺序无关，只与深度有关。（深度缓存发生在每一个像素里面）复杂度为O(n)<br>需要额外创建buffer：<br>frame-buffer：实际要展示的存储值<br>depth-buffer:每一个像素对应的深度值<br>算法原理：先是所有像素设置为无限大，对于一个像素中，看它的深度大于还是小于当前像素的深度，小于替换，大于就不变。</li>
</ul>
<h2 id="3-着色（Shading）"><a href="#3-着色（Shading）" class="headerlink" title="3.着色（Shading）"></a>3.着色（Shading）</h2><ul>
<li>着色：对不同物体应用不同材质的过程（不同材质对于光的反应不同）</li>
</ul>
<h3 id="3-1-布林冯模型-Blinn-Phong-Reflectance-Model-："><a href="#3-1-布林冯模型-Blinn-Phong-Reflectance-Model-：" class="headerlink" title="3.1.布林冯模型(Blinn-Phong Reflectance Model)："></a>3.1.布林冯模型(Blinn-Phong Reflectance Model)：</h3><ul>
<li>高光(Specular highlights):光源直射光。<br>引入半程向量<strong>h</strong>，<strong>h</strong> &#x3D; bisector(<strong>v</strong>, <strong>l</strong>)，即(<strong>v</strong> + <strong>l</strong>)&#x2F;||(<strong>v</strong> + <strong>l</strong>)||。cosα &#x3D; <strong>n</strong> * <strong>h</strong>，其中α为半程向量和法线夹角。<br>Ls &#x3D; Ks(I&#x2F;r^2) * MAX(0, <strong>n</strong> * <strong>h</strong>)^p<br>Ks表示白色系数,p用于限制视线方向的高光范围，通常为100~200  </li>
<li>漫反射(Diffuse reflection):与物体表面法线有关，根据光线与物体表面法线夹角有关，cosθ &#x3D; <strong>l</strong> * <strong>n</strong>,其中<strong>l</strong>为光线方向，<strong>n</strong>为物体法线方向。因此得到<br>Ld &#x3D; Kd(I&#x2F;r^2) * MAX(0, <strong>l</strong> * <strong>n</strong>)<br>其中Kd为材质的漫反射系数，反射出去的颜色为没有吸收的能量，如果表示为RGB值，则表示颜色。由于均匀反射出去，那么从任意一个方向观测都是一样结果，因此与观测方向无关  </li>
<li>环境光(Ambient lighting):均匀间接光照结果<br>La &#x3D; Ka * Ia<br>Ka是环境光系数，Ia为环境光强度<br>与视觉发向、光照方向都无关，是一个常量<br>L &#x3D; Ls + Ld + La</li>
<li>shading是局部的,没有shadow，也就是忽略所有的其他物体存在，只考虑自己</li>
</ul>
<h3 id="3-2-Shading频率"><a href="#3-2-Shading频率" class="headerlink" title="3.2.Shading频率"></a>3.2.Shading频率</h3><ul>
<li>Shading 频率：一个平面进行一次BP模型<br>Flat shading：三角形着色，每一个三角形都是一个颜色，对于平滑表面不太适合<br>Gouraud shading：顶点着色<br>Phong shading：像素着色</li>
<li>着色频率取决于物体本身平面频率如何</li>
<li>顶点法线求法：对顶点四周平面进行加权或者不加权平均。</li>
<li>通过重心坐标获得顶点之间的插值法线</li>
</ul>
<h3 id="3-3-渲染管线"><a href="#3-3-渲染管线" class="headerlink" title="3.3.渲染管线"></a>3.3.渲染管线</h3><ol>
<li>输入场景（点）  shader，可以在硬件里面执行的，里面有控制顶点和像素如何着色的</li>
<li>投影</li>
<li>形成三角形</li>
<li>光栅化</li>
<li>着色</li>
<li>输出<br>GPU：Graphics Process Unit，图形处理单元<br>着色器：顶点着色器、像素着色器<br>shadertoy.com</li>
</ol>
<h3 id="3-4-纹理映射（Texture-Mapping）"><a href="#3-4-纹理映射（Texture-Mapping）" class="headerlink" title="3.4.纹理映射（Texture Mapping）"></a>3.4.纹理映射（Texture Mapping）</h3><h4 id="3-4-1-纹理应用"><a href="#3-4-1-纹理应用" class="headerlink" title="3.4.1.纹理应用"></a>3.4.1.纹理应用</h4><ul>
<li>物体表面实际上是2D的，也就是将一张图片贴在3D物体上，这张图就是纹理（Texture），贴的过程就叫做映射</li>
<li></li>
<li>纹理上设定uv坐标系</li>
<li>对一个采样点，利用重心坐标（从面积算出）算出uv（利用重心坐标和三个顶点得到uv）</li>
<li>纹理定义的就是Diffuse reflect里面的Kd</li>
</ul>
<h4 id="3-4-2-纹理对应"><a href="#3-4-2-纹理对应" class="headerlink" title="3.4.2.纹理对应"></a>3.4.2.纹理对应</h4><ul>
<li>纹理太小（需要Texture Maginification）：<br>四舍五入(Nearest)<br>线性插值(Bilinear Interpolation)：对周围四个uv值进行插值<br>二次立方(Bicubic)：对周围16个值进行插值</li>
<li>纹理太大(导致出现纹理混叠):<br>范围查询(Mipmap):快速，但是只能适用于简单规则正方形。将一张纹理放小一半，如256 * 256到128 * 128…将存储量变小，仅仅是原本的三分之一。<br>且Mipmap会将第D&#x3D;log2L层寻找<br>如果在两层之间，如0和1之间的0.8层，则可以进行第三步插值，也就是三线性插值<br>各向异性过滤(Anisotropic Filtering):对于矩形查询优化，生成了其他单水平或垂直方向图，开销为原本三倍，也就是Ripmap<br>EWA Filtering：多次查询圆形</li>
</ul>
<h3 id="3-5-重心坐标-Barycentric-coodinates"><a href="#3-5-重心坐标-Barycentric-coodinates" class="headerlink" title="3.5.重心坐标(Barycentric coodinates)"></a>3.5.重心坐标(Barycentric coodinates)</h3><ul>
<li>顶点着色的时候，需要对三角形内部进行插值(纹理uv坐标，颜色，法线方向)，也就需要利用重心坐标</li>
<li>重心坐标定义在三角形内，设▲ABC，则同一个平面中任意一个点(x,y),都可以得到(x, y) &#x3D; αA + βB + γC，其中α + β + γ &#x3D; 1.如果三者都大于0，则点在三角形内。重心坐标就是(α， β， γ)<br>ABC内切圆心O，则α &#x3D; Sboc&#x2F;Sabc，β &#x3D; Saoc&#x2F;Sabc，γ &#x3D; Saob&#x2F;Sabc。三角形面积三等分的点对于重心坐标就是(1&#x2F;3, 1&#x2F;3, 1&#x2F;3)</li>
<li>对于插值属性，同样是使用重心坐标</li>
<li>重心坐标缺点：光栅化时，三角形形状在投影下是有缺陷的，不确定的，与原本三角形重心坐标不同。</li>
</ul>
<h3 id="3-6-纹理应用（Application）"><a href="#3-6-纹理应用（Application）" class="headerlink" title="3.6.纹理应用（Application）"></a>3.6.纹理应用（Application）</h3><h4 id="3-6-1-环境映射"><a href="#3-6-1-环境映射" class="headerlink" title="3.6.1.环境映射"></a>3.6.1.环境映射</h4><ul>
<li>球面映射(存在扭曲现象)</li>
<li>立方体映射</li>
</ul>
<h4 id="3-6-2-其他贴图"><a href="#3-6-2-其他贴图" class="headerlink" title="3.6.2.其他贴图"></a>3.6.2.其他贴图</h4><ul>
<li>凹凸&#x2F;法线贴图(Bump&#x2F;Normal Map)：可以展示凹凸效果，但是并没有实际对几何体改变<br>n(p) &#x3D; (0, 0, 1)<br>dp&#x2F;du &#x3D; c1 * [h(u+1) - h(u)]<br>dp&#x2F;dv &#x3D; c2 * [h(v+1) - h(v)]<br>n &#x3D; (-dp&#x2F;du, -dp&#x2F;dv, 1)</li>
<li>位移贴图(Displacement Mapping)：将实际的几何体进行改变<br>缺点：需要更多采样点，模型需要足够细致</li>
</ul>
<h4 id="3-6-3-三维纹理"><a href="#3-6-3-三维纹理" class="headerlink" title="3.6.3.三维纹理"></a>3.6.3.三维纹理</h4><ul>
<li>利用三维空间中的噪声函数进行纹理映射（例如Perlin Noise）  </li>
<li>预先进行环境光遮蔽计算模型阴影  </li>
<li>体渲染通过三维纹理记录信息，然后进行渲染</li>
</ul>
<h2 id="4-几何-Geometry"><a href="#4-几何-Geometry" class="headerlink" title="4.几何(Geometry)"></a>4.几何(Geometry)</h2><h3 id="4-1-几何的表示方法"><a href="#4-1-几何的表示方法" class="headerlink" title="4.1.几何的表示方法"></a>4.1.几何的表示方法</h3><h4 id="4-1-1-两种方法"><a href="#4-1-1-两种方法" class="headerlink" title="4.1.1.两种方法"></a>4.1.1.两种方法</h4><ul>
<li>隐式（Implicit):直接将几何体使用公式表示出来<br>优点：可以直接判断一个点在几何体内外<br>缺点：不能直接看出几何体形状<br>举例：（x² + 9y²&#x2F;4 + z² - 1）³ &#x3D; x²z³ + 9y²z³&#x2F;80，这是一个心形</li>
<li>显式（Explicit):把点直接给出或者参数映射（u，v）-&gt;（x，y，z）<br>优点：可以直观得到几何体（可以是几何体点的集合，也可以是映射关系明确）<br>缺点：不能很容易判断一个点是否在几何体内外</li>
</ul>
<h4 id="4-1-2-一些其他的隐式"><a href="#4-1-2-一些其他的隐式" class="headerlink" title="4.1.2.一些其他的隐式"></a>4.1.2.一些其他的隐式</h4><ul>
<li>代数曲面（algebraic surface）：通过一些代数式表示</li>
<li>构造立体几何法（Constructive Solid Geometry，CSG）：通过一些几何体的交、并、差等操作</li>
<li>距离函数（Distance Function，SDF）：不直接描述表面，而是描述每一个点到一个表面的最短距离，正在外，负在内，通过融合（blend）距离函数，将这些点表示出来</li>
<li>水平集（Level Set Method）：将距离函数用数组表示，从而进行绘制</li>
<li>分形（Fractals）：不断重复自身，类似于函数递归概念</li>
</ul>
<h3 id="4-2-曲线和曲面（Curves-and-Surfaces，显式几何）"><a href="#4-2-曲线和曲面（Curves-and-Surfaces，显式几何）" class="headerlink" title="4.2.曲线和曲面（Curves and Surfaces，显式几何）"></a>4.2.曲线和曲面（Curves and Surfaces，显式几何）</h3><h4 id="4-2-1-几个例子"><a href="#4-2-1-几个例子" class="headerlink" title="4.2.1.几个例子"></a>4.2.1.几个例子</h4><ul>
<li>点云（Point Cloud）：用密集点进行几何体构造<br>可以构造任意一种几何体，在扫描里面经常使用</li>
<li>多边形面（Polygon Mesh）：三角形或者四边形表达几何体。是应用最广泛的方式</li>
<li>.obj文件<br>实际上就是.txt文件，用于存储一些数据，例如纹理，坐标，法线，重心</li>
</ul>
<h4 id="4-2-2-曲线（Curves）"><a href="#4-2-2-曲线（Curves）" class="headerlink" title="4.2.2.曲线（Curves）"></a>4.2.2.曲线（Curves）</h4><ul>
<li>贝塞尔曲线（Bézier Curve）：用一系列控制点定义曲线  </li>
<li>属性：<br>1.经过起始点和终点<br>2.起始切线和结尾切线都是(n-1)(b0-b1)<br>3.仿射曲线<br>4.所有点都在凸包内</li>
<li>德卡斯特里奥算法：定义一个线段AB上面的点C，并系数u（0 &lt; u &lt; 1），使得AC &#x3D; u AB，得到C坐标 C &#x3D; uA + (1-u)B<br>伯恩斯坦：b^n(t) &#x3D; &amp;&amp;Σb_jB_j^n(t)&amp;&amp;</li>
<li>逐段贝塞尔曲线：当控制点太多时，就很难控制。也就是切点<br>C0连续：点线结合<br>C1连续：一阶导数连续</li>
<li>样条（Splines）：一个可控的曲线</li>
</ul>
<h4 id="4-2-3-曲面（Surfaces）"><a href="#4-2-3-曲面（Surfaces）" class="headerlink" title="4.2.3.曲面（Surfaces）"></a>4.2.3.曲面（Surfaces）</h4><ul>
<li>贝塞尔曲面：将多条贝塞尔曲线上面的点作为控制点，制作贝塞尔曲线</li>
</ul>
<h4 id="4-2-4-几何处理"><a href="#4-2-4-几何处理" class="headerlink" title="4.2.4.几何处理"></a>4.2.4.几何处理</h4><h5 id="4-2-4-1-网格细分（Mesh-Subdivision）网格正规化（Mesh-Regularization）"><a href="#4-2-4-1-网格细分（Mesh-Subdivision）网格正规化（Mesh-Regularization）" class="headerlink" title="4.2.4.1.网格细分（Mesh Subdivision）网格正规化（Mesh Regularization）"></a>4.2.4.1.网格细分（Mesh Subdivision）网格正规化（Mesh Regularization）</h5><ul>
<li>卢氏细分（Loop Subdivision)：<br>1.将三角形每个线段中点作为新点，并且相连，得到四个三角形<br>2.将新生成的点平移，将周围四个点进行加权平均，得到新点的位置；旧点度为n，以及权重u，则旧点变为(1-n * u) * 原本位置+u*周围旧点位置之和   </li>
<li>Catmull-Clark Subdivision：用于非三角形<br>非四边形面（Non-quad face）：不是四边形的面<br>奇异点（extraordinary vertex）：只要度不是4都是奇异点<br>1.每一个线取中点，每一个面也取一个点<br>2.将这些点相连<br>第一次操作之后：<br>1.奇异点增加<br>2.非四边形面消失<br>实际上也就是非四边形变成奇异点，此后再次进行的时候，都是非四边形</li>
</ul>
<h5 id="4-2-4-2-网格简化（Mesh-Simplification）"><a href="#4-2-4-2-网格简化（Mesh-Simplification）" class="headerlink" title="4.2.4.2.网格简化（Mesh Simplification）"></a>4.2.4.2.网格简化（Mesh Simplification）</h5><ul>
<li>网格简化：有些时候只需要一个大概的轮廓就行，不需要那么精细的网格。例如远处的物体</li>
<li>边坍缩(Edge Collaps)：将边结合起来成一个点<br>二次误差度量(Quadric Error Metric)：当前顶点到其邻域所有三角面（也称关联平面）的距离平方和。<br>需要使用堆进行每一次二次误差度量</li>
</ul>
<h4 id="4-2-5-阴影-Shadow-Mapping"><a href="#4-2-5-阴影-Shadow-Mapping" class="headerlink" title="4.2.5.阴影(Shadow Mapping)"></a>4.2.5.阴影(Shadow Mapping)</h4><ul>
<li>在阴影里面的定义：在光源点看不到这个点，也不能被相机看到</li>
<li>Shadow Mapping只能处理点光源投射的阴影，处理的是硬阴影</li>
<li>步骤：<br>1.从光源看向场景，光栅化，记录每一个点的深度为多少（z-buffer）<br>2.从相机看向场景，光栅化，计算点到光源成像的深度为多少，并且与第一步的z-buffer进行比较，如果一样，说明可见，如果不一致，就在阴影里</li>
<li>有一些误差问题，因为浮点型很难判断是否相等。用两者距离在一个小范围之内，也就是bias小浮动</li>
<li>硬阴影和软阴影：<br>硬阴影：要么可见要么不可见<br>软阴影：有一定过渡，完全看不到为本影，能看到一点叫做伴影。产生的根本原因是光源本身有大小</li>
</ul>
<h1 id="5-光线追踪（Ray-Tracing）"><a href="#5-光线追踪（Ray-Tracing）" class="headerlink" title="5.光线追踪（Ray Tracing）"></a>5.光线追踪（Ray Tracing）</h1><ul>
<li>产生的原因：光栅化不能解决软阴影、且有些光照会反射多次</li>
<li>特点：光线追踪很精确，但是非常慢，适用于制作动画，但是实时渲染很慢</li>
</ul>
<h2 id="5-1-光线追踪"><a href="#5-1-光线追踪" class="headerlink" title="5.1.光线追踪"></a>5.1.光线追踪</h2><ul>
<li>光线的定义：<br>1.光沿直线传播<br>2.光与光之间不会碰撞<br>3.光路可逆</li>
<li>递归光线追踪（Recursive（Whitted-Style） Ray Tracing）：<br>光源（light source）、首发光线（primary rays）、二次光线（secondary rays）<br>从相机或视线位置发出光线，射到目标像素，然后根据折射或者反射计算光线去向（实际也就是光线来源），然后每次判断光源是否可以照射到新的像素点</li>
</ul>
<h2 id="5-2-光线表面交点（Ray-Surface-Intersection）"><a href="#5-2-光线表面交点（Ray-Surface-Intersection）" class="headerlink" title="5.2.光线表面交点（Ray-Surface Intersection）"></a>5.2.光线表面交点（Ray-Surface Intersection）</h2><ul>
<li>光线的数学定义：射线，是一个向量，每一个向量上的点都用<strong>r</strong>(t) &#x3D; o + t<strong>d</strong>，其中o为光线起始点，<strong>d</strong>为单位方向向量，t为系数  </li>
<li>光线与几何体的交点：<br>1.隐式：可以直接联立方程式<br>2.显式：对一个封闭几何体，任意一个点发出一道射线，与几何体交点为奇数个，说明点在几何体内部；偶数个，说明在几何体外部</li>
<li>判断光线是否与三角形相交：<br>先将光线与三角形的面相交得到与三角形平面的交点，然后利用之前的叉积判断这个点是否在三角形内，如果在，说明相交，；不在，说明不相交<br>光线与平面的交点求法：<br>平面方程为P：（p-p’）* <strong>N</strong> &#x3D; 0，其中p’为任意一个平面上面的点，<strong>N</strong>为平面法向量。与光线联立可得交点</li>
<li>mt算法：可以直接计算得到光线是否与三角形相交</li>
</ul>
<h2 id="5-3-光线表面交点加速"><a href="#5-3-光线表面交点加速" class="headerlink" title="5.3.光线表面交点加速"></a>5.3.光线表面交点加速</h2><p>每一个光线都要计算一次场景求交，因此需要提高速度</p>
<ul>
<li>包围盒(Bounding Volumes):利用一个包围盒将物体完全包住<br>如果光线没有经过包围盒，就不可能射过几何体  </li>
<li>光线和AABB求交：<br>将AABB看作是一个由三个对面的集合，所以当光线进入所有的对面之间，才算进入到AABB里面；只要有光线射出所有对面之间，就算出了AABB<br>算法：将光线与AABB三组对面的交点时间tmin和tmax，tenter &#x3D; max（tmin），texit &#x3D; min（tmax），如果tenter&lt;texit且texit&gt;&#x3D;0，说明光线进入了AABB</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>UnityStudy</title>
    <url>/Blog/2024/02/04/UnityStudy/</url>
    <content><![CDATA[<h1 id="Unity-使用学习"><a href="#Unity-使用学习" class="headerlink" title="Unity 使用学习"></a>Unity 使用学习</h1><ul>
<li>学习资料参考：<br><a class="link"   href="http://unity.cn/" >unity官方文档（中文版） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://b23.tv/ceAYoyi" >b站阿发教程（十分详尽） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h2 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1.基本结构"></a>1.基本结构</h2><h3 id="1-1-游戏物体"><a href="#1-1-游戏物体" class="headerlink" title="1.1.游戏物体"></a>1.1.游戏物体</h3><ul>
<li>cube：正方体  </li>
<li>sphere：球体  </li>
<li>cylinder：圆柱  </li>
<li>capsule：圆柱头  </li>
<li>plane：平面</li>
</ul>
<h3 id="1-2-资源文件"><a href="#1-2-资源文件" class="headerlink" title="1.2.资源文件"></a>1.2.资源文件</h3><ul>
<li>模型文件Model（*.fbx）</li>
<li>图片文件Texture（*.jpg&#x2F;png&#x2F;psd&#x2F;tif）</li>
<li>音频文件AudioClip（*.mp3&#x2F;wav&#x2F;aiff）</li>
<li>脚本文件Script（*.cs）</li>
<li>材质文件Meterial（*.mat）</li>
<li>场景文件Scene（*.unity）</li>
<li>描述文件Meta（*.meta）</li>
<li>预制体文件Prefab（*.prefab）</li>
</ul>
<h3 id="1-3-资源包"><a href="#1-3-资源包" class="headerlink" title="1.3.资源包"></a>1.3.资源包</h3><ul>
<li>选中资源文件或者目录</li>
<li>右键，点击export package</li>
<li>生成*.unitypackage资源包</li>
<li>依赖文件也可以一并导入</li>
</ul>
<h3 id="1-4-摄像机"><a href="#1-4-摄像机" class="headerlink" title="1.4.摄像机"></a>1.4.摄像机</h3><h4 id="1-4-1-摄像机构成"><a href="#1-4-1-摄像机构成" class="headerlink" title="1.4.1 摄像机构成"></a>1.4.1 摄像机构成</h4><ul>
<li>一个拥有camera组件的gameobject</li>
</ul>
<h4 id="1-4-2-移动方式"><a href="#1-4-2-移动方式" class="headerlink" title="1.4.2 移动方式"></a>1.4.2 移动方式</h4><ol>
<li>手工移动</li>
<li>Align with View，与3D视图对其<br>-&gt;在3D视图里面摆好角度<br>-&gt;选中camera，执行Gameobject<br>-&gt;Align with View（ctrl+shift+F）</li>
<li>可以使视角跟随物体运动：<br>-&gt;Edit<br>-&gt;Lock View to Seleted</li>
</ol>
<h3 id="1-5-脚本"><a href="#1-5-脚本" class="headerlink" title="1.5.脚本"></a>1.5.脚本</h3><h4 id="1-5-1-脚本创建和挂载"><a href="#1-5-1-脚本创建和挂载" class="headerlink" title="1.5.1 脚本创建和挂载"></a>1.5.1 脚本创建和挂载</h4><ul>
<li>脚本创建和编写</li>
<li>脚本挂载：<br>直接拖拽或者Add Component</li>
</ul>
<h4 id="1-5-2-脚本控制物体实例"><a href="#1-5-2-脚本控制物体实例" class="headerlink" title="1.5.2 脚本控制物体实例"></a>1.5.2 脚本控制物体实例</h4><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">transform.Position,物体世界坐标  </span><br><span class="line">transform.LocalPosition,物体本地坐标</span><br></pre></td></tr></table></figure></div>
<h3 id="1-6-帧更新"><a href="#1-6-帧更新" class="headerlink" title="1.6.帧更新"></a>1.6.帧更新</h3><ul>
<li><p>Update（）函数为帧更新函数,常用帧率观察：<br>Time.time，游戏时间<br>Time.deltaTime，距离上次更新时间  </p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Debug.log(<span class="string">&quot;每秒至少60帧&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>可以设置unity的帧率：  </p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Application.targetFrameRate = <span class="number">60</span>; <span class="comment">//将帧率调整为尽量60帧每秒</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-物体的运动"><a href="#1-7-物体的运动" class="headerlink" title="1.7.物体的运动"></a>1.7.物体的运动</h3><ul>
<li>物体运动实例<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> speed = <span class="number">2f</span>; <span class="comment">//设置速度</span></span><br><span class="line">        Vector3 pos = <span class="keyword">this</span>.transform.position; <span class="comment">//获取当前位置</span></span><br><span class="line">        pos.z += speed * Time.deltaTime; <span class="comment">//从速度与帧同步的联系，更改目标</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = pos; <span class="comment">//将物体移动</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
也可以使用transform.Translate(dx, dy, dz, Space.World&#x2F;Space.Self)进行帧移动：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> speed = <span class="number">2f</span>;</span><br><span class="line"><span class="built_in">float</span> distance = speed * Time.deltaTime;</span><br><span class="line"><span class="keyword">this</span>.transform.Translate(distance, <span class="number">0</span>, distance); <span class="comment">//Transform.Translate(dx, dy, dz)方法可以直接在不同方向上做增量</span></span><br></pre></td></tr></table></figure></div>
改变运动的方向<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">GameObject flag = GameObject.Find(<span class="string">&quot;flag&quot;</span>); <span class="comment">//Gameobject.Find(&quot;name_or_path&quot;)找到目标物体位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.LookAt(flag.transform); <span class="comment">//transform.LookAt(targetGameobject.Transform)将火车头转向目标位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(<span class="number">0</span>, <span class="number">0</span>, distance, Space.Self); <span class="comment">//Transform.Translate(dx, dy, dz)方法可以直接在不同方向上做增量</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-8-物体的旋转"><a href="#1-8-物体的旋转" class="headerlink" title="1.8.物体的旋转"></a>1.8.物体的旋转</h3><ul>
<li>四元组旋转(不建议使用)：  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">transform.rotation = (x, y, z, w);</span><br></pre></td></tr></table></figure></div></li>
<li>欧拉角旋转Euler Angle：   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">transform.eulerAngles = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>);  </span><br><span class="line">transform.localEulerAngles = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>可以使用transform.Rotate(x, y, z, Space.Self)进行帧旋转:  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.Rotate(<span class="number">0</span>, <span class="number">200</span> * Time.deltaTime, <span class="number">0</span>, Space.Self);</span><br></pre></td></tr></table></figure></div></li>
<li>自转与公转：<br>原理实际上就是建立父子关系，使用了空物体的技巧，将地月系统放在一个空物体下，地球放在轴心处，转动便成为公转自转</li>
</ul>
<h2 id="2-深入学习"><a href="#2-深入学习" class="headerlink" title="2.深入学习"></a>2.深入学习</h2><h3 id="2-1-脚本运行原理"><a href="#2-1-脚本运行原理" class="headerlink" title="2.1.脚本运行原理"></a>2.1.脚本运行原理</h3><ul>
<li>每个脚本都进行以下实例  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Gameobject object1 = <span class="keyword">new</span> Gameobject(); <span class="comment">//实例化节点</span></span><br><span class="line">MeshRender render = <span class="keyword">new</span> Meshrender(); <span class="comment">//实例化组件</span></span><br><span class="line">SimpleLogic script1 = <span class="keyword">new</span> SimpLogic(); <span class="comment">//实例化脚本组件</span></span><br><span class="line">Start(); <span class="comment">//初始化函数</span></span><br><span class="line">Update(); <span class="comment">//帧更新函数</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-消息函数-生命周期"><a href="#2-2-消息函数-生命周期" class="headerlink" title="2.2.消息函数&#x2F;生命周期"></a>2.2.消息函数&#x2F;生命周期</h3><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Awake(); <span class="comment">//初始化函数，仅执行一次（早于start）</span></span><br><span class="line">Start(); <span class="comment">//初始化函数，仅执行一次</span></span><br><span class="line">Update(); <span class="comment">//帧更新，每帧调用一次</span></span><br><span class="line">OnEnable(); <span class="comment">//每当组件启用时调用</span></span><br><span class="line">OnDisable(); <span class="comment">//每当组件禁用时调用</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-3-脚本执行优先级"><a href="#2-3-脚本执行优先级" class="headerlink" title="2.3.脚本执行优先级"></a>2.3.脚本执行优先级</h3><p>选中一个脚本，在inspector界面选择Execution Order，通过拖动或者手动调节脚本执行优先级（优先级值越小，优先级越高）</p>
<h3 id="2-4-主控脚本"><a href="#2-4-主控脚本" class="headerlink" title="2.4.主控脚本"></a>2.4.主控脚本</h3><p>游戏的主控逻辑存放脚本，例如：帧率，全局逻辑，全局设置等，然后放在一个主控节点上</p>
<h3 id="2-5-参数类型"><a href="#2-5-参数类型" class="headerlink" title="2.5.参数类型"></a>2.5.参数类型</h3><h4 id="2-5-1-值类型："><a href="#2-5-1-值类型：" class="headerlink" title="2.5.1. 值类型："></a>2.5.1. 值类型：</h4><p>int，float，bool，string，Vector，color<br>值类型不能为null</p>
<h4 id="2-5-2-引用类型："><a href="#2-5-2-引用类型：" class="headerlink" title="2.5.2. 引用类型："></a>2.5.2. 引用类型：</h4><p>GameObject，Transform，MeshRender，AudioSource，Meterial，Texture，AudioClip<br>都可以放到类的属性中，然后去到inspector赋值</p>
<h3 id="2-6-鼠标键盘等输入"><a href="#2-6-鼠标键盘等输入" class="headerlink" title="2.6.鼠标键盘等输入"></a>2.6.鼠标键盘等输入</h3><h4 id="2-6-1-鼠标输入"><a href="#2-6-1-鼠标输入" class="headerlink" title="2.6.1.鼠标输入"></a>2.6.1.鼠标输入</h4><ul>
<li>事件只会触发一次，并且状态每帧一次，全局事件互不干扰<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Input.GetMouseButtonDown(); <span class="comment">//鼠标按下触发（0是左键，1是右键，2是中键）</span></span><br><span class="line">Input.GetMouseButtonDown(); <span class="comment">//鼠标放开触发</span></span><br><span class="line">Input.GetMouseButton(); <span class="comment">//鼠标按住触发</span></span><br><span class="line">Input.mousePosition(); <span class="comment">//获取屏幕坐标</span></span><br></pre></td></tr></table></figure></div></li>
<li>屏幕坐标<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Camera.main.WorldToScreenPoint(worldPos); <span class="comment">//将世界坐标转换为屏幕坐标</span></span><br><span class="line">Screen.width; <span class="comment">//屏幕宽度</span></span><br><span class="line">Screen.height; <span class="comment">//屏幕高度</span></span><br></pre></td></tr></table></figure></div></li>
<li>键盘输入<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Input.GetKeyDown(keycode); <span class="comment">//键盘按下</span></span><br><span class="line">Input.GetKeyUp(keycode); <span class="comment">//键盘松开</span></span><br><span class="line">Input.GetKey(keycode); <span class="comment">//键盘按住</span></span><br><span class="line">Keycode.A; <span class="comment">//键盘A</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-7-组件调用"><a href="#2-7-组件调用" class="headerlink" title="2.7.组件调用"></a>2.7.组件调用</h3><ul>
<li>以音乐播放器为例  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">AudioSource audio = <span class="keyword">this</span>.GetComponent&lt;AudioSource&gt;(); <span class="comment">//获取AudioSource组件</span></span><br><span class="line">audio.Play(); <span class="comment">//播放</span></span><br></pre></td></tr></table></figure></div>
其中&lt;&gt;表示泛型，即获取<AudioSource>类型的组件  </li>
<li>也可以直接将所需要组件以public写出，拖拽组件所在节点，便会自动寻找到节点中的该组件</li>
<li>引用其他节点中的脚本组件同理可得，然后对组件中进行函数调用、属性修改等等</li>
<li>还可以使用消息调用方法： <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Gameobject <span class="built_in">object</span>;</span><br><span class="line"><span class="built_in">object</span>.SendMessage(<span class="string">&quot;Method&quot;</span>, index);</span><br></pre></td></tr></table></figure></div>
SendMessage的内部执行（反射机制，本质上是同步调用）：<br>1.找到target节点下所有组件<br>2.寻找Method函数<br>-&gt; 如果存在,调用它<br>-&gt; 如果不存在，继续遍历组件查找<br>-&gt; 最终如果无法匹配，则报错</li>
</ul>
<h3 id="2-8-物体获取"><a href="#2-8-物体获取" class="headerlink" title="2.8.物体获取"></a>2.8.物体获取</h3><h4 id="2-8-1-直接获取物体"><a href="#2-8-1-直接获取物体" class="headerlink" title="2.8.1.直接获取物体"></a>2.8.1.直接获取物体</h4><ul>
<li>通过Find方法（名字和路径）获取：   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Gameobject <span class="built_in">object</span> = Gameobject.Find(<span class="string">&quot;name_or_path&quot;</span>); <span class="comment">//指定name或者path获取</span></span><br></pre></td></tr></table></figure></div>
这种方法两个弊端：<br>1.不安全：如果修改节点名称，那么查找不到<br>2.需要遍历查找  </li>
<li>通过inspector拖拽获取  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Gameobject <span class="built_in">object</span>; <span class="comment">//定义一个public变量，在inspector可以获取</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="2-8-2-父子物体获取"><a href="#2-8-2-父子物体获取" class="headerlink" title="2.8.2.父子物体获取"></a>2.8.2.父子物体获取</h4><p><strong>获取需要使用Transform作为媒介</strong>  </p>
<ol>
<li>获取父级物体：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Transform parent = <span class="keyword">this</span>.transform.parent; <span class="comment">//获取父级Transform</span></span><br><span class="line">Gameobject parentNode = <span class="keyword">this</span>.transform.parent.gameObject; <span class="comment">//获取父级节点</span></span><br></pre></td></tr></table></figure></div></li>
<li>获取子级物体：<br>通过遍历获取：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(Transform child <span class="keyword">in</span> transform) <span class="comment">//遍历所有子节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		Debug.log(<span class="string">&quot;*子物体：&quot;</span> + child.name);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>
通过索引获取：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Transform firstChild = <span class="keyword">this</span>.Transform.GetChild(<span class="number">0</span>); <span class="comment">//获取所有子节点中的第一个子节点</span></span><br></pre></td></tr></table></figure></div>
通过名称查找子项：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Transform bb = <span class="keyword">this</span>.Transform.Find(<span class="string">&quot;aa/bb&quot;</span>); <span class="comment">//可以直接是名称，二级子级应该写上路径</span></span><br></pre></td></tr></table></figure></div></li>
<li>物体的操作<br>更换gameobject的父级：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.Transform.SetParent(<span class="string">&quot;name_or_path_or_null&quot;</span>); <span class="comment">//可以是名称，也可以是路径，是null时，表示一级节点</span></span><br></pre></td></tr></table></figure></div>
设置active：  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.transform.gameObject.activeSelf) <span class="comment">//作为判断条件</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>.transform.gameObject.SetActive(<span class="literal">false</span>); <span class="comment">//设置为不显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>.transform.gameObject.SetActive(<span class="literal">true</span>); <span class="comment">//设置为显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="2-9-脚本资源使用"><a href="#2-9-脚本资源使用" class="headerlink" title="2.9.脚本资源使用"></a>2.9.脚本资源使用</h3><h4 id="2-9-1单个资源使用"><a href="#2-9-1单个资源使用" class="headerlink" title="2.9.1单个资源使用"></a>2.9.1单个资源使用</h4><ul>
<li>在脚本中，资源对应变量：<br>音频文件：AudioClip<br>纹理贴图：Texture<br>材质：Material</li>
<li>以音频文件的使用为例：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AudioClip chgeAudio; <span class="comment">//定义音频文件</span></span><br><span class="line"><span class="keyword">private</span> AudioSource audioIndex; <span class="comment">//定义音频组件</span></span><br><span class="line">audioIndex = <span class="keyword">this</span>.transform.GetComponent&lt;AudioSource&gt;(); <span class="comment">//获取组件</span></span><br><span class="line">audioIndex.PlayOneShot(chgeAudio); <span class="comment">//使用组件播放音频文件</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-10-定时调用"><a href="#2-10-定时调用" class="headerlink" title="2.10.定时调用"></a>2.10.定时调用</h3><ul>
<li>定时调用Invoke*，即一般所谓的定时器<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.Invoke(<span class="string">&quot;Func&quot;</span>, delay); <span class="comment">//定时delay秒后进行Func函数调用</span></span><br><span class="line"><span class="keyword">this</span>.InvokeRepeating(<span class="string">&quot;Func&quot;</span>, delay, interval); <span class="comment">//每隔interval秒调用一次</span></span><br><span class="line"><span class="keyword">this</span>.IsInvoking(<span class="string">&quot;Func&quot;</span>); <span class="comment">//是否正在调度中，返回bool</span></span><br><span class="line"><span class="keyword">this</span>.CancelInvoke(<span class="string">&quot;Func&quot;</span>); <span class="comment">//取消调用，从调度队列中移除</span></span><br><span class="line"><span class="keyword">this</span>.CancelInvoke(); <span class="comment">//取消当前脚本所有调度</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-11-向量使用"><a href="#2-11-向量使用" class="headerlink" title="2.11.向量使用"></a>2.11.向量使用</h3><p>简单使用  </p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 v = <span class="keyword">new</span> Vector3(x, y, z); <span class="comment">//向量创建</span></span><br><span class="line"><span class="built_in">float</span> v = v.magnitude; <span class="comment">//获取向量模</span></span><br><span class="line">Vector3 v1 = v.normalized; <span class="comment">//标准化向量（模长为1）</span></span><br><span class="line">Vector.Distance(a, b); <span class="comment">//直接计算两个点之间举例</span></span><br></pre></td></tr></table></figure></div>
<p>常用几个向量：<br>Vector3.zero:(0, 0, 0)<br>Vector3.up:(0, 1, 0)<br>Vector3.right:(1, 0, 0)<br>Vector3.forward:(0, 0, 1)<br>向量乘法、点积和叉积：  </p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">b = a * <span class="number">2</span>;</span><br><span class="line">c = Vector3.Dot(a, b); <span class="comment">//点积</span></span><br><span class="line">c = Vector3.Cross(a, b); <span class="comment">//叉积</span></span><br></pre></td></tr></table></figure></div>
<p>可以使用向量作为参数：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Vector3 speed; <span class="comment">//在inspector中将向量速度输入</span></span><br><span class="line"><span class="keyword">this</span>.Transform.Translate(speed * Time.deltaTime, Space.Self); <span class="comment">//直接将向量参数输入</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-12-预制体使用"><a href="#2-12-预制体使用" class="headerlink" title="2.12.预制体使用"></a>2.12.预制体使用</h3><ul>
<li>预制体的生成与使用</li>
<li>预制体的三种编辑方式<br>1.单独编辑：双击预制体<br>2.原位编辑：选择实例Instance，Inspector里面选择open<br>3.覆盖修改：选中Instance，编辑后选中Overri|Apply，应用编辑；Override|Revert，取消编辑</li>
<li>脚本创建预制体实例  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Object.Instantiate(prefab, parent); <span class="comment">//prebfab是预制体，parent是可以设置预制体的生成父节点。返回值为一个GameObject</span></span><br></pre></td></tr></table></figure></div></li>
<li>创建实例后的初始化<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Instance.transform.position = (x, y, z); <span class="comment">//可以使用空节点作为定位，获取空节点位置</span></span><br><span class="line">Instance.transform.eulerAngles = (x, y, z); <span class="comment">//实例的角度</span></span><br></pre></td></tr></table></figure></div></li>
<li>实例的销毁  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Object.Destroy(Instance, delay); <span class="comment">//delay秒后销毁实例对象。Destroy会在Update之后执行</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="3-物理与特效"><a href="#3-物理与特效" class="headerlink" title="3.物理与特效"></a>3.物理与特效</h2><h3 id="3-1-物理系统"><a href="#3-1-物理系统" class="headerlink" title="3.1.物理系统"></a>3.1.物理系统</h3><ul>
<li>添加刚体组件Rigidbody，添加后，由物理引擎接管物体运动</li>
</ul>
<h3 id="3-2-刚体碰撞"><a href="#3-2-刚体碰撞" class="headerlink" title="3.2.刚体碰撞"></a>3.2.刚体碰撞</h3><ul>
<li>碰撞体Colider，描述了物体的碰撞范围<br>Box Collider：长方碰撞体<br>SphereCollider：球形碰撞体</li>
</ul>
<h3 id="3-3-反弹与摩擦"><a href="#3-3-反弹与摩擦" class="headerlink" title="3.3.反弹与摩擦"></a>3.3.反弹与摩擦</h3><ul>
<li>创建Physic Material</li>
<li>参数：</li>
</ul>
<p>Dynamic Friction：动摩擦系数<br>Static Friction：静摩擦系数<br>Bounciness：反弹系数</p>
<h3 id="3-4-碰撞检测"><a href="#3-4-碰撞检测" class="headerlink" title="3.4.碰撞检测"></a>3.4.碰撞检测</h3><ul>
<li>碰撞<br>条件：两个物体都有碰撞体+至少有个物体有刚体。<br>注意：<br>（1）Unity中碰撞体独立于物体大小，与物体的MeshFilter大小无关。<br>（2）只有碰撞体才能被射线检测到，否则无法被检测。<br>（3）只有刚体才会有受力效果。<br>（4）isKinematic就有点像把刚体关了，但没完全关，因为保留了物理特性如质量，速度等等。</li>
<li>触发<br>条件：产生碰撞的条件(两个物体都有碰撞体+至少有个物体有刚体)+两个物体至少有个有触发器<br>注意：<br>（1）碰撞检测和触发检测不能同时触发，如果是触发检测方法调用就不可能会有碰撞检测方法调用。</li>
</ul>
<h2 id="附：unity以及rider快捷键"><a href="#附：unity以及rider快捷键" class="headerlink" title="附：unity以及rider快捷键"></a>附：unity以及rider快捷键</h2><h3 id="rider："><a href="#rider：" class="headerlink" title="rider："></a>rider：</h3><p>快速注释：ctrl+K，ctrl+C<br>选中当前灭光标所在单词：ctrl+W<br>多光标：shift+alt+鼠标&#x2F;上下键</p>
<h3 id="unity："><a href="#unity：" class="headerlink" title="unity："></a>unity：</h3><p>可以使视角跟随物体运动：-&gt;Edit-&gt;Lock View to Seleted</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Particle System</title>
    <url>/Blog/2024/02/08/Unity%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<h1 id="Unity-Particle-System"><a href="#Unity-Particle-System" class="headerlink" title="Unity Particle System"></a>Unity Particle System</h1><h3 id="1-1-粒子系统"><a href="#1-1-粒子系统" class="headerlink" title="1.1.粒子系统"></a>1.1.粒子系统</h3><ul>
<li>添加一个ParticleSystem</li>
<li>预览与运行</li>
<li>模块与参数<br>1个主模块（基础参数）和22个子模块（扩展参数）<br>默认启用3个子模块：</li>
</ul>
<ol>
<li>Emission，发射的频率</li>
<li>Shape，粒子发生器的形状</li>
<li>Render，粒子的显示</li>
</ol>
<h3 id="1-2-粒子本质"><a href="#1-2-粒子本质" class="headerlink" title="1.2.粒子本质"></a>1.2.粒子本质</h3><ul>
<li>粒子是一个个小纸片，而粒子系统就是一个不短创建并且发射出去的粒子发生器</li>
<li>可以使用Render中的render mode进行修改渲染模式：<br>Billbord：广告牌，自动旋转，始终面向相机</li>
</ul>
<h3 id="1-3-贴图"><a href="#1-3-贴图" class="headerlink" title="1.3.贴图"></a>1.3.贴图</h3><ul>
<li>对于贴图material，使用着色器：<br>Shader：Praticles|Standered Unit<br>Render Mode:Additive<br>Color Mode:Multiply<br>Albedo:指定贴图</li>
</ul>
<h3 id="1-4-周期和时长"><a href="#1-4-周期和时长" class="headerlink" title="1.4.周期和时长"></a>1.4.周期和时长</h3><ul>
<li>Duration：周期，粒子系统的工作时长</li>
<li>Looping：循环，粒子系统工作一次&#x2F;循环工作</li>
<li>Prewarm：预热，粒子系统是否先预热一个周期</li>
<li>Strat Lifetime：粒子的生命时长，默认五秒</li>
</ul>
<h3 id="1-5-模拟空间"><a href="#1-5-模拟空间" class="headerlink" title="1.5.模拟空间"></a>1.5.模拟空间</h3><ul>
<li>Simulation Space模块<br>Local，本地空间，粒子会以粒子发生器为中心<br>World，世界空间，粒子使用世界坐标系</li>
</ul>
<h3 id="1-6-发射"><a href="#1-6-发射" class="headerlink" title="1.6.发射"></a>1.6.发射</h3><h4 id="1-6-1-发射方式"><a href="#1-6-1-发射方式" class="headerlink" title="1.6.1.发射方式"></a>1.6.1.发射方式</h4><ul>
<li>Emission：匀速发射<br>Rate over Time:按时间发射（一般用于静止）<br>Rate over Distance：按距离发射（一般用于运动物体）<br>Max Particles：最大存在粒子数</li>
<li>Brusts：爆发式发射<br>Time：爆炸发生时间<br>Count：爆出多少个粒子<br>Cycles&#x2F;Interval：爆炸次数&#x2F;间隔<br>Probability：爆炸的可能概率，0表示不会爆炸</li>
</ul>
<h4 id="1-6-2-发射器形状"><a href="#1-6-2-发射器形状" class="headerlink" title="1.6.2.发射器形状"></a>1.6.2.发射器形状</h4><ul>
<li>Shape模块<br>Cone：锥形<br>Sphere：球形<br>Hemisphere：半球形<br>Box：盒形<br>Circle：圆形<br>Rectangle：长方形</li>
</ul>
<h3 id="1-7-渐变"><a href="#1-7-渐变" class="headerlink" title="1.7.渐变"></a>1.7.渐变</h3><h4 id="1-7-1-颜色渐变"><a href="#1-7-1-颜色渐变" class="headerlink" title="1.7.1.颜色渐变"></a>1.7.1.颜色渐变</h4><ul>
<li>Color over Lifetime模块<br>上面是透明度，下面是颜色，可以在上面设置多个透明度，以达到淡入淡出的效果<br>颜色的最终值 &#x3D; 初始颜色 * Color over Time设置的颜色（RGB分别相乘）</li>
</ul>
<h4 id="1-7-2-大小渐变"><a href="#1-7-2-大小渐变" class="headerlink" title="1.7.2.大小渐变"></a>1.7.2.大小渐变</h4><ul>
<li>Size over Lifetime模块<br>曲线变化：横坐标lifetime，纵坐标size</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中存储框架</title>
    <url>/Blog/2024/04/30/Unity%E4%B8%AD%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="数据存储框架"><a href="#数据存储框架" class="headerlink" title="数据存储框架"></a>数据存储框架</h1><ul>
<li>分为两种，网络存储和本地存储</li>
</ul>
<h2 id="1-本地存储"><a href="#1-本地存储" class="headerlink" title="1.本地存储"></a>1.本地存储</h2><ul>
<li>Unity中可以有两种方式，一种是CSV文件，一种是使用Unity自带</li>
</ul>
<h3 id="1-1-Unity自带"><a href="#1-1-Unity自带" class="headerlink" title="1.1.Unity自带"></a>1.1.Unity自带</h3><ul>
<li>使用AssetMenu存储<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里使得可以右键创建文件</span></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;ConfigTable&quot;</span>, fileName = <span class="string">&quot;data&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PackageTable</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;BagConfig&gt; bagconfiga = <span class="keyword">new</span> List&lt;BagConfig&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里使得可以在检查器里面显示并且修改</span></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BagConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> describ;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> imgPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-2-CSV文件"><a href="#1-2-CSV文件" class="headerlink" title="1.2.CSV文件"></a>1.2.CSV文件</h3><p>利用csv文件创建相关配置，然后使用代码进行获取</p>
]]></content>
  </entry>
  <entry>
    <title>Unity实现小地图创建</title>
    <url>/Blog/2024/02/08/Unity%E5%AE%9E%E7%8E%B0%E5%B0%8F%E5%9C%B0%E5%9B%BE%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Unity相关</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>实现Unity中UI的拖拽</title>
    <url>/Blog/2024/03/15/%E5%AE%9E%E7%8E%B0Unity%E4%B8%ADUI%E7%9A%84%E6%8B%96%E6%8B%BD/</url>
    <content><![CDATA[<h1 id="实现Unity中UI的拖拽"><a href="#实现Unity中UI的拖拽" class="headerlink" title="实现Unity中UI的拖拽"></a>实现Unity中UI的拖拽</h1><ul>
<li>需要将屏幕坐标转换为世界坐标<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UIElements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerControal</span> : <span class="title">MonoBehaviour</span>,<span class="title">IBeginDragHandler</span>,<span class="title">IDragHandler</span>,<span class="title">IEndDragHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isDragging = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector3 offset;</span><br><span class="line">    <span class="keyword">private</span> Vector2 position;</span><br><span class="line">    <span class="keyword">private</span> RectTransform rectTransform;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        rectTransform = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;开始拖拽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 pos;</span><br><span class="line">        RectTransformUtility.ScreenPointToWorldPointInRectangle(rectTransform, eventData.position, eventData.enterEventCamera, <span class="keyword">out</span> pos);</span><br><span class="line">        rectTransform.position = pos;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;结束拖拽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/Blog/2024/02/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy  </span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/Blog/2024/03/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><p>将无序序列中的值与有序序列中每一个值进行比较并且插入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">insertionSort(arr)</span><br><span class="line"> n = arr.length</span><br><span class="line"> </span><br><span class="line"> // 从第二个元素开始遍历数组</span><br><span class="line"> for i from 1 to n-1 do</span><br><span class="line">   // 将当前元素插入已排序部分的合适位置</span><br><span class="line">   key = arr[i]</span><br><span class="line">   j = i - 1</span><br><span class="line">   </span><br><span class="line">   // 将比当前元素大的元素向后移动</span><br><span class="line">   while j &gt;= 0 and arr[j] &gt; key do</span><br><span class="line">     arr[j + 1] = arr[j]</span><br><span class="line">     j = j - 1</span><br><span class="line">   </span><br><span class="line">   // 将当前元素插入到正确位置</span><br><span class="line">   arr[j + 1] = key</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2.希尔排序"></a>2.希尔排序</h2><p>通过缩小增量进行排序，达到排序结果</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function shellSort(arr)</span><br><span class="line">    n = arr.length</span><br><span class="line">    gap = n / 2</span><br><span class="line">    while gap &gt; 0</span><br><span class="line">        for i = gap to n - 1</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            j = i</span><br><span class="line">            while j &gt;= gap and arr[j - gap] &gt; temp</span><br><span class="line">                arr[j] = arr[j - gap]</span><br><span class="line">                j = j - gap</span><br><span class="line">            arr[j] = temp</span><br><span class="line">        gap = gap / 2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h2><p>从第一个开始两两比较，进行两两排序，每排完一个循环，总有一个大值从后往前归到正确位置，所以叫冒泡法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure bubbleSort(arr)</span><br><span class="line">    n = length(arr)</span><br><span class="line">    for i from 0 to n-1</span><br><span class="line">        for j from 0 to n-i-1</span><br><span class="line">            if arr[j] &gt; arr[j+1]</span><br><span class="line">                swap(arr[j], arr[j+1])</span><br></pre></td></tr></table></figure></div>
<h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h2><ol>
<li>在待排序表L[1…n]中任取⼀个元素pivot作为枢轴（或基准）  </li>
<li>通过⼀趟排序将待排序表划分为独⽴的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于 pivot，则pivot放在了其最终位置L(k)上，这个过程称为⼀次“划分”。  </li>
<li>然后分别递归地对两个⼦表重复上述过程，直每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function quickSort(arr, low, high)</span><br><span class="line"> if low &lt; high</span><br><span class="line">     pi = partition(arr, low, high)</span><br><span class="line">     quickSort(arr, low, pi - 1) // Before pi</span><br><span class="line">     quickSort(arr, pi + 1, high) // After pi</span><br><span class="line"></span><br><span class="line">function partition(arr, low, high)</span><br><span class="line"> pivot = arr[high]</span><br><span class="line"> i = low - 1 //保证 i 指向的是小于等于基准值的元素的最后一个位置</span><br><span class="line"> for j from low to high - 1</span><br><span class="line">     if arr[j] &lt;= pivot</span><br><span class="line">         i = i + 1</span><br><span class="line">         swap(arr[i], arr[j])</span><br><span class="line"> swap(arr[i + 1], arr[high])</span><br><span class="line"> return i + 1</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="5-选择排序（逻辑最简单，最稳定）"><a href="#5-选择排序（逻辑最简单，最稳定）" class="headerlink" title="5.选择排序（逻辑最简单，最稳定）"></a>5.选择排序（逻辑最简单，最稳定）</h2><p>每一次将无序序列中最小的数追加到有序序列的里面</p>
<h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h2><ul>
<li>时间复杂度：O(n * logn)<br>1.构建最大堆O(n)<br>2.排序O(logn)<br>3.所以结果为相乘O(n * logn)</li>
<li>原理<br>大根堆：根节点是最大的<br>小根堆：根节点是最小的<br>建立堆，然后使用堆排序调整堆。简而言之就是每次把未排序中最大数，放到有序序列的最小处<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">heapSort(arr)</span><br><span class="line">    n = arr.length</span><br><span class="line">    </span><br><span class="line">    // 构建最大堆，将最大的放到堆顶（此时左右子节点还是无序的）</span><br><span class="line">    for i from n/2 - 1 down to 0 do</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    </span><br><span class="line">    // 从堆顶开始逐步将最大值移到数组末尾，并进行调整（也就是每一次都把最大的数放到堆底）</span><br><span class="line">    for i from n - 1 down to 1 do</span><br><span class="line">        swap(arr[0], arr[i]) // 将堆顶元素（最大值）与当前未排序部分的末尾元素交换</span><br><span class="line">        heapify(arr, i, 0)   // 对剩余元素重新进行堆调整，保持最大堆性质</span><br><span class="line"></span><br><span class="line">// 调整堆，保持最大堆性质</span><br><span class="line">heapify(arr, n, i)</span><br><span class="line">    largest = i   // 初始化父节点索引为最大值索引</span><br><span class="line">    left = 2 * i + 1   // 左子节点索引</span><br><span class="line">    right = 2 * i + 2  // 右子节点索引</span><br><span class="line">    </span><br><span class="line">    // 检查左子节点是否大于父节点</span><br><span class="line">    if left &lt; n and arr[left] &gt; arr[largest] then</span><br><span class="line">        largest = left</span><br><span class="line">    </span><br><span class="line">    // 检查右子节点是否大于父节点或左子节点</span><br><span class="line">    if right &lt; n and arr[right] &gt; arr[largest] then</span><br><span class="line">        largest = right</span><br><span class="line">    </span><br><span class="line">    // 如果最大值不是父节点，则进行交换，并递归调整受影响的子树</span><br><span class="line">    if largest != i then</span><br><span class="line">        swap(arr[i], arr[largest])</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h2><ul>
<li>先将序列分成两个序列，分别进行排序，随后将两个序列进行合并<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mergeSort(arr)</span><br><span class="line">  n = arr.length</span><br><span class="line">  // 如果数组只有一个元素，直接返回</span><br><span class="line">  if n &lt; 2 then</span><br><span class="line">    return</span><br><span class="line">  </span><br><span class="line">  // 计算中间索引</span><br><span class="line">  mid = n / 2</span><br><span class="line">  </span><br><span class="line">  // 创建左右子数组</span><br><span class="line">  left = arr[0...mid-1]</span><br><span class="line">  right = arr[mid...n-1]</span><br><span class="line">  </span><br><span class="line">  // 递归地对左右子数组进行排序</span><br><span class="line">  mergeSort(left)</span><br><span class="line">  mergeSort(right)</span><br><span class="line">  </span><br><span class="line">  // 合并左右两个有序子数组</span><br><span class="line">  merge(arr, left, right)</span><br><span class="line"></span><br><span class="line">merge(arr, left, right)</span><br><span class="line">  nL = left.length</span><br><span class="line">  nR = right.length</span><br><span class="line">  i = 0, j = 0, k = 0</span><br><span class="line">  </span><br><span class="line">  // 合并左右两个有序子数组</span><br><span class="line">  while i &lt; nL and j &lt; nR do</span><br><span class="line">    if left[i] &lt;= right[j] then</span><br><span class="line">      arr[k] = left[i]</span><br><span class="line">      i = i + 1</span><br><span class="line">    else</span><br><span class="line">      arr[k] = right[j]</span><br><span class="line">      j = j + 1</span><br><span class="line">    k = k + 1</span><br><span class="line">  </span><br><span class="line">  // 处理剩余元素</span><br><span class="line">  while i &lt; nL do</span><br><span class="line">    arr[k] = left[i]</span><br><span class="line">    i = i + 1</span><br><span class="line">    k = k + 1</span><br><span class="line">  </span><br><span class="line">  while j &lt; nR do</span><br><span class="line">    arr[k] = right[j]</span><br><span class="line">    j = j + 1</span><br><span class="line">    k = k + 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8.基数排序"></a>8.基数排序</h2><ul>
<li>非比较序列，并不直接进行数的大小比较，而是对每一位进行比较<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取数组中最大元素的位数</span><br><span class="line">function getMax(arr):</span><br><span class="line">    max = arr[0]</span><br><span class="line">    for i from 1 to arr.length - 1 do</span><br><span class="line">        if arr[i] &gt; max then</span><br><span class="line">            max = arr[i]</span><br><span class="line">    return max</span><br><span class="line"></span><br><span class="line">// 对数组按照指定位数进行计数排序</span><br><span class="line">function countingSort(arr, exp):</span><br><span class="line">    n = arr.length</span><br><span class="line">    output = new Array(n)</span><br><span class="line">    count = new Array(10)</span><br><span class="line">    for i from 0 to 9 do</span><br><span class="line">        count[i] = 0</span><br><span class="line"></span><br><span class="line">    // 统计每个桶中元素的个数</span><br><span class="line">    for i from 0 to n - 1 do</span><br><span class="line">        index = (arr[i] / exp) % 10</span><br><span class="line">        count[index]++</span><br><span class="line"></span><br><span class="line">    // 将计数数组转换为位置索引数组</span><br><span class="line">    for i from 1 to 9 do</span><br><span class="line">        count[i] += count[i - 1]</span><br><span class="line"></span><br><span class="line">    // 将元素按照当前位的值放置到输出数组中</span><br><span class="line">    for i from n - 1 down to 0 do</span><br><span class="line">        index = (arr[i] / exp) % 10</span><br><span class="line">        output[count[index] - 1] = arr[i]</span><br><span class="line">        count[index]--</span><br><span class="line"></span><br><span class="line">    // 将输出数组复制回原数组</span><br><span class="line">    for i from 0 to n - 1 do</span><br><span class="line">        arr[i] = output[i]</span><br><span class="line"></span><br><span class="line">// 基数排序函数</span><br><span class="line">function radixSort(arr):</span><br><span class="line">    max = getMax(arr)</span><br><span class="line">    exp = 1</span><br><span class="line">    while max / exp &gt; 0 do</span><br><span class="line">        countingSort(arr, exp)</span><br><span class="line">        exp *= 10</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/Blog/2024/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-概论"><a href="#1-概论" class="headerlink" title="1.概论"></a>1.概论</h2><h3 id="1-1-网络、互联网以及因特网"><a href="#1-1-网络、互联网以及因特网" class="headerlink" title="1.1.网络、互联网以及因特网"></a>1.1.网络、互联网以及因特网</h3><ul>
<li>网络由若干个结点和连接这些结点的链路组成</li>
<li>多个网络可以用路由器互连起来，构成一个更大的网络，也就是互联网</li>
<li>因特网就是最大的互联网</li>
</ul>
<h3 id="1-2-因特网组成"><a href="#1-2-因特网组成" class="headerlink" title="1.2.因特网组成"></a>1.2.因特网组成</h3><ul>
<li>边缘部分：由所有连接到网络的主机构成，是用户直接使用的，作为通信和资源共享</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成的，用于向边缘部分提供服务</li>
</ul>
<h3 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3.三种交换方式"></a>1.3.三种交换方式</h3><p>交换：按照某种方式动态分配传输线路的资源  </p>
<ul>
<li>电路交换：电话交换机接通电话线的方式<br>1.建立连接（分配通信资源）<br>2.通话（建立的资源始终被占用）<br>3.释放连接（归还通信资源）</li>
<li>分组交换<br>1.发送方：构造分组，发送分组<br>2.路由器：缓存分组，转发分组<br>3.接收方：接受分组，还原报文</li>
<li>报文交换：已经被分组交换替代</li>
<li>后两者都引起了转发时延，但是都提高了线路利用率，并且可以提供多目标服务</li>
</ul>
<h3 id="1-4-定义和分类"><a href="#1-4-定义和分类" class="headerlink" title="1.4.定义和分类"></a>1.4.定义和分类</h3><ul>
<li>定义：一些互相连接、自治的计算机集合</li>
<li>分类：<br>1.按交换技术分类：电路交换网络、报文交换网络、分组交换网络<br>2.按使用者分类：公用网、专用网<br>3.传输介质：有线网络、无线网络<br>4.覆盖网络：广域网（WAN）、城域网（MAN）、局域网（LAN）、个域网（PAN）<br>5.拓扑结构：总线型网络、星型网络、环形网络、网状型网络</li>
</ul>
<h3 id="1-5-计算机网络性能指标"><a href="#1-5-计算机网络性能指标" class="headerlink" title="1.5.计算机网络性能指标"></a>1.5.计算机网络性能指标</h3><ul>
<li>速率：传输数据的速度</li>
<li>带宽：信号所包含的各种不同频率成分所占据的频率范围；网络的通信线路所能传输数据的能力，也就是单位时间内，从网络的某个点到另一个点所能通过的最高数据率</li>
<li>吞吐量：单位时间内，通过某个网络的数据量。吞吐量受到网络带宽或者额定速率的限制</li>
<li>时延：发送时延（分组长度&#x2F;发送速率）、传播时延（信道长度&#x2F;电磁波在不同介质中的传输速率）、处理时延（无法计算）</li>
<li>时延带宽积：乘以的是传播时延和带宽乘积。也就是第一个比特到终点时，已经发送了的数据量</li>
<li>往返时间（RTT，Round-Trip Time）：双向交互时间</li>
<li>利用率：信道利用率、网络利用率。D0表示空闲时的时延，D表示当前时延，利用率U，则D&#x3D;D0&#x2F;（1-U）</li>
<li>丢包率：传输过程中丢失的分组数量与总分组数量比值。丢包原因：误码或网络拥塞</li>
</ul>
<h3 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6.计算机网络体系结构"></a>1.6.计算机网络体系结构</h3><ul>
<li>OSI模型：<br>物理层、数据链路层、网络层、运输层、会话层、表示层、应用层</li>
<li>TCP&#x2F;IP模型：<br>网络接口层、网际层、运输层、应用层</li>
<li>原理模型：<br>物理层：解决用何种信号传输比特的问题<br>链路层：解决分组在一个网络里面（或者一段链路里面）上传输的问题<br>网络层：解决分组在多个网络上传输（路由）的问题<br>运输层：解决进程之间基于网络的通信问题<br>应用层：解决通过应用进程的交互来实现特定网络应用的问题</li>
</ul>
<h2 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h2><h3 id="2-1-传输方式"><a href="#2-1-传输方式" class="headerlink" title="2.1.传输方式"></a>2.1.传输方式</h3><p>串行传输：数据一个比特一个比特发送<br>并行传输：一次发送多个比特<br>同步：字节同步<br>异步：字节间异步，但是字节中的比特流依然同步<br>单工：只能单向传输<br>半双工：双向不同时（对讲机）<br>全双工：双向且同时（电话）</p>
<h3 id="2-2-编码与调制"><a href="#2-2-编码与调制" class="headerlink" title="2.2.编码与调制"></a>2.2.编码与调制</h3><ul>
<li>码元：在时间域中，用波形表示数字信号时，代表不同数值的离散波形</li>
<li>基带信号分为<strong>数字基带信号</strong>和<strong>模拟基带信号</strong></li>
<li>编码和调制：将基带信号转换到数字信道的过程为编码；将基带信号转换到模拟信道的过程称为调制</li>
</ul>
<h4 id="2-2-1-常用编码方式"><a href="#2-2-1-常用编码方式" class="headerlink" title="2.2.1.常用编码方式"></a>2.2.1.常用编码方式</h4><p>不归零编码：需要额外一个时钟信号<br>归零编码：不需要额外时钟信号，会实现自同步，但是效率低<br>曼切斯特码：跳变表示了时钟以及数据<br>差分曼切斯特码：跳变仅表示时钟，码元开始是否发生变化来表示数据</p>
<h4 id="2-2-2-基本调制方法"><a href="#2-2-2-基本调制方法" class="headerlink" title="2.2.2.基本调制方法"></a>2.2.2.基本调制方法</h4><p>调幅（AM）<br>调频（FM）<br>调相（PM）<br>正交振幅调制（QAM）：通过格雷码使得每一个码元都表示一个比特</p>
<h3 id="2-3-信道极限容量"><a href="#2-3-信道极限容量" class="headerlink" title="2.3.信道极限容量"></a>2.3.信道极限容量</h3><ul>
<li>奈氏准则：为了避免码间串扰，码元的传输速率应该有上限<br>理想低通信道的最高码元速率 &#x3D; 2W Baud &#x3D; 2W 码元&#x2F;秒<br>理想带通信道的最高码元速率 &#x3D; W Baud &#x3D; W 码元&#x2F;秒   </li>
<li>香浓公式<br>极限传输速率C &#x3D; W * log2（1+S&#x2F;N）<br>W为带宽，S为信道平均速率，N为高斯噪声功率，S&#x2F;N为信噪比</li>
<li>数据传输速率 &#x3D; 波特率 * 每个码元携带信息量</li>
</ul>
<h2 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h2><ul>
<li>链路：就是从一个结点到相邻一个结点的一段物理线路，中间没有任何的交换结点</li>
<li>数据链路：是指把实现通信协议的硬件和软件加到链路上，数据链路层以帧为单位传输和处理数据</li>
</ul>
<h3 id="3-1-封装成帧"><a href="#3-1-封装成帧" class="headerlink" title="3.1.封装成帧"></a>3.1.封装成帧</h3><ul>
<li>封装成帧：数据链路层给上层交付的协议数据单元（PDU）添加帧头和帧尾的操作<br>帧头帧尾里面有重要控制信息，作用之一就是帧界定  </li>
<li>透明传输：数据链路层对上层交付的传输数据没有任何限制，好像数据链路层不存在一样<br>这就需要对帧界定进行保护<br>面向字节的物理链路使用字节填充<br>面向比特的物理链路使用比特填充</li>
</ul>
<h3 id="3-2-差错检测"><a href="#3-2-差错检测" class="headerlink" title="3.2.差错检测"></a>3.2.差错检测</h3><ul>
<li>比特差错：比特可能会0变成1，或者1变成0</li>
<li>误码率BER：传输错误的比特占总比特的比例</li>
<li>差错检测码：<br>奇偶校验（只能检测奇数误码）：添加一位奇偶校验位，使得整个数据中，1的个数为奇数或者偶数<br>循环冗余校验（CRC）：双方约定多项式，并且用待发送的数据除以<strong>生成多项式</strong>（使待发数据后面添加0，0个数为生成多项式的最高次），然后将余数作为冗余码（同样与生成多项式最高次相同，不够在前面添加0），添加到数据后面作为校验；接收方就将接收到的数据（连同余数冗余码）除以生成多项式（异或运算），如果余数为0，说明没有误码，否则有误码</li>
</ul>
<h3 id="3-3-可靠传输"><a href="#3-3-可靠传输" class="headerlink" title="3.3.可靠传输"></a>3.3.可靠传输</h3><h4 id="3-3-1-可靠传输基本概念"><a href="#3-3-1-可靠传输基本概念" class="headerlink" title="3.3.1.可靠传输基本概念"></a>3.3.1.可靠传输基本概念</h4><ul>
<li>数据链路层向上提供的服务<br>不可靠传输：如果有误码，就直接将误码帧丢弃<br>可靠传输：想办法实现发送端发送什么，接收端就收到什么<br>一般情况下，有线链路误码率低，只要不可靠传输即可；无线链路误码率高，需要提供可靠传输服务</li>
<li>可靠传输在其他层也可以实现<br>TCP为面向连接的可靠服务、UDP为无连接不可靠服务、IP为无连接不可靠服务</li>
</ul>
<h4 id="3-3-2-可靠传输实现机制"><a href="#3-3-2-可靠传输实现机制" class="headerlink" title="3.3.2.可靠传输实现机制"></a>3.3.2.可靠传输实现机制</h4><ul>
<li>停止-等待协议（SW）<br>发送方发送数据，接收方接受并且检测没有误码之后，发送一个确认信号ACK给到发送方，否则发送一个NAK；发送方发送之后进入等待，接收到ACK之后发送下一个分组，如果是NAK则重新发送上一个分组（因此上一个分组数据缓存始终在发送方，直到确认接收）<br>因为有可能第一次发送就直接丢失，接收方不会发送ACK或者NAK，发送方就会陷入等待，所以加入一个超时计时器，定时为略大于正常往返时间，如果超过重传时间没有收到信号，就重新发送上一个分组，这就叫做<strong>超时重传</strong><br>如果ACK或者NAK有丢失，那么会导致发送方接收不到信号，就会重新发送，而为了可以让接收端判断这是分组重复，所以需要对分组进行序号编号；同理也需要对ACK或者NAK进行编号，确保分别对应分组来确认收到或者否定收到</li>
<li>回退N帧协议（GBN）<br>使用多个发送窗口，使得可以一次发送多个分组。例如使用3个比特给分组编号，则发送窗口尺寸为1&lt;Wt&lt;2^n - 1,接收窗口为1.<br>累计确认：连续收到好几个按序到达且误码的分组后，针对最后一个分组发送确认分组<br>如果发送窗口中第一个分组误码，则后面的也不会接收，因为只有一个接收窗口，需要按序接收。<br>不能一次发送超过2^n - 1个分组，因为这样接收方就不能区分是新帧还是旧帧</li>
<li>选择重传协议（SR）：不再是一个接收窗口，而是Wr &#x3D; Wt个窗口，而1&lt;Wt&lt;2^(n-1)<br>发送窗口或者接收窗口在尺寸内的分组被发送成功或者接收成功后才会继续向后滑动，按序不空缺</li>
</ul>
<h3 id="3-4-点对点协议（PPP）"><a href="#3-4-点对点协议（PPP）" class="headerlink" title="3.4.点对点协议（PPP）"></a>3.4.点对点协议（PPP）</h3><ul>
<li>PPP：数据链路层中建立点对点协议<br>F-A-C-P-Data-FCS-F<br>F：Flag，标志位，通常为7E<br>A：Adress，地址位，通常为FF<br>C：Control，控制位，通常03<br>P：协议位，0021表示为IP数据报；C021表示为LCP分组；8021表示为NCP分组<br>Data：数据<br>FCS：帧检验字段（CRC结果）</li>
<li>透明传输：<br>面向字节：加入在与F重复前添加7D<br>面向比特：在每5个1后面加上一个0</li>
</ul>
<h3 id="3-5-媒体介入控制"><a href="#3-5-媒体介入控制" class="headerlink" title="3.5.媒体介入控制"></a>3.5.媒体介入控制</h3><h4 id="3-5-1-静态划分信道"><a href="#3-5-1-静态划分信道" class="headerlink" title="3.5.1.静态划分信道"></a>3.5.1.静态划分信道</h4><ul>
<li>不太灵活，只用在物理层，不用在数据链路层</li>
<li>复用：通过一条物理线路同时传输多路用户的信号</li>
<li>频分复用（FDM）（包含波形复用（WDM）、时分复用（TDM）、码分复用（CDM）</li>
<li>码分复用（CDM&#x2F;CDMA）<br>通过各用户使用经过特殊挑选的不同码型，允许用户在同样的时间使用同样的频带通信（实际上就是在内容上做出适应）<br>CDMA中每一个比特时间再划分m个短的时间间隔，称为码片（chip），每一个站使用唯一m bit码片序列。如果要表示1，发出m序列；如果要表示0，发出m序列的二进制反码<br>码片挑选原则：<br>1.每个站的码片序列必须不同<br>2.每个站的码片必须相互正交（规格化内积为0）</li>
</ul>
<h4 id="3-5-2-动态接入控制—-随机接入"><a href="#3-5-2-动态接入控制—-随机接入" class="headerlink" title="3.5.2.动态接入控制—-随机接入"></a>3.5.2.动态接入控制—-随机接入</h4><ul>
<li>载波监听多址接入&#x2F;碰撞检测（CSMA&#x2F;CD）：多址接入（MA）就是多个站在一条总线上，竞争使用总线；载波监听（CS）就是发送前，检测总线上是否有其他站点要发送帧；碰撞检测（CD），每一个发送中的帧边发送边检测碰撞<br>争用期（碰撞窗口）：最多经过2t(t为端到端的传播时延)时间检测到本次是否发生碰撞。因此，总线长度越大越容易发生碰撞、主机越多也越不顺利<br>最小帧长：不能太短（导致不能碰撞检测，数据会丢失），以太网64字节（数据很短就补上其他字节，保证原始数据不会丢失）。最小帧长 &#x3D; 争用期 * 数据传播速率<br>最大帧长：不能太长，占用总线太久导致其他站缓存溢出<br>截断二进制指数退避算法：退避时间 &#x3D; 基本退避时间 * 随机数r（r为2的指数）<br>信道利用率：S &#x3D; 发送成功时间&#x2F;发送成功时间+端到端的传播时延，所以发送成功时间应该长一些，端到端距离应该短一些  </li>
<li>载波监听多址接入&#x2F;碰撞避免（CSMA&#x2F;CA）：碰撞避免，采用了数据链路层的SW协议。<br>所有站点必须在持续检测信道空闲后一段时间才开始发送帧，这个帧间间隔为IFS<br>IFS长度取决于要发送的帧类型，高优先级帧IFS短，低优先级帧IFS长。IFS有DIFS（长）和SIFS（短）<br>1.工作原理：源站检测信道空闲，等待一个DIFS然后发送（避免有高优先级发送），发送第一帧到目的站，目的站等待SIFS后（分隔开属于一次对话的各帧，让一个站点可以从发送方式转换到接收方式），发送ACK给回源站；其他站点在这个过程中检测到信道忙，当检测空闲后，等待一个DIFS，然后再来一个退避算法（防止多个站点同时发送数据产生碰撞），接着发送下一帧<br>当站点检测到信道是空闲的，并且所要发送的帧不是在上一帧发送完之后立即发送的，就可以不使用退避算法；否则都要使用退避算法<br>2.CSMA&#x2F;CA的退避算法：退避时间减小到0时，开始发送数据；退避时间还没有到0就检测到信道忙时，将退避时间冻结，等到检测信道空闲的时候，一个DIFS之后才开始继续之前退避时间数值的倒计时。第i次退避，用的是2^i乘以基本退避时间，避免退避时间重复(第6次之后不再增加）。<br>3.CSMA&#x2F;CA的信道预约和虚拟载波监听：<br>信道预约：在帧发送前，一个DIFS后发送RTC（Request To Send），目的站收到后等待SIFS，发送CTS（Clear To Send），源站收到后等待SIFS，发送数据，其他站收到CTS，知道此时不会发送，避免碰撞<br>虚拟载波监听：只需要监听RTS或者CTS或者数据帧任意一个，就可以知道信道被占用时间，可以减少屏蔽站带来的碰撞问题</li>
</ul>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
</search>
