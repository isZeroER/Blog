<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>.fbx文件使用</title>
    <url>/Blog/2024/02/02/FBX%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一、三个组成部分"><a href="#一、三个组成部分" class="headerlink" title="一、三个组成部分"></a>一、三个组成部分</h3><ul>
<li><strong>mesh</strong>：网格，定义物体形状</li>
<li><strong>meterial</strong>：材质，定义表面光学特性</li>
<li><strong>textures</strong>：贴图，定义表面像素颜色</li>
</ul>
<h3 id="二、-fbx使用方式"><a href="#二、-fbx使用方式" class="headerlink" title="二、.fbx使用方式"></a>二、.fbx使用方式</h3><h4 id="1、直接拖动"><a href="#1、直接拖动" class="headerlink" title="1、直接拖动"></a>1、直接拖动</h4><ul>
<li><strong>选择.fbx文件，直接拖到层级窗口</strong></li>
<li><strong>观察节点图标</strong></li>
<li><strong>选中节点，观察inspector中的操作按钮</strong></li>
</ul>
<h4 id="2、材质替换"><a href="#2、材质替换" class="headerlink" title="2、材质替换"></a>2、材质替换</h4><ul>
<li><strong>选择.fbx文件</strong></li>
<li><strong>在inspector里面切到materials属性-&gt;Use Embeded Materials-&gt;On Demand Remap:映射新的材质</strong></li>
<li><strong>Apply应用设置</strong></li>
</ul>
<h5 id="or……"><a href="#or……" class="headerlink" title="or……"></a>or……</h5><ul>
<li><strong>选中.fbx文件</strong></li>
<li><strong>Location：Use External Materials：使用外部材质</strong></li>
<li><strong>Apply，可以获得内嵌材质解压缩后的Materials目录</strong></li>
<li><strong>直接对解压缩后的材质文件进行修改</strong></li>
</ul>
<h4 id="3、分解重组"><a href="#3、分解重组" class="headerlink" title="3、分解重组"></a>3、分解重组</h4><ul>
<li><strong>将fbx文件中的材质单独拿出来使用</strong></li>
</ul>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Study</title>
    <url>/Blog/2024/02/14/C++%20Study/</url>
    <content><![CDATA[<h1 id="1-C-基础"><a href="#1-C-基础" class="headerlink" title="1.C++基础"></a>1.C++基础</h1><h2 id="1-1-C-运行原理"><a href="#1-1-C-运行原理" class="headerlink" title="1.1.C++运行原理"></a>1.1.C++运行原理</h2><ul>
<li>C++如何工作<br>编译器先处理预处理，即在编译前处理；<br>所有cpp文件被编译后，生成.obj文件，linker将这些文件整合成一个二进制可执行文件，也就是.exe 文件</li>
<li>C++编译器如何工作<br>预处理的处理-&gt;生成语法树<br>预处理，实际上就是将预处理的文件全数复制粘贴到当前文件<br>对于编译器来说，文件没有任何意义，只需要告知是什么文件即可</li>
<li>C++链接器如何工作<br>需要一个入口，一般是main函数，但也可以是其他函数<br>链接器会链接可能需要使用到的函数，所以如果函数仅仅在自己的文件里可能被使用到，并且在本文件不会被使用到，那么在最前面加上static就可以使它不被链接。static使其成为内部函数</li>
</ul>
<h2 id="1-2-C-变量、函数"><a href="#1-2-C-变量、函数" class="headerlink" title="1.2.C++变量、函数"></a>1.2.C++变量、函数</h2><ul>
<li>变量<br>int,string,long,long long,bool</li>
<li>函数的创建原则：避免过多重复代码</li>
<li>sizeof(),可以查看变量的大小</li>
</ul>
<h2 id="1-3-头文件"><a href="#1-3-头文件" class="headerlink" title="1.3.头文件"></a>1.3.头文件</h2><ul>
<li>头文件通过#include进行复制</li>
<li>#pragma once确保头文件仅被复制一次</li>
<li>“”用于文件路径，&lt;&gt;用于文件夹路径</li>
</ul>
<h2 id="1-4-条件、分支和循环"><a href="#1-4-条件、分支和循环" class="headerlink" title="1.4.条件、分支和循环"></a>1.4.条件、分支和循环</h2><h3 id="1-4-1-条件语句"><a href="#1-4-1-条件语句" class="headerlink" title="1.4.1.条件语句"></a>1.4.1.条件语句</h3><ul>
<li>本质上是给CPU不同的指令（机器代码），在不同的内存进行运作</li>
</ul>
<h3 id="1-4-2-循环语句"><a href="#1-4-2-循环语句" class="headerlink" title="1.4.2.循环语句"></a>1.4.2.循环语句</h3><ul>
<li>for循环</li>
<li>while循环</li>
<li>do while循环</li>
</ul>
<h3 id="1-4-3-控制流语句"><a href="#1-4-3-控制流语句" class="headerlink" title="1.4.3.控制流语句"></a>1.4.3.控制流语句</h3><ul>
<li>continue,进行下一次循环</li>
<li>break，跳出循环，终止循环</li>
<li>return，完全退出函数，并且返回</li>
</ul>
<h2 id="1-5-指针和引用"><a href="#1-5-指针和引用" class="headerlink" title="1.5.指针和引用"></a>1.5.指针和引用</h2><h3 id="1-5-1-指针"><a href="#1-5-1-指针" class="headerlink" title="1.5.1.指针"></a>1.5.1.指针</h3><ul>
<li>指针用于管理和操纵内存，指针是一种存储内存地址的整数</li>
<li>指针的类型是告诉计算机，对应地址的值是什么类型，对于地址本身没有影响，地址始终是整数</li>
<li>指针可以指向指针，例如：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptn = &amp;var; <span class="comment">//&amp;取了var地址</span></span><br><span class="line"><span class="type">int</span>** ptnd = &amp;ptn;</span><br></pre></td></tr></table></figure></div></li>
<li>指针的指向对象可以修改<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* ref = &amp;a;</span><br><span class="line">*ref = <span class="number">1</span>; <span class="comment">//逆向指针，即取地址的值并且修改</span></span><br><span class="line">ref = &amp;b;</span><br><span class="line">*ref = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-5-2-引用"><a href="#1-5-2-引用" class="headerlink" title="1.5.2.引用"></a>1.5.2.引用</h3><ul>
<li>引用只是引用现有的变量，并没有在内存中占用资源，仅仅出现在源代码中。相当于给已有变量取别名<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = var;</span><br><span class="line">ref = <span class="number">9</span>; <span class="comment">//通过引用改变了var的实际值</span></span><br></pre></td></tr></table></figure></div></li>
<li>函数引用举例：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">9</span>;</span><br><span class="line">	<span class="built_in">Add</span>(var);</span><br><span class="line">	std::cout &lt;&lt; var &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>引用之后不能修改引用的对象</li>
</ul>
<h2 id="1-6-C-类"><a href="#1-6-C-类" class="headerlink" title="1.6.C++类"></a>1.6.C++类</h2><h3 id="1-6-1-C-类"><a href="#1-6-1-C-类" class="headerlink" title="1.6.1.C++类"></a>1.6.1.C++类</h3><ul>
<li>类的创建<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;; <span class="comment">//注意这里需要一个分号</span></span><br></pre></td></tr></table></figure></div></li>
<li>类的属性默认都是私有的<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//这里使用public，就可以使得这些属性为公有的</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">int</span> speed;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;; <span class="comment">//注意这里需要一个分号</span></span><br></pre></td></tr></table></figure></div></li>
<li>类的两种实例创建<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Example e_1; <span class="comment">//在栈上创建的，离开作用域后就自动销毁</span></span><br><span class="line">	Example* e_2 = <span class="keyword">new</span> Example; <span class="comment">//在堆上创建的，需要手动销毁（new关键字返回的是指针）</span></span><br><span class="line">	<span class="keyword">delete</span> e_2; <span class="comment">//用new关键字创建在堆上的，需要使用delete删除</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果new创建数组，delete也要加上数组</span></span><br><span class="line">	<span class="type">int</span>* nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-2-静态（static）"><a href="#1-6-2-静态（static）" class="headerlink" title="1.6.2.静态（static）"></a>1.6.2.静态（static）</h3><ul>
<li>类或者结构体外的static可以确保静态函数或者变量只在当前翻译单元（cpp文件）被链接。<br>类中的static，使得该变量或者函数仅仅只有一个实例；假设一个类的许多实例对该变量进行改变，改变的始终只有这一个变量；所有实例的这些变量或者函数都指向同一个内存<br>静态方法不能访问非静态变量</li>
<li>局部静态（local static）：在函数中，不会被函数以外调用到，但是有记忆，生存期永远  <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//static使得变量i只能被Function函数修改，但是这个i是有记忆的</span></span><br><span class="line">	i++;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>(); <span class="comment">//打印1</span></span><br><span class="line">	<span class="built_in">Function</span>(); <span class="comment">//打印2</span></span><br><span class="line">	<span class="built_in">Function</span>(); <span class="comment">//打印3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-3-枚举"><a href="#1-6-3-枚举" class="headerlink" title="1.6.3.枚举"></a>1.6.3.枚举</h3><ul>
<li>枚举将某些数字赋予名词,一定是整数，并且调用形式为：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	A, B, C <span class="comment">//默认情况下，A，B，C，从0递增</span></span><br><span class="line">&#125;; <span class="comment">//需要一个分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; Entity::A &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-4-构造函数"><a href="#1-6-4-构造函数" class="headerlink" title="1.6.4.构造函数"></a>1.6.4.构造函数</h3><ul>
<li>构造函数起到一个初始化类的作用，可以对类属性等等进行初始化<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//初始化代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">float</span> x) <span class="comment">//可以进行函数重载，即同名函数，因为不同参数而有的不同函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//对x进行操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>构造函数可以被两种方法删除：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将构造函数删除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>() = <span class="keyword">delete</span>; <span class="comment">//这样类就不能被创建实例</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将构造函数private</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Entity</span>(); <span class="comment">//这样类就不能被创建实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-5-析构函数"><a href="#1-6-5-析构函数" class="headerlink" title="1.6.5.析构函数"></a>1.6.5.析构函数</h3><ul>
<li>析构函数在对象被销毁的时候调用<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	~<span class="built_in">Entity</span>() <span class="comment">//类名前添加一个~</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//对象被删除时的操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-6-6-类的继承"><a href="#1-6-6-类的继承" class="headerlink" title="1.6.6.类的继承"></a>1.6.6.类的继承</h3><ul>
<li>继承使得子类继承了父类的所有属性、方法等<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> A = <span class="number">3</span>, B =<span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Plus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; A + B &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Entity <span class="comment">//继承类Entity的所有public属性和方法&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> C = <span class="number">5</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">cPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; A + B + C &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
在以上的例子中，类Son的实例，实际上也是Entity的实例</li>
</ul>
<h3 id="1-6-7-虚函数"><a href="#1-6-7-虚函数" class="headerlink" title="1.6.7.虚函数"></a>1.6.7.虚函数</h3><ul>
<li>允许我们在子类中重写方法</li>
<li>引入V表（虚函数表），包含基类中所有虚函数映射<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> A = <span class="number">3</span>, B =<span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Plus</span><span class="params">()</span> <span class="comment">//添加上virtual标记为虚函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; A + B &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Entity <span class="comment">//继承类Entity的所有public属性和方法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> C = <span class="number">5</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Plus</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">//添加override表明重载函数</span></span><br><span class="line">		std::cout &lt;&lt; A + B + C &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>虚函数的两个缺点</li>
</ul>
<ol>
<li>需要在基类中创造一个指针</li>
<li>需要对V表遍历，从而确定映射的目标函数</li>
</ol>
<h3 id="1-6-8-C-接口（纯虚函数）"><a href="#1-6-8-C-接口（纯虚函数）" class="headerlink" title="1.6.8.C++接口（纯虚函数）"></a>1.6.8.C++接口（纯虚函数）</h3><ul>
<li>父类中的接口只包含未实现的方法作为模板，纯虚函数必须被实现，才可以创建这个子类的实例<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//创建纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintableSon</span> :<span class="keyword">public</span> Printable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;PrintableSon&quot;</span>; &#125; <span class="comment">//重载了纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> :<span class="keyword">public</span> Printable, PrintableSon</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125; <span class="comment">//重载了纯虚函数</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Printable* Instate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//A-&gt;B，意味着A是指针，-&gt;是成员提取。A必须是指向类、结构、联合的指针</span></span><br><span class="line">	std::cout &lt;&lt; Instate-&gt;<span class="built_in">GetName</span>()&lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PrintName</span>(<span class="keyword">new</span> <span class="built_in">Player</span>()); <span class="comment">//new Player()返回的是Player实例的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="1-7-一些深入探讨"><a href="#1-7-一些深入探讨" class="headerlink" title="1.7.一些深入探讨"></a>1.7.一些深入探讨</h2><h3 id="1-7-1-C-数组"><a href="#1-7-1-C-数组" class="headerlink" title="1.7.1.C++数组"></a>1.7.1.C++数组</h3><ul>
<li>数组就是表示一堆变量组成的集合  </li>
<li>如果访问数组范围外索引，则会Memory access violation（内存范文违规）  </li>
<li>数组实质上是指针<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> example[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* ptr = example; <span class="comment">//不会报错</span></span><br></pre></td></tr></table></figure></div></li>
<li>数组是指针<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">*(<span class="type">int</span>*)((<span class="type">char</span>*)ptr+<span class="number">8</span>)=<span class="number">6</span>； <span class="comment">//将数组是指针的原理展现的很清晰</span></span><br></pre></td></tr></table></figure></div>
首先，ptr是int指针，所以被定义4字节是一个索引；当（char* ）转化的时候，被定义为了8字节为一个索引；所以加8就是加了一个索引，而（int*）就是将其重新转化为int指针，并且赋值为6</li>
</ul>
<h3 id="1-7-2-C-字符串"><a href="#1-7-2-C-字符串" class="headerlink" title="1.7.2.C++字符串"></a>1.7.2.C++字符串</h3><ul>
<li>char是一个字节，char不是在堆，而是在栈上建立</li>
<li>char默认以单引号，char*默认以双引号<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">//编译器自动分配一个字符数组，其中包含一个额外的空字符表示字符串的结束</span></span><br><span class="line"><span class="type">char</span> *ptr = <span class="string">&quot;Hello&quot;</span>; <span class="comment">//这样ptr直接指向字符串的首地址</span></span><br><span class="line"><span class="type">char</span>* ptr = str; <span class="comment">//str数组名本身也就是字符串的首地址</span></span><br><span class="line"></span><br><span class="line">此外，添加<span class="type">const</span>说明不可修改</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;i am ztl&quot;</span>;</span><br></pre></td></tr></table></figure></div></li>
<li>字符串数组的工作原理：在指针末尾有一个空终止字符00</li>
<li>一个””双引号包括的文本，一般默认为一个char数组</li>
<li>std::string是一个类，用来表示字符串，会动态地分配内存以容纳字符串的长度</li>
</ul>
<h3 id="1-7-3-CONST"><a href="#1-7-3-CONST" class="headerlink" title="1.7.3.CONST"></a>1.7.3.CONST</h3><ul>
<li>const承诺某些东西的不变性<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> age = <span class="number">90</span>;	</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//将指针指向地址内的值设为常量</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//将指针指向地址内的值设为常量</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//将指针指向的地址内设为常量，即不能改变指针指向</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//两者都不能修改</span></span><br></pre></td></tr></table></figure></div></li>
<li>const可以使类里面的函数不能修改类<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> var;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//第一个const表示返回值不可改变，这里的第二个const就使得函数不可以修改类，只能读取类的值</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> var;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>mutable修饰，可以使被const的函数去修改类<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> var;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> var2；</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//这里的const就使得函数不可以修改类，只能读取类的值</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">mutable</span> var2 = <span class="number">2</span>； <span class="comment">//因为是mutable修饰的变量，所以const函数里面可以将它修改 </span></span><br><span class="line">		<span class="keyword">return</span> var;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-4-类的初始化成员列表"><a href="#1-7-4-类的初始化成员列表" class="headerlink" title="1.7.4.类的初始化成员列表"></a>1.7.4.类的初始化成员列表</h3><ul>
<li>在类的构造函数括号后面紧接着：并将变量赋值：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_number;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Example</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is Example_1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Example</span>(<span class="type">int</span> num)</span><br><span class="line">		:<span class="built_in">m_number</span>(num) <span class="comment">//将变量用括号内值赋值</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is Example_2 with&quot;</span> &lt;&lt; m_number &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>有一种减少性能消耗的方式<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_number;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Example</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is Example_1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Example</span>(<span class="type">int</span> num)</span><br><span class="line">		:<span class="built_in">m_number</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;this is Example_2 with&quot;</span> &lt;&lt; m_number &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Example m_example;</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">int</span> num)</span><br><span class="line">		: <span class="built_in">m_example</span>(num) <span class="comment">//这里就可以防止生成额外的实例</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//m_example = Example(num); //这就导致产生了两个Example实例，而有一个只是创建了没有被实际使用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-5-三元操作符"><a href="#1-7-5-三元操作符" class="headerlink" title="1.7.5.三元操作符"></a>1.7.5.三元操作符</h3><ul>
<li>实际上就是if-else的语法糖</li>
<li>将要赋值的变量 &#x3D; 判定条件？ 赋值1：赋值2;<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> curNum = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> comNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是正常写法</span></span><br><span class="line"><span class="keyword">if</span> (curNum &gt; comNum)</span><br><span class="line">&#123;</span><br><span class="line">	curNum = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	curNum = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是三元操作符写法</span></span><br><span class="line">curNum = curNum &gt; comNum ? <span class="number">20</span> : <span class="number">30</span>; </span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-6-隐式转换和explicit"><a href="#1-7-6-隐式转换和explicit" class="headerlink" title="1.7.6.隐式转换和explicit"></a>1.7.6.隐式转换和explicit</h3><h4 id="1-7-6-1-隐式构造函数以及转换"><a href="#1-7-6-1-隐式构造函数以及转换" class="headerlink" title="1.7.6.1.隐式构造函数以及转换"></a>1.7.6.1.隐式构造函数以及转换</h4><ul>
<li>构造函数相同，只是在创建实例的时候有一些不同<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	std::string m_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个不同构造函数</span></span><br><span class="line">	<span class="built_in">Example</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">	:m_name = name</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="built_in">Example</span>(<span class="type">int</span> age):<span class="built_in">m_number</span>(num)</span><br><span class="line">	:m_age = age</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Example <span class="title">a</span><span class="params">(<span class="string">&quot;ztl&quot;</span>)</span></span>;</span><br><span class="line">	Example a = <span class="string">&quot;ztl&quot;</span>; <span class="comment">//直接赋值，编译器自动转换为Example（&quot;ztl&quot;）</span></span><br><span class="line">	<span class="function">Example <span class="title">b</span><span class="params">(<span class="number">21</span>)</span></span>;</span><br><span class="line">	Example b = <span class="number">21</span>; <span class="comment">//直接赋值，编译器自动转换21为Example（21）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>将explicit写在构造函数之前，那么就不能隐式转换</li>
</ul>
<h3 id="1-7-7-运算符及其重载"><a href="#1-7-7-运算符及其重载" class="headerlink" title="1.7.7.运算符及其重载"></a>1.7.7.运算符及其重载</h3><h4 id="1-7-7-1-运算符"><a href="#1-7-7-1-运算符" class="headerlink" title="1.7.7.1.运算符"></a>1.7.7.1.运算符</h4><p>+，-，*，&#x2F;，new，delete，逗号，括号等也是运算符，运算符实际上就是函数</p>
<h4 id="1-7-7-2-重载"><a href="#1-7-7-2-重载" class="headerlink" title="1.7.7.2.重载"></a>1.7.7.2.重载</h4><ul>
<li>重载就是赋予新的定义和作用<br>以+为例<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载加法运算符</span></span><br><span class="line">    Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; v) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(x + v.x, y + v.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出向量的坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Vector result = v1 + v2; <span class="comment">// 调用重载的加法运算符</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Resultant vector: &quot;</span>;</span><br><span class="line">    result.<span class="built_in">display</span>(); <span class="comment">// 输出结果向量的坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
<li>除了类属关系运算符”.”、成员指针运算符”.*”、作用域运算符”::”、sizeof运算符和三目运算符”?:”以外，C++中的所有运算符都可以重载但是&#x3D;、()、[]、-&gt;这四个不能重载为类的友元函数。</li>
</ul>
<h3 id="1-7-8-关于this"><a href="#1-7-8-关于this" class="headerlink" title="1.7.8.关于this"></a>1.7.8.关于this</h3><ul>
<li>this是一个指向当前对象的指针，它是每个非静态成员函数的隐含参数</li>
<li>this返回的是指针，所以不是一个对象，而是对象地址，对于对象的变量引用应该是间接的，例如：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;x; <span class="comment">//意思是this指针所指向的对象，对这个对象的x变量修改</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-9-关于作用域"><a href="#1-7-9-关于作用域" class="headerlink" title="1.7.9.关于作用域"></a>1.7.9.关于作用域</h3><ul>
<li>当变量是在栈上创建的，脱离了作用域就会自动销毁</li>
<li>当是在堆上创建，脱离了作用域不会自动销毁</li>
<li>一个自动销毁的例子<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Create!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Destroy!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Entity* m_ptr;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//构造函数必须要是public，否则不能创建实例</span></span><br><span class="line">	<span class="built_in">Example</span>(Entity* ptr)</span><br><span class="line">	:<span class="built_in">m_ptr</span>(ptr) <span class="comment">//构造的时候，传递指针</span></span><br><span class="line">	&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	~<span class="built_in">Example</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr; <span class="comment">//析构的时候，将指针删除</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Example e = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">//隐式转换；虽然是栈上创建的Example，但是Entity实例会自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-8-1-智能指针（-include-）"><a href="#1-8-1-智能指针（-include-）" class="headerlink" title="1.8.1.智能指针（#include &lt;memory&gt;）"></a>1.8.1.智能指针（#include &lt;memory&gt;）</h3><ul>
<li>unique_ptr指针（默认不能隐式构造，也不能拷贝构造和拷贝赋值，并且同一时间有独占所有权语义）<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>; <span class="comment">//默认不能使用隐式转换，需要手动管理内存;先创建一个Entity，然后传给shared_ptr分配内存</span></span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;; <span class="comment">//更加安全（处理异常）,会自动管理内存，否则造成内存泄漏</span></span><br></pre></td></tr></table></figure></div></li>
<li>shared_ptr指针（存在引用计数）<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>; <span class="comment">//先创建Entity，然后share_ptr分配一个内存控制空间，用作引用计数</span></span><br><span class="line">std::shared_ptr&lt;Entity&gt; entity = std::make_shared&lt;Entity&gt;; <span class="comment">//组合一次性创建，性能强大</span></span><br></pre></td></tr></table></figure></div></li>
<li>还有一个weak_ptr，与shared_ptr一同使用，不会增加引用计数<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;Entity&gt; weakEntity = sharedEntity; <span class="comment">//将一个shared_ptr给weak_ptr弱指针</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-8-2-复制与拷贝构造函数"><a href="#1-8-2-复制与拷贝构造函数" class="headerlink" title="1.8.2.复制与拷贝构造函数"></a>1.8.2.复制与拷贝构造函数</h3><ul>
<li>C++的类默认有拷贝构造函数，用于将</li>
<li>浅拷贝和深拷贝：<br>浅拷贝（Shallow Copy）：<br>浅拷贝是指将一个对象的值复制到另一个对象，而不复制内存地址。换句话说，浅拷贝只复制了对象的引用，而没有复制对象的内容。<br>在浅拷贝中，如果对象内部包含指针或动态分配的内存，那么只会复制指针的值，而不会复制指针所指向的内容。因此，多个对象可能会共享同一块内存，这就可能导致一旦其中一个对象修改了内存中的数据，其他对象也会受到影响。<br>浅拷贝通常是通过对象的复制构造函数或赋值运算符实现的。<br>深拷贝（Deep Copy）：<br>深拷贝是指在复制对象时，会递归地复制对象及其包含的所有数据，而不仅仅是复制对象的引用。这意味着每个对象都有自己独立的内存空间存储数据，彼此之间互不影响。<br>在深拷贝中，对象的所有成员变量以及动态分配的内存都会被复制，因此每个对象都拥有自己的一份数据副本。<br>深拷贝通常需要自定义对象的复制构造函数和赋值运算符，确保在复制过程中进行适当的内存分配和数据复制。</li>
<li>拷贝构造函数：<br>用于创建一个新对象，该对象的内容是另一个同类对象的副本<br>被调用的条件：</li>
</ul>
<ol>
<li>对象初始化，使用一个已经存在的对象来创建另一个新的对象</li>
<li>作为参数传递的时候，会用拷贝构造函数创建一个副本</li>
<li>作为函数的返回值，返回的时候同样创建一个副本<br>如果将拷贝函数 &#x3D; delete;，那么类禁止拷贝</li>
</ol>
<h3 id="1-8-3-箭头操作符"><a href="#1-8-3-箭头操作符" class="headerlink" title="1.8.3.箭头操作符"></a>1.8.3.箭头操作符</h3><ul>
<li>通常用于访问类或结构体对象的成员，特别是在对象是指针类型时<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">printfa</span>()</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">	(*e).<span class="built_in">printfa</span>(); <span class="comment">//需要逆向引用才可以使用.进行调用函数</span></span><br><span class="line">	e-&gt;<span class="built_in">printfa</span>(); <span class="comment">//箭头可以直接对指针的成员进行访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>还可以获取类中或者结构体中数据的偏移量</li>
</ul>
<h1 id="2-C-标准库"><a href="#2-C-标准库" class="headerlink" title="2.C++标准库"></a>2.C++标准库</h1><h2 id="2-1-C-标准库"><a href="#2-1-C-标准库" class="headerlink" title="2.1.C++标准库"></a>2.1.C++标准库</h2><h3 id="2-1-1-C-动态数组Vector"><a href="#2-1-1-C-动态数组Vector" class="headerlink" title="2.1.1.C++动态数组Vector"></a>2.1.1.C++动态数组Vector</h3><ul>
<li>动态数组与原始数组不同的是，它可以不设定原始大小，可以动态增加数组大小<br>原理是，创建一个新的更大的数组，将原本小的数组复制到这个大数组里面，然后删除原有数组<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VectoX</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> VectoX&amp; vectox)</span><br><span class="line">&#123;</span><br><span class="line">	stream &lt;&lt; vectox.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vectox.y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vectox.z;</span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;VectoX&gt; list;</span><br><span class="line">	list.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">//push_back可以将元素加入动态数组中</span></span><br><span class="line">	list.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;);</span><br><span class="line">	list.<span class="built_in">push_back</span>(&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++)</span><br><span class="line">		std::cout &lt;&lt; list[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; list.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">//获取数组长度</span></span><br><span class="line">	list.<span class="built_in">erase</span>(list.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">//erase()可以进行索引删除，begin()得到数组第一个索引</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (VectoX&amp; v : list) <span class="comment">//循环方法</span></span><br><span class="line">		std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	list.<span class="built_in">clear</span>(); <span class="comment">//清空数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>一些优化，避免过多复制<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">list.<span class="built_in">reserve</span>(num); <span class="comment">//让Vector预留三个位置，从而不用创建新数组，删除旧数组</span></span><br><span class="line">list.<span class="built_in">emplace_back</span>(); <span class="comment">//直接在Vector里面添加新的元素，而不是在main栈帧里面创建然后复制</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-1-2-C-动态库（处理二进制库）"><a href="#2-1-2-C-动态库（处理二进制库）" class="headerlink" title="2.1.2.C++动态库（处理二进制库）"></a>2.1.2.C++动态库（处理二进制库）</h3><ul>
<li>可执行文件被执行的时候，动态链接库才开始加载</li>
<li>.dll和.dll.lib文件，其中.lib要配置，而.dll应该要放到可执行文件目录下</li>
</ul>
<h3 id="2-1-3-C-静态库（源代码实际编译）"><a href="#2-1-3-C-静态库（源代码实际编译）" class="headerlink" title="2.1.3.C++静态库（源代码实际编译）"></a>2.1.3.C++静态库（源代码实际编译）</h3><ul>
<li>头文件(.h)告诉编译器哪些函数可以用，库文件(.lib)提供定义，然后链接器链接到那些函数</li>
<li>静态链接允许更多的优化</li>
</ul>
<h3 id="2-1-4-C-返回多个值"><a href="#2-1-4-C-返回多个值" class="headerlink" title="2.1.4.C++返回多个值"></a>2.1.4.C++返回多个值</h3><ul>
<li>tuple以及pair（两者相差不大，就是使用上面的区别）<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>...&gt; <span class="title">Function</span><span class="params">()</span> <span class="comment">//自定义返回的数量以及类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_pair</span>(string, <span class="type">int</span>); <span class="comment">//将实参传入return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> a = <span class="built_in">Function</span>();</span><br><span class="line">	std::get&lt;<span class="number">0</span>&gt;a; <span class="comment">//tuple的使用</span></span><br><span class="line">	a.first; <span class="comment">//pair的使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>struct<br>可以通过命名，并且return {}；非常简单</li>
<li>C++17之后，可以通过结构化绑定进行获取<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>[a, b] = <span class="built_in">Function</span>(); <span class="comment">//自动获取a,b的类型（根据返回的顺序）</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-1-5-C-模板、泛型（templates）"><a href="#2-1-5-C-模板、泛型（templates）" class="headerlink" title="2.1.5.C++模板、泛型（templates）"></a>2.1.5.C++模板、泛型（templates）</h3><ul>
<li>基于给定编译器的规则，编译器自动写出代码（并且是函数调用的时候，才根据传递类型自动生成代码）<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//typename也可以是class，T可以是任意自取命名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span> <span class="comment">//T就是类型，value就是参数名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">print</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">20</span>); <span class="comment">//隐式转换</span></span><br><span class="line">	<span class="built_in">print</span>&lt;std::string&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>也可以对类进行模板<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T array[N]; <span class="comment">//这个类型也可以自行定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Array&lt;std::string, <span class="number">20</span>&gt; array;</span><br><span class="line">	std::cout &lt;&lt; array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2-2-C"><a href="#2-2-C" class="headerlink" title="2.2.C++"></a>2.2.C++</h2><h3 id="2-2-1-内存区域"><a href="#2-2-1-内存区域" class="headerlink" title="2.2.1.内存区域"></a>2.2.1.内存区域</h3><ul>
<li>五大内存区域<br>1.栈（stack）：用于存储函数的局部变量、函数的参数值等。在程序执行期间，栈的大小是动态变化的，每当调用函数时，会在栈上分配一块内存空间，函数执行结束时释放这些空间。<br>2.堆（heap）：用于动态分配内存，即通过 new 或 malloc 等操作来分配内存。在程序运行期间，堆的大小也是动态变化的，需要手动释放动态分配的内存，否则可能会导致内存泄漏。<br>3.全局&#x2F;静态存储区（Global&#x2F;Static Storage Area）：用于存储全局变量、静态变量等。这些变量在程序启动时被分配内存，在程序结束时释放。<br>4.常量存储区（Constant Storage Area）：用于存储常量值，例如字符串常量。这些值在程序编译时就已经确定，并存储在常量存储区中<br>5.代码区（Code Area）：用于存储程序的代码。这部分内存通常是只读的，并且在程序执行期间不会被修改</li>
<li>栈和堆的区别<br>栈：栈预定义为2M左右的内存空间，内存分配的是一段连续的空间，分配速度更快，未初始化的时候为cc<br>堆：堆大小会变化，内存分配为不同的地方，分配速度更慢，未初始化的时候为cd  </li>
<li>malloc and free ， new and delete<br>系统会维护空闲列表（free list），用于跟踪空闲内存块，并且跟踪他们的位置。当malloc调用时，需要动态内存时，浏览free list，找到合适内存空间，然后返回那片空间的指针，记录大小以及使用情况（避免再次使用）</li>
</ul>
<h3 id="2-2-2-宏"><a href="#2-2-2-宏" class="headerlink" title="2.2.2. 宏"></a>2.2.2. 宏</h3><ul>
<li>宏（Macros）是一种在编程中常用的预处理指令，用于在编译之前进行文本替换，从而实现代码重用和简化，C++中，宏以#define定义<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN int main()\	</span></span><br><span class="line">&#123;\</span><br><span class="line">	std::cin.<span class="built_in">get</span>();\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>一个例子<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> PR_DEBUG == 1 <span class="comment">//可以在属性里设置preprocessor Definitions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt;x&lt;&lt;std::endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div></li>
<li>宏中__Function__代表着函数的函数名</li>
</ul>
<h3 id="2-2-3-auto关键字"><a href="#2-2-3-auto关键字" class="headerlink" title="2.2.3.auto关键字"></a>2.2.3.auto关键字</h3><ul>
<li>auto可以自动通过编译器获取变量类型<br>auto自动获取变量的双刃剑：可以自动获取变量类型，但是也可能破坏代码结构</li>
<li>可以为已有类型名添加别名的两种方式<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> INT = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-4-C-静态数组（-include-）"><a href="#2-2-4-C-静态数组（-include-）" class="headerlink" title="2.2.4.C++静态数组（#include &lt;array&gt;）"></a>2.2.4.C++静态数组（#include &lt;array&gt;）</h3><ul>
<li>创建在栈上的数组类实例<br>array存在边界检查<br>array可以获取数组大小.size()<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::array&lt;Type, Num&gt; Array; <span class="comment">//Type是存储类型，Num是数组大小</span></span><br></pre></td></tr></table></figure></div></li>
<li>与vector的对比<br>1.array创建在栈上，vector创建在堆上；<br>2.array是静态数组，大小固定；vector是动态数组，大小可变</li>
</ul>
<h3 id="2-2-5-C-函数指针（原始函数指针，源自于C语言）"><a href="#2-2-5-C-函数指针（原始函数指针，源自于C语言）" class="headerlink" title="2.2.5.C++函数指针（原始函数指针，源自于C语言）"></a>2.2.5.C++函数指针（原始函数指针，源自于C语言）</h3><ul>
<li>函数指针存储着函数的内存地址，使得可以通过该指针调用函数<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">void</span>(*Zero)() = Hello; <span class="comment">//将函数指针指向Hello（这里有一个隐式转换，实际上是 = &amp;Hello）</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Zero</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*isZero)</span><span class="params">()</span></span>; <span class="comment">//创建类型别名，isZero是一个函数指针别名</span></span><br><span class="line">	isZero _zero = Hello;</span><br><span class="line"></span><br><span class="line">	_zero();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>函数指针调用的实例<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Value is : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetArray</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vector, <span class="type">void</span>(*func)(<span class="type">int</span>))</span> <span class="comment">//定义输入函数指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v : vector) <span class="comment">//遍历数组</span></span><br><span class="line">		<span class="built_in">func</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; vector = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span> &#125;; <span class="comment">//初始化列表</span></span><br><span class="line">	<span class="built_in">GetArray</span>(vector, Print); <span class="comment">//将Print函数的地址传入</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-6-lambda函数（匿名函数）"><a href="#2-2-6-lambda函数（匿名函数）" class="headerlink" title="2.2.6.lambda函数（匿名函数）"></a>2.2.6.lambda函数（匿名函数）</h3><ul>
<li>lambda通常和函数指针放在一起使用，可以简洁地定义一个函数<br>语法为<a href="parameters">capture</a> -&gt; return_type { body }<br>capture:捕获，可以是&#x3D;，表示捕获所有值；&amp;，表示捕获引用；也可以是具体变量a,&amp;b；<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> lambda = [](<span class="type">int</span> a) &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="built_in">Print</span>(lambda);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-7-namespace-名称空间、命名空间"><a href="#2-2-7-namespace-名称空间、命名空间" class="headerlink" title="2.2.7.namespace(名称空间、命名空间)"></a>2.2.7.namespace(名称空间、命名空间)</h3><ul>
<li>为了避免同样的函数，引入命名空间<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line">	<span class="built_in">function</span>(); <span class="comment">//可以直接调用</span></span><br><span class="line">	<span class="keyword">namespace</span> a = apple;</span><br><span class="line">	a::<span class="built_in">function</span>(); <span class="comment">//通过作用域使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-8-线程（-include-）"><a href="#2-2-8-线程（-include-）" class="headerlink" title="2.2.8.线程（#include &lt;thread&gt;）"></a>2.2.8.线程（#include &lt;thread&gt;）</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> is_waiting = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals; <span class="comment">//让线程暂停的命名空间</span></span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt;<span class="string">&quot;this thread is&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; <span class="comment">//获取当前线程的id</span></span><br><span class="line">	<span class="keyword">while</span> (!is_waiting)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Waiting...\n&quot;</span>;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s); <span class="comment">//每次停顿一秒</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;this thread is&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; <span class="comment">//获取当前线程的id</span></span><br><span class="line">	<span class="function">std::thread <span class="title">worker</span><span class="params">(Print)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">	is_waiting = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	worker.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-2-9-计时（-include-）"><a href="#2-2-9-计时（-include-）" class="headerlink" title="2.2.9.计时（#include &lt;chrono&gt;）"></a>2.2.9.计时（#include &lt;chrono&gt;）</h3><ul>
<li>可以对函数线程等等进行的时间进行计算<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals; <span class="comment">//引用这个命名空间，以便使用其中的函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); <span class="comment">//获取当前时间</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">	<span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); <span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line">	std::chrono::duration&lt;<span class="type">float</span>&gt; duration = end - start; <span class="comment">//计算出两者时间间隔</span></span><br><span class="line">	std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>可以使用对象作用时间作为计时器原理</li>
<li>题外话：\n比std::endl;更优化</li>
</ul>
<h3 id="2-3-1-C-多维数组"><a href="#2-3-1-C-多维数组" class="headerlink" title="2.3.1.C++多维数组"></a>2.3.1.C++多维数组</h3><ul>
<li>数组本质上是指针，所以一些元素的指针的集合就是指针数组，以此为原理创建多维数组<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>*** a3d = <span class="keyword">new</span> <span class="type">int</span>** [<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a3d[i] = <span class="keyword">new</span> <span class="type">int</span>* [<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a3d[i][j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				a3d[i][j][k] = (i + <span class="number">1</span>) * (j + <span class="number">1</span>) + k;</span><br><span class="line">				std::cout &lt;&lt; a3d[i][j][k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			std::cout&lt;&lt;std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>delete数组需要将所有释放，否则导致内存泄漏<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] a3d[i][j];	<span class="comment">//将每一个整型数组删除，删除并不会影响到后面的数组，因为是一一映射的</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] a3d[i]; <span class="comment">//将每一个指向整型数组的指针删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] a3d; <span class="comment">//将指向数组的指针的三维数组指针删除</span></span><br></pre></td></tr></table></figure></div></li>
<li>一维数组同样可以做到二维数组的事情，因为内存分配是在一个连续的内存块，因此速度会更快，是一种优化的方法<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[j + i * <span class="number">5</span>] = j + i * <span class="number">5</span>;</span><br><span class="line">		std::cout &lt;&lt; a[j + i * <span class="number">5</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-3-2-C-排序-std-sort，-include"><a href="#2-3-2-C-排序-std-sort，-include" class="headerlink" title="2.3.2.C++排序(std::sort，#include &lt;algorithm&gt;)"></a>2.3.2.C++排序(std::sort，#include &lt;algorithm&gt;)</h3><ul>
<li>C++库中内置的排序函数</li>
<li>可以对各种数据结构进行排序，也可以用不同的函数或者说方式进行排序<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) <span class="comment">//可以传入函数或者lambda</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> a &lt; b;</span><br><span class="line">		&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v : values)</span><br><span class="line">		std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-3-3-C-类型双关"><a href="#2-3-3-C-类型双关" class="headerlink" title="2.3.3.C++类型双关"></a>2.3.3.C++类型双关</h3><ul>
<li>想要将一个数据当作另外一个类型，只需要得到它的指针并且转换指针类型<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a =<span class="number">2</span>, b=<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">	<span class="type">int</span>* pos = (<span class="type">int</span>*) &amp; e; <span class="comment">//获取地址并且转换为int指针</span></span><br><span class="line">	pos[<span class="number">0</span>] = <span class="number">6</span>; <span class="comment">//可以将其当作数组处理</span></span><br><span class="line">	pos[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">	std::cout &lt;&lt; e.a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; e.b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>结构体如果为空，那么它是一个字节用于寻址，如果是有例如int a, int b，那么就只有这两者大小。并且是在一段连续内存中</li>
</ul>
<h3 id="2-3-4-C-联合体"><a href="#2-3-4-C-联合体" class="headerlink" title="2.3.4.C++联合体"></a>2.3.4.C++联合体</h3><ul>
<li>联合体内的东西是同一个内存指向<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Union</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">float</span> a;</span><br><span class="line">		<span class="type">int</span> b;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Union u;</span><br><span class="line">	u.a = <span class="number">2.0f</span>;</span><br><span class="line">	std::cout &lt;&lt; u.a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; u.b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>可以作为类型转换的一个技巧</li>
</ul>
<h3 id="2-3-5-虚析构函数"><a href="#2-3-5-虚析构函数" class="headerlink" title="2.3.5.虚析构函数"></a>2.3.5.虚析构函数</h3><ul>
<li>析构函数加上virtual与其他类中的函数加上virtual不一样，而是对析构函数加上一个功能，如果没有加上virtual,那么只能调用基类的析构函数<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A Destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">B</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;B Destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	B* b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">	<span class="keyword">delete</span> b;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	A* c = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">	<span class="keyword">delete</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>派生类指针不能指向基类对象，因为基类没有派生类的元素，所以指向基类的话导致不能对成员变量访问。默认可以上行转换（up_cast），想要下行可以进行dynamic_cast转换</li>
</ul>
<h3 id="2-3-5-类型转换"><a href="#2-3-5-类型转换" class="headerlink" title="2.3.5.类型转换"></a>2.3.5.类型转换</h3><ul>
<li>C语言型转换<br>隐式转换和显式转换<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="type">float</span> b = a; <span class="comment">//这样就会自动隐式转换为float类型</span></span><br><span class="line">	<span class="type">float</span> b = (<span class="type">float</span>)a; <span class="comment">//(float)就是一个显式转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>C++语言型转换(cast)<br>static_cast：用于在编译时进行类型转换<br>dynamic_cast：用于在运行时进行安全的向下转换，成功会返回指针，失败返回nullptr  <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> :<span class="keyword">public</span> Entity&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span>:<span class="keyword">public</span> Entity&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Player* player = <span class="keyword">new</span> <span class="built_in">Player</span>();</span><br><span class="line">	</span><br><span class="line">	Entity* acEnemy = <span class="keyword">new</span> <span class="built_in">Enemy</span>();</span><br><span class="line">	Entity* acPlayer = player;</span><br><span class="line"></span><br><span class="line">	Player* p0 = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(acPlayer); <span class="comment">//成功</span></span><br><span class="line">	Player* p1 = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(acEnemy); <span class="comment">//失败</span></span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; p0 &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
const_cast：用于从表达式中删除const或volatile修饰符<br>reinterpret_cast：用于进行指针类型之间的不安全转换，通常用于底层编程或与硬件交互</li>
</ul>
<h3 id="2-3-6-C-安全"><a href="#2-3-6-C-安全" class="headerlink" title="2.3.6.C++安全"></a>2.3.6.C++安全</h3><ul>
<li>关于内存泄漏、非法访问、降低崩溃</li>
<li>实际上归结为两大问题：内存问题、所有权问题</li>
</ul>
<h3 id="2-3-7-预编译头文件-pch"><a href="#2-3-7-预编译头文件-pch" class="headerlink" title="2.3.7.预编译头文件(.pch)"></a>2.3.7.预编译头文件(.pch)</h3><ul>
<li>就是防止某些库过多次被进行编译。预编译头文件是二进制文件，可以被编译器处理</li>
<li>将一些不会改变的库等等放入pch中，减少编译时间；但是对于依赖的可读性就没有那么高<br>将头文件放入.h中，然后将这个name.h #include到一个cpp文件，然后右键这个文件，选择properties-&gt;C&#x2F;C++-&gt;Precompiled Header-&gt;Precompiled Header中选择为creat；然后进入整个项目的properties，同样更改Precompiled Header里面为Use。</li>
</ul>
<h2 id="2-4-C-17特性"><a href="#2-4-C-17特性" class="headerlink" title="2.4.C++17特性"></a>2.4.C++17特性</h2><h3 id="2-4-1-处理optional数据（-include-）"><a href="#2-4-1-处理optional数据（-include-）" class="headerlink" title="2.4.1.处理optional数据（#include &lt;optional&gt;）"></a>2.4.1.处理optional数据（#include &lt;optional&gt;）</h3><ul>
<li>可以用于包装可能存在或者可能不存在的值<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; maybeValue; <span class="comment">// 声明一个可能不存在的 int 值</span></span><br><span class="line">    </span><br><span class="line">    maybeValue = <span class="number">42</span>; <span class="comment">// 现在 maybeValue 包含了一个值为 42 的 int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maybeValue.<span class="built_in">has_value</span>()) &#123; <span class="comment">//这里可以直接if(maybeValue)</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;maybeValue has value: &quot;</span> &lt;&lt; maybeValue.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;maybeValue has no value.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 maybeValue 的值（如果有的话）</span></span><br><span class="line">    <span class="type">int</span> value = maybeValue.<span class="built_in">value_or</span>(<span class="number">0</span>); <span class="comment">// 如果 maybeValue 为空，则返回默认值 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-4-2-单一变量存放多种数据（-include-）"><a href="#2-4-2-单一变量存放多种数据（-include-）" class="headerlink" title="2.4.2.单一变量存放多种数据（#include &lt;variant&gt;）"></a>2.4.2.单一变量存放多种数据（#include &lt;variant&gt;）</h3><ul>
<li>将可能的类型写入，variant会对每一种类型值进行存储<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var;</span><br><span class="line">    </span><br><span class="line">    var = <span class="number">42</span>; <span class="comment">// 存储一个 int 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    var = <span class="number">3.14</span>; <span class="comment">// 存储一个 double 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    var = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 存储一个 std::string 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-4-3-单一变量存储任意类型数据（-include-）"><a href="#2-4-3-单一变量存储任意类型数据（-include-）" class="headerlink" title="2.4.3.单一变量存储任意类型数据（#include &lt;any&gt;）"></a>2.4.3.单一变量存储任意类型数据（#include &lt;any&gt;）</h3><ul>
<li>可以存储任意类型数据<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any a;</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">5</span>; <span class="comment">// 存储一个 int 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">3.14</span>; <span class="comment">// 存储一个 double 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(a) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 存储一个 std::string 类型的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-4-4-any和variant的比较"><a href="#2-4-4-any和variant的比较" class="headerlink" title="2.4.4.any和variant的比较"></a>2.4.4.any和variant的比较</h3><ul>
<li>any可以存储任何类型数据，variant可以存储有限的已经设定的一些数据类型</li>
<li>any会进行动态分配，而variant不会，因此variant比any性能要好</li>
</ul>
<h2 id="2-5-C-优化"><a href="#2-5-C-优化" class="headerlink" title="2.5.C++优化"></a>2.5.C++优化</h2><h3 id="2-5-1-多线程（-include-）"><a href="#2-5-1-多线程（-include-）" class="headerlink" title="2.5.1.多线程（#include &lt;future&gt;）"></a>2.5.1.多线程（#include &lt;future&gt;）</h3><ul>
<li>利用核心加载东西，实时加载需要的东西</li>
<li>如果要引用传递参数，需要使用std::ref()<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行 foo 函数，并获取其结果</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result_future = std::<span class="built_in">async</span>(foo, <span class="number">10</span>); <span class="comment">//函数里面是异步的操作，出来又是同步的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步操作的结果</span></span><br><span class="line">    <span class="type">int</span> result = result_future.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-5-2-字符串优化-std-string-view，C-17里面才有的"><a href="#2-5-2-字符串优化-std-string-view，C-17里面才有的" class="headerlink" title="2.5.2.字符串优化(std::string_view，C++17里面才有的)"></a>2.5.2.字符串优化(std::string_view，C++17里面才有的)</h3><ul>
<li>字符串默认情况下是用new进行堆创建，因此对于性能有一些损耗，尤其是对字符串的部分截取。因此std::string_view提供了一种指针办法，不是重新创建一个堆分配，而是一个指针指向原本字符串<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::string name = <span class="string">&quot;ztl love lxy&quot;</span>;</span><br><span class="line"><span class="function">std::string_view <span class="title">ztl</span><span class="params">(name.c_str(), <span class="number">3</span>)</span></span>; <span class="comment">//c_str()返回该字符串的指针</span></span><br><span class="line"><span class="function">std::string_view <span class="title">lxy</span><span class="params">(name.c_str() + <span class="number">9</span>, <span class="number">3</span>)</span></span>; <span class="comment">//从起始位置开始，往后三个字符</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-5-3-可视化基准测试"><a href="#2-5-3-可视化基准测试" class="headerlink" title="2.5.3.可视化基准测试"></a>2.5.3.可视化基准测试</h3><ul>
<li>可以使用gogle chrome里面的可视化基准测试，搜索chrome:&#x2F;&#x2F;tracing即可</li>
</ul>
<h3 id="2-5-4-单例模式"><a href="#2-5-4-单例模式" class="headerlink" title="2.5.4.单例模式"></a>2.5.4.单例模式</h3><ul>
<li>单例有单一数据集以及一些功能，有着代表数据的类成员变量，成员函数（对特定数据集执行操作）</li>
<li>单例类形同命名空间，C++中的单例模式仅仅只是一种组织一堆全局变量和静态函数的方式<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">//删除复制构造函数，从而禁止实例的复制</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> <span class="comment">//用于获取单例实例</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> Singleton s_singleton; <span class="comment">//可以将声明放到这里，因为static修饰的变量，不论调用多少次，只会被实际调用一次</span></span><br><span class="line">		<span class="keyword">return</span> s_singleton;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Get</span>().<span class="built_in">IFloat</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">IFloat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.5f</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125; <span class="comment">//将构造函数设置为private，使得不能创建实例</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//static Singleton m_singleton; //这是一个静态实例，也就是唯一的单例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Singleton Singleton::m_singleton; //静态成员变量需要在类外进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> num1 = Singleton::<span class="built_in">Float</span>(); <span class="comment">//这里直接使用静态函数Float</span></span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> num2 = Singleton::<span class="built_in">Get</span>().<span class="built_in">Float</span>(); <span class="comment">//通过单例引用，然后去调用Float函数(适用于Float函数不是static修饰)</span></span><br><span class="line">	std::cout &lt;&lt; num1&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
以上确保单例模式的条件：<br>1.将构造函数设置为private<br>2.将复制构造函数删除<br>3.Get函数返回一个引用单例</li>
</ul>
<h3 id="2-5-5-小字符串优化（SSO）"><a href="#2-5-5-小字符串优化（SSO）" class="headerlink" title="2.5.5.小字符串优化（SSO）"></a>2.5.5.小字符串优化（SSO）</h3><ul>
<li>小于一定大小的字符串，C++自动在小栈内进行内存分配，从而不需要堆分配，做到自动化优化</li>
</ul>
<h3 id="2-5-6-内存跟踪方法"><a href="#2-5-6-内存跟踪方法" class="headerlink" title="2.5.6.内存跟踪方法"></a>2.5.6.内存跟踪方法</h3><ul>
<li>通过对new和delete的重载，以及断点的设置从而达到跟踪的效果<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocationMetrics</span> <span class="comment">//用于跟踪的计数结构体</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> TotalAllocated = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> TotalFreed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">uint32_t</span> <span class="title">CurrentUsage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TotalAllocated - TotalFreed; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TotalAllocatedAdd</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TotalAllocated += size;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TotalFreedAdd</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TotalFreed += size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> AllocationMetrics _Metricer; <span class="comment">//创建静态实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span>  <span class="comment">//重载new</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_Metricer.<span class="built_in">TotalAllocatedAdd</span>(size);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Allocating...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* memory, <span class="type">size_t</span> size)</span> <span class="comment">//重载delete</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_Metricer.<span class="built_in">TotalFreedAdd</span>(size);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Freeing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Current Usage:&quot;</span> &lt;&lt; _Metricer.<span class="built_in">CurrentUsage</span>() &lt;&lt; <span class="string">&quot;bytes\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PrintMemory</span>();</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	std::string name = <span class="string">&quot;ztl love lxy&quot;</span>;</span><br><span class="line">	<span class="built_in">PrintMemory</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">PrintMemory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-5-7-左值和右值"><a href="#2-5-7-左值和右值" class="headerlink" title="2.5.7.左值和右值"></a>2.5.7.左值和右值</h3><ul>
<li>左值(L-value):通常在等号左边，是可以被取地址的表达式。</li>
<li>右值(R-value):通常在等号右边，是一些不能被进一步引用的临时对象或字面量</li>
<li>但是有一些情况右值可以被引用：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="comment">//加上const，就可以对字面量或者临时变量进行引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(std::string&amp;&amp; name)</span> <span class="comment">//加上两个&amp;，就只可以引用右值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string name_1 = <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">	std::string name_2 = <span class="string">&quot;isZero&quot;</span>;</span><br><span class="line">	<span class="built_in">Function</span>(name_1);</span><br><span class="line">	<span class="built_in">Function</span>(name_2);</span><br><span class="line">	<span class="built_in">Function</span>(name_1 + name_2); <span class="comment">//这里name_1+name_2属于是临时变量</span></span><br><span class="line">	<span class="built_in">Function</span>(<span class="string">&quot;ztl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-5-8-移动语义"><a href="#2-5-8-移动语义" class="headerlink" title="2.5.8.移动语义"></a>2.5.8.移动语义</h3><ul>
<li>通过&amp;&amp;标记的引用类型，绑定到右值或者临时对象<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>() = <span class="keyword">default</span>; <span class="comment">//原始构造函数</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* name) <span class="comment">//创建构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">		m_size = <span class="built_in">strlen</span>(name);</span><br><span class="line">		m_name = <span class="keyword">new</span> <span class="type">char</span>[m_size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_name, name, m_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; string) <span class="comment">//复制构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">		m_size = string.m_size;</span><br><span class="line">		m_name = <span class="keyword">new</span> <span class="type">char</span>[m_size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_name, string.m_name, m_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(String&amp;&amp; name) <span class="keyword">noexcept</span> <span class="comment">//移动语义构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		m_size = name.m_size;</span><br><span class="line">		m_name = name.m_name; <span class="comment">//将指针传递给m_name，通过浅拷贝</span></span><br><span class="line"></span><br><span class="line">		name.m_size = <span class="number">0</span>;</span><br><span class="line">		name.m_name = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_name[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_name;</span><br><span class="line">	<span class="type">uint32_t</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">		:<span class="built_in">m_string</span>(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>(String&amp;&amp; name) <span class="comment">//移动语义</span></span><br><span class="line">		:<span class="built_in">m_string</span>(std::<span class="built_in">move</span>(name))&#123;&#125; <span class="comment">//这里std::move()也可以是(String&amp;&amp;)name。</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;m_string.<span class="built_in">print</span>();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	String m_string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Entity <span class="title">e</span><span class="params">(<span class="string">&quot;ztl&quot;</span>)</span></span>;</span><br><span class="line">	e.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>std::move就是将一个已经存在的变量，转换成一个临时变量，从而作为移动语义函数或者移动赋值操作符</li>
</ul>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>UI框架</title>
    <url>/Blog/2024/04/29/UI%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="框架要素（MVC模式）"><a href="#框架要素（MVC模式）" class="headerlink" title="框架要素（MVC模式）"></a>框架要素（MVC模式）</h1><ul>
<li>UIManager：将manager设置为单例模式</li>
<li>BasePanel：用于控制UI的一些函数，需要继承Monobehaviour以对其他节点进行控制</li>
<li>界面配置关系：UI名称、UI预制体路径等</li>
</ul>
<h2 id="1-UIManager"><a href="#1-UIManager" class="headerlink" title="1.UIManager"></a>1.UIManager</h2><ul>
<li>确保UIManager是单例模式</li>
<li>创建字典来分别保存路径、预制体、以及已经打开的UI</li>
<li>利用UIConst作为不同UI配置</li>
<li>调用BasePanel实例的open和close<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UIManager _uiManager;</span><br><span class="line">    <span class="comment">//预制体字典</span></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, GameObject&gt; prefabsLists;</span><br><span class="line">    <span class="comment">//路径字典</span></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pathLists;</span><br><span class="line">    <span class="comment">//已经打开的UI</span></span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, BasePanel&gt; panelLists;</span><br><span class="line">    <span class="keyword">private</span> Transform _uiRoot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_uiManager == <span class="literal">null</span>)</span><br><span class="line">                _uiManager = <span class="keyword">new</span> UIManager();</span><br><span class="line">            <span class="keyword">return</span> _uiManager;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitUI();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UI界面配置，名称与Prefabs路径等</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _uiRoot = UIRoot;</span><br><span class="line">        panelLists = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, BasePanel&gt;();</span><br><span class="line">        prefabsLists = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, GameObject&gt;();</span><br><span class="line">        pathLists = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; UIConst.MainPanel, <span class="string">&quot;Prefabs/UI/MainPanel&quot;</span> &#125;,</span><br><span class="line">            &#123; UIConst.SuccessPanel, <span class="string">&quot;Prefabs/UI/SuccessPanel&quot;</span> &#125;,</span><br><span class="line">            &#123; UIConst.FailPanel, <span class="string">&quot;Prefabs/UI/FailPanel&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取根节点</span></span><br><span class="line">    <span class="keyword">private</span> Transform UIRoot</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_uiRoot == <span class="literal">null</span>)</span><br><span class="line">                _uiRoot = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line">            <span class="keyword">return</span> _uiRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasePanel <span class="title">OpenPanel</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BasePanel panel = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (panelLists.TryGetValue(name, <span class="keyword">out</span> panel))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(name + <span class="string">&quot;界面已经打开&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!pathLists.TryGetValue(name, <span class="keyword">out</span> path))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(name + <span class="string">&quot;的UI路径出错！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        GameObject panelPrefabs = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prefabsLists.TryGetValue(name, <span class="keyword">out</span> panelPrefabs))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> realpath = path;</span><br><span class="line">            panelPrefabs = Resources.Load&lt;GameObject&gt;(realpath) <span class="keyword">as</span> GameObject;</span><br><span class="line">            prefabsLists.Add(name, panelPrefabs);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打开界面</span></span><br><span class="line">        GameObject panelObject = GameObject.Instantiate(panelPrefabs);</span><br><span class="line">        panel = panelObject.GetComponent&lt;BasePanel&gt;();</span><br><span class="line">        panel.OpenPanel(name);</span><br><span class="line">        panelLists.Add(name, panel);</span><br><span class="line">        <span class="keyword">return</span> panel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ClosePanel</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BasePanel panel = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!panelLists.TryGetValue(name, <span class="keyword">out</span> panel))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;界面未打开！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        panel.ClosePanel();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UI定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIConst</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> MainPanel = <span class="string">&quot;MainPanel&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> SuccessPanel = <span class="string">&quot;SuccessPanel&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> FailPanel = <span class="string">&quot;FailPanel&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2-BasePanel"><a href="#2-BasePanel" class="headerlink" title="2.BasePanel"></a>2.BasePanel</h2><ul>
<li>基本打开和关闭方法<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BasePanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="built_in">bool</span> isReMove = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">protected</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OpenPanel</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">this</span>._name = name;</span><br><span class="line">      gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ClosePanel</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">      isReMove = <span class="literal">true</span>;  </span><br><span class="line">      gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">      Destroy(gameObject);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UIManager.Instance.panelLists.ContainsKey(_name))</span><br><span class="line">      &#123;</span><br><span class="line">         UIManager.Instance.panelLists.Remove(_name);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="3-界面配置关系"><a href="#3-界面配置关系" class="headerlink" title="3.界面配置关系"></a>3.界面配置关系</h2><p>Unity中可以使用两种方式，一种是Excel导入，一种是使用Unity自带的</p>
]]></content>
  </entry>
  <entry>
    <title>Games101</title>
    <url>/Blog/2024/02/13/Games101/</url>
    <content><![CDATA[<h1 id="Games101"><a href="#Games101" class="headerlink" title="Games101"></a>Games101</h1><h2 id="1-变换（Transformation）"><a href="#1-变换（Transformation）" class="headerlink" title="1.变换（Transformation）"></a>1.变换（Transformation）</h2><h3 id="1-1MVP变换-将物体转化到-1-1-3的立方体上面"><a href="#1-1MVP变换-将物体转化到-1-1-3的立方体上面" class="headerlink" title="1.1MVP变换-&gt;将物体转化到[-1, 1]^3的立方体上面"></a>1.1MVP变换-&gt;将物体转化到[-1, 1]^3的立方体上面</h3><h2 id="2-光栅化（Rasterization）"><a href="#2-光栅化（Rasterization）" class="headerlink" title="2.光栅化（Rasterization）"></a>2.光栅化（Rasterization）</h2><ul>
<li>就是将MVP转化的结果，画到二维数组上面</li>
</ul>
<h3 id="2-1-屏幕（pixel）"><a href="#2-1-屏幕（pixel）" class="headerlink" title="2.1.屏幕（pixel）"></a>2.1.屏幕（pixel）</h3><ul>
<li>颜色表示：RGB</li>
<li>屏幕：二维数组，从左下角的(0, 0)开始，所以每一个像素(x, y)的中心在于(x+0.5, y+0.5)。</li>
</ul>
<h3 id="2-2-画到屏幕上"><a href="#2-2-画到屏幕上" class="headerlink" title="2.2.画到屏幕上"></a>2.2.画到屏幕上</h3><ul>
<li>[-1, 1]^3的立方体转化到[0, h]高度以及[0, w]宽度上面：<br>1.将立方体拉伸到h，w<br>2.将立方体移到中心<br>变换矩阵：</li>
</ul>
<h3 id="2-3-三角形作为Mesh"><a href="#2-3-三角形作为Mesh" class="headerlink" title="2.3.三角形作为Mesh"></a>2.3.三角形作为Mesh</h3><ul>
<li>为何选择三角形<br>1.最为基本的图形<br>2.任何图像都可以拆成三角形<br>3.三个顶点的属性定义之后，可以对三角形内部进行插值计算</li>
<li>采样（Sample）：从不同的位置取值,将函数离散化；重复频域</li>
<li>给定一个三角形，要对其采样，需要对每个屏幕空间中每个像素的中心进行一个判断，看是否在三角形内部<br>这里涉及到了叉积，三角形ABC，以及一个未知点Q，如果<strong>AB</strong> 和 <strong>AQ</strong>的叉积，与<strong>BC</strong> 和 <strong>BQ</strong>的叉积，以及<strong>CA</strong> 和 <strong>CQ</strong>的叉积方向一致（右手螺旋定则），说明点Q在三角形内部；否则Q点在三角形外部</li>
<li>如果点落在三角形上，有些定则是：计上不计下，计左不计右</li>
<li>三角形包围盒（BoundingBox）：不需要将所有像素进行判断，只需要将三个顶点，MAX&#x2F;MIN(A.x&#x2F;y,B.x&#x2F;y,C.x&#x2F;y)分别求出来</li>
<li>现实生活中LCD<br>BayerPattern：红绿蓝组成图案，绿色偏多（人眼对于绿色更为敏感）</li>
</ul>
<h3 id="2-4-走样（Aliasing，Jaggies）"><a href="#2-4-走样（Aliasing，Jaggies）" class="headerlink" title="2.4.走样（Aliasing，Jaggies）"></a>2.4.走样（Aliasing，Jaggies）</h3><ul>
<li>因为采样率有限，所以导致走样</li>
<li>Artifacts：图形学中的瑕疵  </li>
<li>由于走样产生的瑕疵：锯齿（Jaggies）、摩尔纹（Moire）、滚轮（Wagon Wheel Effect）</li>
<li>走样原理：信号改变太快，但是采样太慢了</li>
<li>频域（Frequency Domain）<br>频谱中高频意味着图像的边界，低频意味着图像的平坦区域，大块背景；两条亮白色线意味着时域图的边界发生剧烈频域变化</li>
<li>反走样（Anti Aliasing）：<br>1.滤波（模糊，卷积）：模糊处理，也就是低通滤波，然后进行采样。不能反过来，因为先采样已经走样了，然后对走样的信号进行模糊处理<br>2.多重采样抗锯齿（MSAA）：将每一个像素取不同采样点，计算更精确一些的图像属性，并没有实际增大分辨率。但是增大计算量，消耗性能</li>
<li>其他反走样：<br>FXAA（Fast Approximate AA）：图像后处理，与采样无关，速度很快<br>TAA（Temporal AA）：采用上一帧的像素值</li>
</ul>
<h3 id="2-5-深度缓存（Z-buffering）"><a href="#2-5-深度缓存（Z-buffering）" class="headerlink" title="2.5.深度缓存（Z-buffering）"></a>2.5.深度缓存（Z-buffering）</h3><ul>
<li>画家算法：先绘制背景，然后逐一绘制前景中的物体，后画的会覆盖前画的物体。局限：多个物体相互遮挡，导致不能判断深度，复杂度为O(nlogn)</li>
<li>z-buffer算法：通过对每一个像素进行值替换，与顺序无关，只与深度有关。（深度缓存发生在每一个像素里面）复杂度为O(n)<br>需要额外创建buffer：<br>frame-buffer：实际要展示的存储值<br>depth-buffer:每一个像素对应的深度值<br>算法原理：先是所有像素设置为无限大，对于一个像素中，看它的深度大于还是小于当前像素的深度，小于替换，大于就不变。</li>
</ul>
<h2 id="3-着色（Shading）"><a href="#3-着色（Shading）" class="headerlink" title="3.着色（Shading）"></a>3.着色（Shading）</h2><ul>
<li>着色：对不同物体应用不同材质的过程（不同材质对于光的反应不同）</li>
</ul>
<h3 id="3-1-布林冯模型-Blinn-Phong-Reflectance-Model-："><a href="#3-1-布林冯模型-Blinn-Phong-Reflectance-Model-：" class="headerlink" title="3.1.布林冯模型(Blinn-Phong Reflectance Model)："></a>3.1.布林冯模型(Blinn-Phong Reflectance Model)：</h3><ul>
<li>高光(Specular highlights):光源直射光。<br>引入半程向量<strong>h</strong>，<strong>h</strong> &#x3D; bisector(<strong>v</strong>, <strong>l</strong>)，即(<strong>v</strong> + <strong>l</strong>)&#x2F;||(<strong>v</strong> + <strong>l</strong>)||。cosα &#x3D; <strong>n</strong> * <strong>h</strong>，其中α为半程向量和法线夹角。<br>Ls &#x3D; Ks(I&#x2F;r^2) * MAX(0, <strong>n</strong> * <strong>h</strong>)^p<br>Ks表示白色系数,p用于限制视线方向的高光范围，通常为100~200  </li>
<li>漫反射(Diffuse reflection):与物体表面法线有关，根据光线与物体表面法线夹角有关，cosθ &#x3D; <strong>l</strong> * <strong>n</strong>,其中<strong>l</strong>为光线方向，<strong>n</strong>为物体法线方向。因此得到<br>Ld &#x3D; Kd(I&#x2F;r^2) * MAX(0, <strong>l</strong> * <strong>n</strong>)<br>其中Kd为材质的漫反射系数，反射出去的颜色为没有吸收的能量，如果表示为RGB值，则表示颜色。由于均匀反射出去，那么从任意一个方向观测都是一样结果，因此与观测方向无关  </li>
<li>环境光(Ambient lighting):均匀间接光照结果<br>La &#x3D; Ka * Ia<br>Ka是环境光系数，Ia为环境光强度<br>与视觉发向、光照方向都无关，是一个常量<br>L &#x3D; Ls + Ld + La</li>
<li>shading是局部的,没有shadow，也就是忽略所有的其他物体存在，只考虑自己</li>
</ul>
<h3 id="3-2-Shading频率"><a href="#3-2-Shading频率" class="headerlink" title="3.2.Shading频率"></a>3.2.Shading频率</h3><ul>
<li>Shading 频率：一个平面进行一次BP模型<br>Flat shading：三角形着色，每一个三角形都是一个颜色，对于平滑表面不太适合<br>Gouraud shading：顶点着色<br>Phong shading：像素着色</li>
<li>着色频率取决于物体本身平面频率如何</li>
<li>顶点法线求法：对顶点四周平面进行加权或者不加权平均。</li>
<li>通过重心坐标获得顶点之间的插值法线</li>
</ul>
<h3 id="3-3-渲染管线"><a href="#3-3-渲染管线" class="headerlink" title="3.3.渲染管线"></a>3.3.渲染管线</h3><ol>
<li>输入场景（点）  shader，可以在硬件里面执行的，里面有控制顶点和像素如何着色的</li>
<li>投影</li>
<li>形成三角形</li>
<li>光栅化</li>
<li>着色</li>
<li>输出<br>GPU：Graphics Process Unit，图形处理单元<br>着色器：顶点着色器、像素着色器<br>shadertoy.com</li>
</ol>
<h3 id="3-4-纹理映射（Texture-Mapping）"><a href="#3-4-纹理映射（Texture-Mapping）" class="headerlink" title="3.4.纹理映射（Texture Mapping）"></a>3.4.纹理映射（Texture Mapping）</h3><h4 id="3-4-1-纹理应用"><a href="#3-4-1-纹理应用" class="headerlink" title="3.4.1.纹理应用"></a>3.4.1.纹理应用</h4><ul>
<li>物体表面实际上是2D的，也就是将一张图片贴在3D物体上，这张图就是纹理（Texture），贴的过程就叫做映射</li>
<li></li>
<li>纹理上设定uv坐标系</li>
<li>对一个采样点，利用重心坐标（从面积算出）算出uv（利用重心坐标和三个顶点得到uv）</li>
<li>纹理定义的就是Diffuse reflect里面的Kd</li>
</ul>
<h4 id="3-4-2-纹理对应"><a href="#3-4-2-纹理对应" class="headerlink" title="3.4.2.纹理对应"></a>3.4.2.纹理对应</h4><ul>
<li>纹理太小（需要Texture Maginification）：<br>四舍五入(Nearest)<br>线性插值(Bilinear Interpolation)：对周围四个uv值进行插值<br>二次立方(Bicubic)：对周围16个值进行插值</li>
<li>纹理太大(导致出现纹理混叠):<br>范围查询(Mipmap):快速，但是只能适用于简单规则正方形。将一张纹理放小一半，如256 * 256到128 * 128…将存储量变小，仅仅是原本的三分之一。<br>且Mipmap会将第D&#x3D;log2L层寻找<br>如果在两层之间，如0和1之间的0.8层，则可以进行第三步插值，也就是三线性插值<br>各向异性过滤(Anisotropic Filtering):对于矩形查询优化，生成了其他单水平或垂直方向图，开销为原本三倍，也就是Ripmap<br>EWA Filtering：多次查询圆形</li>
</ul>
<h3 id="3-5-重心坐标-Barycentric-coodinates"><a href="#3-5-重心坐标-Barycentric-coodinates" class="headerlink" title="3.5.重心坐标(Barycentric coodinates)"></a>3.5.重心坐标(Barycentric coodinates)</h3><ul>
<li>顶点着色的时候，需要对三角形内部进行插值(纹理uv坐标，颜色，法线方向)，也就需要利用重心坐标</li>
<li>重心坐标定义在三角形内，设▲ABC，则同一个平面中任意一个点(x,y),都可以得到(x, y) &#x3D; αA + βB + γC，其中α + β + γ &#x3D; 1.如果三者都大于0，则点在三角形内。重心坐标就是(α， β， γ)<br>ABC内切圆心O，则α &#x3D; Sboc&#x2F;Sabc，β &#x3D; Saoc&#x2F;Sabc，γ &#x3D; Saob&#x2F;Sabc。三角形面积三等分的点对于重心坐标就是(1&#x2F;3, 1&#x2F;3, 1&#x2F;3)</li>
<li>对于插值属性，同样是使用重心坐标</li>
<li>重心坐标缺点：光栅化时，三角形形状在投影下是有缺陷的，不确定的，与原本三角形重心坐标不同。</li>
</ul>
<h3 id="3-6-纹理应用（Application）"><a href="#3-6-纹理应用（Application）" class="headerlink" title="3.6.纹理应用（Application）"></a>3.6.纹理应用（Application）</h3><h4 id="3-6-1-环境映射"><a href="#3-6-1-环境映射" class="headerlink" title="3.6.1.环境映射"></a>3.6.1.环境映射</h4><ul>
<li>球面映射(存在扭曲现象)</li>
<li>立方体映射</li>
</ul>
<h4 id="3-6-2-其他贴图"><a href="#3-6-2-其他贴图" class="headerlink" title="3.6.2.其他贴图"></a>3.6.2.其他贴图</h4><ul>
<li>凹凸&#x2F;法线贴图(Bump&#x2F;Normal Map)：可以展示凹凸效果，但是并没有实际对几何体改变<br>n(p) &#x3D; (0, 0, 1)<br>dp&#x2F;du &#x3D; c1 * [h(u+1) - h(u)]<br>dp&#x2F;dv &#x3D; c2 * [h(v+1) - h(v)]<br>n &#x3D; (-dp&#x2F;du, -dp&#x2F;dv, 1)</li>
<li>位移贴图(Displacement Mapping)：将实际的几何体进行改变<br>缺点：需要更多采样点，模型需要足够细致</li>
</ul>
<h4 id="3-6-3-三维纹理"><a href="#3-6-3-三维纹理" class="headerlink" title="3.6.3.三维纹理"></a>3.6.3.三维纹理</h4><ul>
<li>利用三维空间中的噪声函数进行纹理映射（例如Perlin Noise）  </li>
<li>预先进行环境光遮蔽计算模型阴影  </li>
<li>体渲染通过三维纹理记录信息，然后进行渲染</li>
</ul>
<h2 id="4-几何-Geometry"><a href="#4-几何-Geometry" class="headerlink" title="4.几何(Geometry)"></a>4.几何(Geometry)</h2><h3 id="4-1-几何的表示方法"><a href="#4-1-几何的表示方法" class="headerlink" title="4.1.几何的表示方法"></a>4.1.几何的表示方法</h3><h4 id="4-1-1-两种方法"><a href="#4-1-1-两种方法" class="headerlink" title="4.1.1.两种方法"></a>4.1.1.两种方法</h4><ul>
<li>隐式（Implicit):直接将几何体使用公式表示出来<br>优点：可以直接判断一个点在几何体内外<br>缺点：不能直接看出几何体形状<br>举例：（x² + 9y²&#x2F;4 + z² - 1）³ &#x3D; x²z³ + 9y²z³&#x2F;80，这是一个心形</li>
<li>显式（Explicit):把点直接给出或者参数映射（u，v）-&gt;（x，y，z）<br>优点：可以直观得到几何体（可以是几何体点的集合，也可以是映射关系明确）<br>缺点：不能很容易判断一个点是否在几何体内外</li>
</ul>
<h4 id="4-1-2-一些其他的隐式"><a href="#4-1-2-一些其他的隐式" class="headerlink" title="4.1.2.一些其他的隐式"></a>4.1.2.一些其他的隐式</h4><ul>
<li>代数曲面（algebraic surface）：通过一些代数式表示</li>
<li>构造立体几何法（Constructive Solid Geometry，CSG）：通过一些几何体的交、并、差等操作</li>
<li>距离函数（Distance Function，SDF）：不直接描述表面，而是描述每一个点到一个表面的最短距离，正在外，负在内，通过融合（blend）距离函数，将这些点表示出来</li>
<li>水平集（Level Set Method）：将距离函数用数组表示，从而进行绘制</li>
<li>分形（Fractals）：不断重复自身，类似于函数递归概念</li>
</ul>
<h3 id="4-2-曲线和曲面（Curves-and-Surfaces，显式几何）"><a href="#4-2-曲线和曲面（Curves-and-Surfaces，显式几何）" class="headerlink" title="4.2.曲线和曲面（Curves and Surfaces，显式几何）"></a>4.2.曲线和曲面（Curves and Surfaces，显式几何）</h3><h4 id="4-2-1-几个例子"><a href="#4-2-1-几个例子" class="headerlink" title="4.2.1.几个例子"></a>4.2.1.几个例子</h4><ul>
<li>点云（Point Cloud）：用密集点进行几何体构造<br>可以构造任意一种几何体，在扫描里面经常使用</li>
<li>多边形面（Polygon Mesh）：三角形或者四边形表达几何体。是应用最广泛的方式</li>
<li>.obj文件<br>实际上就是.txt文件，用于存储一些数据，例如纹理，坐标，法线，重心</li>
</ul>
<h4 id="4-2-2-曲线（Curves）"><a href="#4-2-2-曲线（Curves）" class="headerlink" title="4.2.2.曲线（Curves）"></a>4.2.2.曲线（Curves）</h4><ul>
<li>贝塞尔曲线（Bézier Curve）：用一系列控制点定义曲线  </li>
<li>属性：<br>1.经过起始点和终点<br>2.起始切线和结尾切线都是(n-1)(b0-b1)<br>3.仿射曲线<br>4.所有点都在凸包内</li>
<li>德卡斯特里奥算法：定义一个线段AB上面的点C，并系数u（0 &lt; u &lt; 1），使得AC &#x3D; u AB，得到C坐标 C &#x3D; uA + (1-u)B<br>伯恩斯坦：b^n(t) &#x3D; &amp;&amp;Σb_jB_j^n(t)&amp;&amp;</li>
<li>逐段贝塞尔曲线：当控制点太多时，就很难控制。也就是切点<br>C0连续：点线结合<br>C1连续：一阶导数连续</li>
<li>样条（Splines）：一个可控的曲线</li>
</ul>
<h4 id="4-2-3-曲面（Surfaces）"><a href="#4-2-3-曲面（Surfaces）" class="headerlink" title="4.2.3.曲面（Surfaces）"></a>4.2.3.曲面（Surfaces）</h4><ul>
<li>贝塞尔曲面：将多条贝塞尔曲线上面的点作为控制点，制作贝塞尔曲线</li>
</ul>
<h4 id="4-2-4-几何处理"><a href="#4-2-4-几何处理" class="headerlink" title="4.2.4.几何处理"></a>4.2.4.几何处理</h4><h5 id="4-2-4-1-网格细分（Mesh-Subdivision）网格正规化（Mesh-Regularization）"><a href="#4-2-4-1-网格细分（Mesh-Subdivision）网格正规化（Mesh-Regularization）" class="headerlink" title="4.2.4.1.网格细分（Mesh Subdivision）网格正规化（Mesh Regularization）"></a>4.2.4.1.网格细分（Mesh Subdivision）网格正规化（Mesh Regularization）</h5><ul>
<li>卢氏细分（Loop Subdivision)：<br>1.将三角形每个线段中点作为新点，并且相连，得到四个三角形<br>2.将新生成的点平移，将周围四个点进行加权平均，得到新点的位置；旧点度为n，以及权重u，则旧点变为(1-n * u) * 原本位置+u*周围旧点位置之和   </li>
<li>Catmull-Clark Subdivision：用于非三角形<br>非四边形面（Non-quad face）：不是四边形的面<br>奇异点（extraordinary vertex）：只要度不是4都是奇异点<br>1.每一个线取中点，每一个面也取一个点<br>2.将这些点相连<br>第一次操作之后：<br>1.奇异点增加<br>2.非四边形面消失<br>实际上也就是非四边形变成奇异点，此后再次进行的时候，都是非四边形</li>
</ul>
<h5 id="4-2-4-2-网格简化（Mesh-Simplification）"><a href="#4-2-4-2-网格简化（Mesh-Simplification）" class="headerlink" title="4.2.4.2.网格简化（Mesh Simplification）"></a>4.2.4.2.网格简化（Mesh Simplification）</h5><ul>
<li>网格简化：有些时候只需要一个大概的轮廓就行，不需要那么精细的网格。例如远处的物体</li>
<li>边坍缩(Edge Collaps)：将边结合起来成一个点<br>二次误差度量(Quadric Error Metric)：当前顶点到其邻域所有三角面（也称关联平面）的距离平方和。<br>需要使用堆进行每一次二次误差度量</li>
</ul>
<h4 id="4-2-5-阴影-Shadow-Mapping"><a href="#4-2-5-阴影-Shadow-Mapping" class="headerlink" title="4.2.5.阴影(Shadow Mapping)"></a>4.2.5.阴影(Shadow Mapping)</h4><ul>
<li>在阴影里面的定义：在光源点看不到这个点，也不能被相机看到</li>
<li>Shadow Mapping只能处理点光源投射的阴影，处理的是硬阴影</li>
<li>步骤：<br>1.从光源看向场景，光栅化，记录每一个点的深度为多少（z-buffer）<br>2.从相机看向场景，光栅化，计算点到光源成像的深度为多少，并且与第一步的z-buffer进行比较，如果一样，说明可见，如果不一致，就在阴影里</li>
<li>有一些误差问题，因为浮点型很难判断是否相等。用两者距离在一个小范围之内，也就是bias小浮动</li>
<li>硬阴影和软阴影：<br>硬阴影：要么可见要么不可见<br>软阴影：有一定过渡，完全看不到为本影，能看到一点叫做伴影。产生的根本原因是光源本身有大小</li>
</ul>
<h1 id="5-光线追踪（Ray-Tracing）"><a href="#5-光线追踪（Ray-Tracing）" class="headerlink" title="5.光线追踪（Ray Tracing）"></a>5.光线追踪（Ray Tracing）</h1><ul>
<li>产生的原因：光栅化不能解决软阴影、且有些光照会反射多次</li>
<li>特点：光线追踪很精确，但是非常慢，适用于制作动画，但是实时渲染很慢</li>
</ul>
<h2 id="5-1-光线追踪"><a href="#5-1-光线追踪" class="headerlink" title="5.1.光线追踪"></a>5.1.光线追踪</h2><ul>
<li>光线的定义：<br>1.光沿直线传播<br>2.光与光之间不会碰撞<br>3.光路可逆</li>
<li>递归光线追踪（Recursive（Whitted-Style） Ray Tracing）：<br>光源（light source）、首发光线（primary rays）、二次光线（secondary rays）<br>从相机或视线位置发出光线，射到目标像素，然后根据折射或者反射计算光线去向（实际也就是光线来源），然后每次判断光源是否可以照射到新的像素点</li>
</ul>
<h2 id="5-2-光线表面交点（Ray-Surface-Intersection）"><a href="#5-2-光线表面交点（Ray-Surface-Intersection）" class="headerlink" title="5.2.光线表面交点（Ray-Surface Intersection）"></a>5.2.光线表面交点（Ray-Surface Intersection）</h2><ul>
<li>光线的数学定义：射线，是一个向量，每一个向量上的点都用<strong>r</strong>(t) &#x3D; o + t<strong>d</strong>，其中o为光线起始点，<strong>d</strong>为单位方向向量，t为系数  </li>
<li>光线与几何体的交点：<br>1.隐式：可以直接联立方程式<br>2.显式：对一个封闭几何体，任意一个点发出一道射线，与几何体交点为奇数个，说明点在几何体内部；偶数个，说明在几何体外部</li>
<li>判断光线是否与三角形相交：<br>先将光线与三角形的面相交得到与三角形平面的交点，然后利用之前的叉积判断这个点是否在三角形内，如果在，说明相交，；不在，说明不相交<br>光线与平面的交点求法：<br>平面方程为P：（p-p’）* <strong>N</strong> &#x3D; 0，其中p’为任意一个平面上面的点，<strong>N</strong>为平面法向量。与光线联立可得交点</li>
<li>mt算法：可以直接计算得到光线是否与三角形相交</li>
</ul>
<h2 id="5-3-光线表面交点加速"><a href="#5-3-光线表面交点加速" class="headerlink" title="5.3.光线表面交点加速"></a>5.3.光线表面交点加速</h2><p>每一个光线都要计算一次场景求交，因此需要提高速度</p>
<ul>
<li>包围盒(Bounding Volumes):利用一个包围盒将物体完全包住<br>加速原理：如果光线没有经过包围盒，就不可能射过几何体  </li>
<li>光线和AABB求交：<br>将AABB看作是一个由三个对面的集合，所以当光线进入所有的对面之间，才算进入到AABB里面；只要有光线射出所有对面之间，就算出了AABB<br>算法：将光线与AABB三组对面的交点时间tmin和tmax，tenter &#x3D; max（tmin），texit &#x3D; min（tmax），如果tenter&lt;texit且texit&gt;&#x3D;0，说明光线进入了AABB</li>
</ul>
<h3 id="5-3-1-均匀空间划分（Uniform-Spatial-Partitions）使用格子"><a href="#5-3-1-均匀空间划分（Uniform-Spatial-Partitions）使用格子" class="headerlink" title="5.3.1.均匀空间划分（Uniform Spatial Partitions）使用格子"></a>5.3.1.均匀空间划分（Uniform Spatial Partitions）使用格子</h3><p>1.找到包围盒<br>2.创建格子<br>3.将可能存在物体表面的格子储存  </p>
<ul>
<li><p>如果格子太少：达不到加速的目的</p>
</li>
<li><p>如果格子太多：导致性能下降</p>
</li>
<li><p>格子划分数 &#x3D; C * 场景物体数量，其中3D里，C ≈ 27</p>
</li>
<li><p>然而均匀空间划分对于大规模无物体空间，导致许多性能浪费</p>
</li>
</ul>
<h3 id="5-3-2-空间划分（Spatial-Partition）"><a href="#5-3-2-空间划分（Spatial-Partition）" class="headerlink" title="5.3.2.空间划分（Spatial Partition）"></a>5.3.2.空间划分（Spatial Partition）</h3><ul>
<li>Oct-Tree，八叉树，所谓八就是在空间中将空间分成均匀8份</li>
<li>KD-Tree，沿着某一个轴，总是砍成两个空间，类似二叉树</li>
<li>BSP-Tree，对空间二分，每一次选择不同方向</li>
</ul>
<p>KD-Tree：与大盒子有交点，于是将盒子细分，再进行判断里面的盒子是否有交，如此递归，一直到不能再分了，就对其中所有物体进行求交。  </p>
<ul>
<li>缺点：可能一个物体在不同盒子之内都存在，也可能三角形包住了盒子</li>
</ul>
<h3 id="5-3-3-Bounding-Volume-Hierarchy（BVH）"><a href="#5-3-3-Bounding-Volume-Hierarchy（BVH）" class="headerlink" title="5.3.3.Bounding Volume Hierarchy（BVH）"></a>5.3.3.Bounding Volume Hierarchy（BVH）</h3><p>1.找到包围盒<br>2.递归地将空间划分成两个子集，然后重新计算子盒子的包围盒（选择节点中最长的轴 或者 取中间的物体的位置来划分节点。）<br>3.满足要求时停止下来，不再划分，并且将物体存储在叶子结点中</p>
<ul>
<li>弥补了KD-Tree的问题，使得每一个物体只会出现在一个盒子里，并且不用考虑三角形与包围盒求交</li>
<li>缺点：没有把空间严格分开，存在空间重叠</li>
<li>伪代码：<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intersect(Ray ray,BVH node)&#123;</span><br><span class="line">	if(ray misses node.bbox) return;</span><br><span class="line">	if(node is a leaf node)</span><br><span class="line">		test intersection with all objs;</span><br><span class="line">		return closest intersection;</span><br><span class="line">	</span><br><span class="line">	hit1 = Intersect(ray,node.child1);</span><br><span class="line">	hit2 = Intersect(ray,node.child2);</span><br><span class="line"></span><br><span class="line">	return the closer of hit1,hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="5-4-辐射度量学（Radiometry）"><a href="#5-4-辐射度量学（Radiometry）" class="headerlink" title="5.4.辐射度量学（Radiometry）"></a>5.4.辐射度量学（Radiometry）</h2><ul>
<li>由于Whitted-Style形成的光线追踪体系其实并不够真实，引入辐射度量学</li>
</ul>
<h3 id="5-4-1-一些物理量"><a href="#5-4-1-一些物理量" class="headerlink" title="5.4.1.一些物理量"></a>5.4.1.一些物理量</h3><p>Radiant Energy（辐射能量），单位为焦耳，J<br>Radiant Flux（辐射通量）功率，单位为瓦特&#x2F;流明，W&#x2F;lm<br>Radiant Intensity（辐射强度）光源发出的某一方向上的亮度，每一个立体角度（立体面积除以半径r²）对应的能量，lm&#x2F;sr，也就是cd，得出I &#x3D; ⨚&#x2F;4Π<br>Radiant Irradiance（辐射光照度）某一平面所接受到的光线亮度<br>Radiant Radiance（辐射亮度）一条传播光线所具有的亮度  </p>
]]></content>
  </entry>
  <entry>
    <title>Unity中存储框架</title>
    <url>/Blog/2024/04/30/Unity%E4%B8%AD%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="数据存储框架"><a href="#数据存储框架" class="headerlink" title="数据存储框架"></a>数据存储框架</h1><ul>
<li>分为两种，网络存储和本地存储</li>
</ul>
<h2 id="1-本地存储"><a href="#1-本地存储" class="headerlink" title="1.本地存储"></a>1.本地存储</h2><ul>
<li>Unity中可以有两种方式，一种是CSV文件，一种是使用Unity自带</li>
</ul>
<h3 id="1-1-Unity自带"><a href="#1-1-Unity自带" class="headerlink" title="1.1.Unity自带"></a>1.1.Unity自带</h3><ul>
<li>使用AssetMenu存储<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里使得可以右键创建文件</span></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;ConfigTable&quot;</span>, fileName = <span class="string">&quot;data&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PackageTable</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;BagConfig&gt; bagconfiga = <span class="keyword">new</span> List&lt;BagConfig&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里使得可以在检查器里面显示并且修改</span></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BagConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> describ;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> imgPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-2-CSV文件"><a href="#1-2-CSV文件" class="headerlink" title="1.2.CSV文件"></a>1.2.CSV文件</h3><p>利用csv文件创建相关配置，然后使用代码进行获取</p>
]]></content>
  </entry>
  <entry>
    <title>UnityStudy</title>
    <url>/Blog/2024/02/04/UnityStudy/</url>
    <content><![CDATA[<h1 id="Unity-使用学习"><a href="#Unity-使用学习" class="headerlink" title="Unity 使用学习"></a>Unity 使用学习</h1><ul>
<li>学习资料参考：<br><a class="link"   href="http://unity.cn/" >unity官方文档（中文版） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://b23.tv/ceAYoyi" >b站阿发教程（十分详尽） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h2 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1.基本结构"></a>1.基本结构</h2><h3 id="1-1-游戏物体"><a href="#1-1-游戏物体" class="headerlink" title="1.1.游戏物体"></a>1.1.游戏物体</h3><ul>
<li>cube：正方体  </li>
<li>sphere：球体  </li>
<li>cylinder：圆柱  </li>
<li>capsule：圆柱头  </li>
<li>plane：平面</li>
</ul>
<h3 id="1-2-资源文件"><a href="#1-2-资源文件" class="headerlink" title="1.2.资源文件"></a>1.2.资源文件</h3><ul>
<li>模型文件Model（*.fbx）</li>
<li>图片文件Texture（*.jpg&#x2F;png&#x2F;psd&#x2F;tif）</li>
<li>音频文件AudioClip（*.mp3&#x2F;wav&#x2F;aiff）</li>
<li>脚本文件Script（*.cs）</li>
<li>材质文件Meterial（*.mat）</li>
<li>场景文件Scene（*.unity）</li>
<li>描述文件Meta（*.meta）</li>
<li>预制体文件Prefab（*.prefab）</li>
</ul>
<h3 id="1-3-资源包"><a href="#1-3-资源包" class="headerlink" title="1.3.资源包"></a>1.3.资源包</h3><ul>
<li>选中资源文件或者目录</li>
<li>右键，点击export package</li>
<li>生成*.unitypackage资源包</li>
<li>依赖文件也可以一并导入</li>
</ul>
<h3 id="1-4-摄像机"><a href="#1-4-摄像机" class="headerlink" title="1.4.摄像机"></a>1.4.摄像机</h3><h4 id="1-4-1-摄像机构成"><a href="#1-4-1-摄像机构成" class="headerlink" title="1.4.1 摄像机构成"></a>1.4.1 摄像机构成</h4><ul>
<li>一个拥有camera组件的gameobject</li>
</ul>
<h4 id="1-4-2-移动方式"><a href="#1-4-2-移动方式" class="headerlink" title="1.4.2 移动方式"></a>1.4.2 移动方式</h4><ol>
<li>手工移动</li>
<li>Align with View，与3D视图对其<br>-&gt;在3D视图里面摆好角度<br>-&gt;选中camera，执行Gameobject<br>-&gt;Align with View（ctrl+shift+F）</li>
<li>可以使视角跟随物体运动：<br>-&gt;Edit<br>-&gt;Lock View to Seleted</li>
</ol>
<h3 id="1-5-脚本"><a href="#1-5-脚本" class="headerlink" title="1.5.脚本"></a>1.5.脚本</h3><h4 id="1-5-1-脚本创建和挂载"><a href="#1-5-1-脚本创建和挂载" class="headerlink" title="1.5.1 脚本创建和挂载"></a>1.5.1 脚本创建和挂载</h4><ul>
<li>脚本创建和编写</li>
<li>脚本挂载：<br>直接拖拽或者Add Component</li>
</ul>
<h4 id="1-5-2-脚本控制物体实例"><a href="#1-5-2-脚本控制物体实例" class="headerlink" title="1.5.2 脚本控制物体实例"></a>1.5.2 脚本控制物体实例</h4><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">transform.Position,物体世界坐标  </span><br><span class="line">transform.LocalPosition,物体本地坐标</span><br></pre></td></tr></table></figure></div>
<h3 id="1-6-帧更新"><a href="#1-6-帧更新" class="headerlink" title="1.6.帧更新"></a>1.6.帧更新</h3><ul>
<li><p>Update（）函数为帧更新函数,常用帧率观察：<br>Time.time，游戏时间<br>Time.deltaTime，距离上次更新时间  </p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Debug.log(<span class="string">&quot;每秒至少60帧&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>可以设置unity的帧率：  </p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Application.targetFrameRate = <span class="number">60</span>; <span class="comment">//将帧率调整为尽量60帧每秒</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-物体的运动"><a href="#1-7-物体的运动" class="headerlink" title="1.7.物体的运动"></a>1.7.物体的运动</h3><ul>
<li>物体运动实例<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> speed = <span class="number">2f</span>; <span class="comment">//设置速度</span></span><br><span class="line">        Vector3 pos = <span class="keyword">this</span>.transform.position; <span class="comment">//获取当前位置</span></span><br><span class="line">        pos.z += speed * Time.deltaTime; <span class="comment">//从速度与帧同步的联系，更改目标</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = pos; <span class="comment">//将物体移动</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
也可以使用transform.Translate(dx, dy, dz, Space.World&#x2F;Space.Self)进行帧移动：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> speed = <span class="number">2f</span>;</span><br><span class="line"><span class="built_in">float</span> distance = speed * Time.deltaTime;</span><br><span class="line"><span class="keyword">this</span>.transform.Translate(distance, <span class="number">0</span>, distance); <span class="comment">//Transform.Translate(dx, dy, dz)方法可以直接在不同方向上做增量</span></span><br></pre></td></tr></table></figure></div>
改变运动的方向<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">GameObject flag = GameObject.Find(<span class="string">&quot;flag&quot;</span>); <span class="comment">//Gameobject.Find(&quot;name_or_path&quot;)找到目标物体位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.LookAt(flag.transform); <span class="comment">//transform.LookAt(targetGameobject.Transform)将火车头转向目标位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(<span class="number">0</span>, <span class="number">0</span>, distance, Space.Self); <span class="comment">//Transform.Translate(dx, dy, dz)方法可以直接在不同方向上做增量</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-8-物体的旋转"><a href="#1-8-物体的旋转" class="headerlink" title="1.8.物体的旋转"></a>1.8.物体的旋转</h3><ul>
<li>四元组旋转(不建议使用)：  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">transform.rotation = (x, y, z, w);</span><br></pre></td></tr></table></figure></div></li>
<li>欧拉角旋转Euler Angle：   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">transform.eulerAngles = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>);  </span><br><span class="line">transform.localEulerAngles = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>可以使用transform.Rotate(x, y, z, Space.Self)进行帧旋转:  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.Rotate(<span class="number">0</span>, <span class="number">200</span> * Time.deltaTime, <span class="number">0</span>, Space.Self);</span><br></pre></td></tr></table></figure></div></li>
<li>自转与公转：<br>原理实际上就是建立父子关系，使用了空物体的技巧，将地月系统放在一个空物体下，地球放在轴心处，转动便成为公转自转</li>
</ul>
<h2 id="2-深入学习"><a href="#2-深入学习" class="headerlink" title="2.深入学习"></a>2.深入学习</h2><h3 id="2-1-脚本运行原理"><a href="#2-1-脚本运行原理" class="headerlink" title="2.1.脚本运行原理"></a>2.1.脚本运行原理</h3><ul>
<li>每个脚本都进行以下实例  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Gameobject object1 = <span class="keyword">new</span> Gameobject(); <span class="comment">//实例化节点</span></span><br><span class="line">MeshRender render = <span class="keyword">new</span> Meshrender(); <span class="comment">//实例化组件</span></span><br><span class="line">SimpleLogic script1 = <span class="keyword">new</span> SimpLogic(); <span class="comment">//实例化脚本组件</span></span><br><span class="line">Start(); <span class="comment">//初始化函数</span></span><br><span class="line">Update(); <span class="comment">//帧更新函数</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-消息函数-生命周期"><a href="#2-2-消息函数-生命周期" class="headerlink" title="2.2.消息函数&#x2F;生命周期"></a>2.2.消息函数&#x2F;生命周期</h3><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Awake(); <span class="comment">//初始化函数，仅执行一次（早于start）</span></span><br><span class="line">Start(); <span class="comment">//初始化函数，仅执行一次</span></span><br><span class="line">Update(); <span class="comment">//帧更新，每帧调用一次</span></span><br><span class="line">OnEnable(); <span class="comment">//每当组件启用时调用</span></span><br><span class="line">OnDisable(); <span class="comment">//每当组件禁用时调用</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-3-脚本执行优先级"><a href="#2-3-脚本执行优先级" class="headerlink" title="2.3.脚本执行优先级"></a>2.3.脚本执行优先级</h3><p>选中一个脚本，在inspector界面选择Execution Order，通过拖动或者手动调节脚本执行优先级（优先级值越小，优先级越高）</p>
<h3 id="2-4-主控脚本"><a href="#2-4-主控脚本" class="headerlink" title="2.4.主控脚本"></a>2.4.主控脚本</h3><p>游戏的主控逻辑存放脚本，例如：帧率，全局逻辑，全局设置等，然后放在一个主控节点上</p>
<h3 id="2-5-参数类型"><a href="#2-5-参数类型" class="headerlink" title="2.5.参数类型"></a>2.5.参数类型</h3><h4 id="2-5-1-值类型："><a href="#2-5-1-值类型：" class="headerlink" title="2.5.1. 值类型："></a>2.5.1. 值类型：</h4><p>int，float，bool，string，Vector，color<br>值类型不能为null</p>
<h4 id="2-5-2-引用类型："><a href="#2-5-2-引用类型：" class="headerlink" title="2.5.2. 引用类型："></a>2.5.2. 引用类型：</h4><p>GameObject，Transform，MeshRender，AudioSource，Meterial，Texture，AudioClip<br>都可以放到类的属性中，然后去到inspector赋值</p>
<h3 id="2-6-鼠标键盘等输入"><a href="#2-6-鼠标键盘等输入" class="headerlink" title="2.6.鼠标键盘等输入"></a>2.6.鼠标键盘等输入</h3><h4 id="2-6-1-鼠标输入"><a href="#2-6-1-鼠标输入" class="headerlink" title="2.6.1.鼠标输入"></a>2.6.1.鼠标输入</h4><ul>
<li>事件只会触发一次，并且状态每帧一次，全局事件互不干扰<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Input.GetMouseButtonDown(); <span class="comment">//鼠标按下触发（0是左键，1是右键，2是中键）</span></span><br><span class="line">Input.GetMouseButtonDown(); <span class="comment">//鼠标放开触发</span></span><br><span class="line">Input.GetMouseButton(); <span class="comment">//鼠标按住触发</span></span><br><span class="line">Input.mousePosition(); <span class="comment">//获取屏幕坐标</span></span><br></pre></td></tr></table></figure></div></li>
<li>屏幕坐标<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Camera.main.WorldToScreenPoint(worldPos); <span class="comment">//将世界坐标转换为屏幕坐标</span></span><br><span class="line">Screen.width; <span class="comment">//屏幕宽度</span></span><br><span class="line">Screen.height; <span class="comment">//屏幕高度</span></span><br></pre></td></tr></table></figure></div></li>
<li>键盘输入<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Input.GetKeyDown(keycode); <span class="comment">//键盘按下</span></span><br><span class="line">Input.GetKeyUp(keycode); <span class="comment">//键盘松开</span></span><br><span class="line">Input.GetKey(keycode); <span class="comment">//键盘按住</span></span><br><span class="line">Keycode.A; <span class="comment">//键盘A</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-7-组件调用"><a href="#2-7-组件调用" class="headerlink" title="2.7.组件调用"></a>2.7.组件调用</h3><ul>
<li>以音乐播放器为例  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">AudioSource audio = <span class="keyword">this</span>.GetComponent&lt;AudioSource&gt;(); <span class="comment">//获取AudioSource组件</span></span><br><span class="line">audio.Play(); <span class="comment">//播放</span></span><br></pre></td></tr></table></figure></div>
其中&lt;&gt;表示泛型，即获取<AudioSource>类型的组件  </li>
<li>也可以直接将所需要组件以public写出，拖拽组件所在节点，便会自动寻找到节点中的该组件</li>
<li>引用其他节点中的脚本组件同理可得，然后对组件中进行函数调用、属性修改等等</li>
<li>还可以使用消息调用方法： <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Gameobject <span class="built_in">object</span>;</span><br><span class="line"><span class="built_in">object</span>.SendMessage(<span class="string">&quot;Method&quot;</span>, index);</span><br></pre></td></tr></table></figure></div>
SendMessage的内部执行（反射机制，本质上是同步调用）：<br>1.找到target节点下所有组件<br>2.寻找Method函数<br>-&gt; 如果存在,调用它<br>-&gt; 如果不存在，继续遍历组件查找<br>-&gt; 最终如果无法匹配，则报错</li>
</ul>
<h3 id="2-8-物体获取"><a href="#2-8-物体获取" class="headerlink" title="2.8.物体获取"></a>2.8.物体获取</h3><h4 id="2-8-1-直接获取物体"><a href="#2-8-1-直接获取物体" class="headerlink" title="2.8.1.直接获取物体"></a>2.8.1.直接获取物体</h4><ul>
<li>通过Find方法（名字和路径）获取：   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Gameobject <span class="built_in">object</span> = Gameobject.Find(<span class="string">&quot;name_or_path&quot;</span>); <span class="comment">//指定name或者path获取</span></span><br></pre></td></tr></table></figure></div>
这种方法两个弊端：<br>1.不安全：如果修改节点名称，那么查找不到<br>2.需要遍历查找  </li>
<li>通过inspector拖拽获取  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Gameobject <span class="built_in">object</span>; <span class="comment">//定义一个public变量，在inspector可以获取</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="2-8-2-父子物体获取"><a href="#2-8-2-父子物体获取" class="headerlink" title="2.8.2.父子物体获取"></a>2.8.2.父子物体获取</h4><p><strong>获取需要使用Transform作为媒介</strong>  </p>
<ol>
<li>获取父级物体：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Transform parent = <span class="keyword">this</span>.transform.parent; <span class="comment">//获取父级Transform</span></span><br><span class="line">Gameobject parentNode = <span class="keyword">this</span>.transform.parent.gameObject; <span class="comment">//获取父级节点</span></span><br></pre></td></tr></table></figure></div></li>
<li>获取子级物体：<br>通过遍历获取：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(Transform child <span class="keyword">in</span> transform) <span class="comment">//遍历所有子节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		Debug.log(<span class="string">&quot;*子物体：&quot;</span> + child.name);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>
通过索引获取：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Transform firstChild = <span class="keyword">this</span>.Transform.GetChild(<span class="number">0</span>); <span class="comment">//获取所有子节点中的第一个子节点</span></span><br></pre></td></tr></table></figure></div>
通过名称查找子项：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Transform bb = <span class="keyword">this</span>.Transform.Find(<span class="string">&quot;aa/bb&quot;</span>); <span class="comment">//可以直接是名称，二级子级应该写上路径</span></span><br></pre></td></tr></table></figure></div></li>
<li>物体的操作<br>更换gameobject的父级：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.Transform.SetParent(<span class="string">&quot;name_or_path_or_null&quot;</span>); <span class="comment">//可以是名称，也可以是路径，是null时，表示一级节点</span></span><br></pre></td></tr></table></figure></div>
设置active：  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.transform.gameObject.activeSelf) <span class="comment">//作为判断条件</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>.transform.gameObject.SetActive(<span class="literal">false</span>); <span class="comment">//设置为不显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>.transform.gameObject.SetActive(<span class="literal">true</span>); <span class="comment">//设置为显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="2-9-脚本资源使用"><a href="#2-9-脚本资源使用" class="headerlink" title="2.9.脚本资源使用"></a>2.9.脚本资源使用</h3><h4 id="2-9-1单个资源使用"><a href="#2-9-1单个资源使用" class="headerlink" title="2.9.1单个资源使用"></a>2.9.1单个资源使用</h4><ul>
<li>在脚本中，资源对应变量：<br>音频文件：AudioClip<br>纹理贴图：Texture<br>材质：Material</li>
<li>以音频文件的使用为例：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AudioClip chgeAudio; <span class="comment">//定义音频文件</span></span><br><span class="line"><span class="keyword">private</span> AudioSource audioIndex; <span class="comment">//定义音频组件</span></span><br><span class="line">audioIndex = <span class="keyword">this</span>.transform.GetComponent&lt;AudioSource&gt;(); <span class="comment">//获取组件</span></span><br><span class="line">audioIndex.PlayOneShot(chgeAudio); <span class="comment">//使用组件播放音频文件</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-10-定时调用"><a href="#2-10-定时调用" class="headerlink" title="2.10.定时调用"></a>2.10.定时调用</h3><ul>
<li>定时调用Invoke*，即一般所谓的定时器<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.Invoke(<span class="string">&quot;Func&quot;</span>, delay); <span class="comment">//定时delay秒后进行Func函数调用</span></span><br><span class="line"><span class="keyword">this</span>.InvokeRepeating(<span class="string">&quot;Func&quot;</span>, delay, interval); <span class="comment">//每隔interval秒调用一次</span></span><br><span class="line"><span class="keyword">this</span>.IsInvoking(<span class="string">&quot;Func&quot;</span>); <span class="comment">//是否正在调度中，返回bool</span></span><br><span class="line"><span class="keyword">this</span>.CancelInvoke(<span class="string">&quot;Func&quot;</span>); <span class="comment">//取消调用，从调度队列中移除</span></span><br><span class="line"><span class="keyword">this</span>.CancelInvoke(); <span class="comment">//取消当前脚本所有调度</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-11-向量使用"><a href="#2-11-向量使用" class="headerlink" title="2.11.向量使用"></a>2.11.向量使用</h3><p>简单使用  </p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 v = <span class="keyword">new</span> Vector3(x, y, z); <span class="comment">//向量创建</span></span><br><span class="line"><span class="built_in">float</span> v = v.magnitude; <span class="comment">//获取向量模</span></span><br><span class="line">Vector3 v1 = v.normalized; <span class="comment">//标准化向量（模长为1）</span></span><br><span class="line">Vector.Distance(a, b); <span class="comment">//直接计算两个点之间举例</span></span><br></pre></td></tr></table></figure></div>
<p>常用几个向量：<br>Vector3.zero:(0, 0, 0)<br>Vector3.up:(0, 1, 0)<br>Vector3.right:(1, 0, 0)<br>Vector3.forward:(0, 0, 1)<br>向量乘法、点积和叉积：  </p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">b = a * <span class="number">2</span>;</span><br><span class="line">c = Vector3.Dot(a, b); <span class="comment">//点积</span></span><br><span class="line">c = Vector3.Cross(a, b); <span class="comment">//叉积</span></span><br></pre></td></tr></table></figure></div>
<p>可以使用向量作为参数：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Vector3 speed; <span class="comment">//在inspector中将向量速度输入</span></span><br><span class="line"><span class="keyword">this</span>.Transform.Translate(speed * Time.deltaTime, Space.Self); <span class="comment">//直接将向量参数输入</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-12-预制体使用"><a href="#2-12-预制体使用" class="headerlink" title="2.12.预制体使用"></a>2.12.预制体使用</h3><ul>
<li>预制体的生成与使用</li>
<li>预制体的三种编辑方式<br>1.单独编辑：双击预制体<br>2.原位编辑：选择实例Instance，Inspector里面选择open<br>3.覆盖修改：选中Instance，编辑后选中Overri|Apply，应用编辑；Override|Revert，取消编辑</li>
<li>脚本创建预制体实例  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Object.Instantiate(prefab, parent); <span class="comment">//prebfab是预制体，parent是可以设置预制体的生成父节点。返回值为一个GameObject</span></span><br></pre></td></tr></table></figure></div></li>
<li>创建实例后的初始化<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Instance.transform.position = (x, y, z); <span class="comment">//可以使用空节点作为定位，获取空节点位置</span></span><br><span class="line">Instance.transform.eulerAngles = (x, y, z); <span class="comment">//实例的角度</span></span><br></pre></td></tr></table></figure></div></li>
<li>实例的销毁  <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Object.Destroy(Instance, delay); <span class="comment">//delay秒后销毁实例对象。Destroy会在Update之后执行</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="3-物理与特效"><a href="#3-物理与特效" class="headerlink" title="3.物理与特效"></a>3.物理与特效</h2><h3 id="3-1-物理系统"><a href="#3-1-物理系统" class="headerlink" title="3.1.物理系统"></a>3.1.物理系统</h3><ul>
<li>添加刚体组件Rigidbody，添加后，由物理引擎接管物体运动</li>
</ul>
<h3 id="3-2-刚体碰撞"><a href="#3-2-刚体碰撞" class="headerlink" title="3.2.刚体碰撞"></a>3.2.刚体碰撞</h3><ul>
<li>碰撞体Colider，描述了物体的碰撞范围<br>Box Collider：长方碰撞体<br>SphereCollider：球形碰撞体</li>
</ul>
<h3 id="3-3-反弹与摩擦"><a href="#3-3-反弹与摩擦" class="headerlink" title="3.3.反弹与摩擦"></a>3.3.反弹与摩擦</h3><ul>
<li>创建Physic Material</li>
<li>参数：</li>
</ul>
<p>Dynamic Friction：动摩擦系数<br>Static Friction：静摩擦系数<br>Bounciness：反弹系数</p>
<h3 id="3-4-碰撞检测"><a href="#3-4-碰撞检测" class="headerlink" title="3.4.碰撞检测"></a>3.4.碰撞检测</h3><ul>
<li>碰撞<br>条件：两个物体都有碰撞体+至少有个物体有刚体。<br>注意：<br>（1）Unity中碰撞体独立于物体大小，与物体的MeshFilter大小无关。<br>（2）只有碰撞体才能被射线检测到，否则无法被检测。<br>（3）只有刚体才会有受力效果。<br>（4）isKinematic就有点像把刚体关了，但没完全关，因为保留了物理特性如质量，速度等等。</li>
<li>触发<br>条件：产生碰撞的条件(两个物体都有碰撞体+至少有个物体有刚体)+两个物体至少有个有触发器<br>注意：<br>（1）碰撞检测和触发检测不能同时触发，如果是触发检测方法调用就不可能会有碰撞检测方法调用。</li>
</ul>
<h2 id="4-项目中的学习"><a href="#4-项目中的学习" class="headerlink" title="4.项目中的学习"></a>4.项目中的学习</h2><ul>
<li>按键封装<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameInput</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, KeyCode&gt; ButtonLists = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, KeyCode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitCode</span>(<span class="params"><span class="built_in">string</span> type = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;&quot;</span> || type == <span class="string">&quot;button&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AddButton(<span class="string">&quot;Up&quot;</span>, KeyCode.W);</span><br><span class="line">            AddButton(<span class="string">&quot;Down&quot;</span>, KeyCode.S);</span><br><span class="line">            AddButton(<span class="string">&quot;Left&quot;</span>, KeyCode.A);</span><br><span class="line">            AddButton(<span class="string">&quot;Right&quot;</span>, KeyCode.D);</span><br><span class="line">            AddButton(<span class="string">&quot;Fire&quot;</span>, KeyCode.J);</span><br><span class="line">            AddButton(<span class="string">&quot;Jump&quot;</span>, KeyCode.K);</span><br><span class="line">            AddButton(<span class="string">&quot;Skill&quot;</span>, KeyCode.L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddButton</span>(<span class="params"><span class="built_in">string</span> button, KeyCode code</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ButtonLists.ContainsKey(button))</span><br><span class="line">        &#123;</span><br><span class="line">            ButtonLists[button] = code;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ButtonLists.Add(button, code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetButton</span>(<span class="params"><span class="built_in">string</span> button</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ButtonLists.ContainsKey(button))</span><br><span class="line">            <span class="keyword">return</span> Input.GetKey(ButtonLists[button]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetButtonDown</span>(<span class="params"><span class="built_in">string</span> button</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ButtonLists.ContainsKey(button))</span><br><span class="line">            <span class="keyword">return</span> Input.GetKeyDown(ButtonLists[button]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetButtonUp</span>(<span class="params"><span class="built_in">string</span> button</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ButtonLists.ContainsKey(button))</span><br><span class="line">            <span class="keyword">return</span> Input.GetKeyUp(ButtonLists[button]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="附：unity以及rider快捷键"><a href="#附：unity以及rider快捷键" class="headerlink" title="附：unity以及rider快捷键"></a>附：unity以及rider快捷键</h2><h3 id="rider："><a href="#rider：" class="headerlink" title="rider："></a>rider：</h3><p>快速注释：ctrl+K，ctrl+C<br>选中当前灭光标所在单词：ctrl+W<br>多光标：shift+alt+鼠标&#x2F;上下键</p>
<h3 id="unity："><a href="#unity：" class="headerlink" title="unity："></a>unity：</h3><p>可以使视角跟随物体运动：-&gt;Edit-&gt;Lock View to Seleted</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity实现小地图创建</title>
    <url>/Blog/2024/02/08/Unity%E5%AE%9E%E7%8E%B0%E5%B0%8F%E5%9C%B0%E5%9B%BE%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Unity相关</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Particle System</title>
    <url>/Blog/2024/02/08/Unity%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<h1 id="Unity-Particle-System"><a href="#Unity-Particle-System" class="headerlink" title="Unity Particle System"></a>Unity Particle System</h1><h3 id="1-1-粒子系统"><a href="#1-1-粒子系统" class="headerlink" title="1.1.粒子系统"></a>1.1.粒子系统</h3><ul>
<li>添加一个ParticleSystem</li>
<li>预览与运行</li>
<li>模块与参数<br>1个主模块（基础参数）和22个子模块（扩展参数）<br>默认启用3个子模块：</li>
</ul>
<ol>
<li>Emission，发射的频率</li>
<li>Shape，粒子发生器的形状</li>
<li>Render，粒子的显示</li>
</ol>
<h3 id="1-2-粒子本质"><a href="#1-2-粒子本质" class="headerlink" title="1.2.粒子本质"></a>1.2.粒子本质</h3><ul>
<li>粒子是一个个小纸片，而粒子系统就是一个不短创建并且发射出去的粒子发生器</li>
<li>可以使用Render中的render mode进行修改渲染模式：<br>Billbord：广告牌，自动旋转，始终面向相机</li>
</ul>
<h3 id="1-3-贴图"><a href="#1-3-贴图" class="headerlink" title="1.3.贴图"></a>1.3.贴图</h3><ul>
<li>对于贴图material，使用着色器：<br>Shader：Praticles|Standered Unit<br>Render Mode:Additive<br>Color Mode:Multiply<br>Albedo:指定贴图</li>
</ul>
<h3 id="1-4-周期和时长"><a href="#1-4-周期和时长" class="headerlink" title="1.4.周期和时长"></a>1.4.周期和时长</h3><ul>
<li>Duration：周期，粒子系统的工作时长</li>
<li>Looping：循环，粒子系统工作一次&#x2F;循环工作</li>
<li>Prewarm：预热，粒子系统是否先预热一个周期</li>
<li>Strat Lifetime：粒子的生命时长，默认五秒</li>
</ul>
<h3 id="1-5-模拟空间"><a href="#1-5-模拟空间" class="headerlink" title="1.5.模拟空间"></a>1.5.模拟空间</h3><ul>
<li>Simulation Space模块<br>Local，本地空间，粒子会以粒子发生器为中心<br>World，世界空间，粒子使用世界坐标系</li>
</ul>
<h3 id="1-6-发射"><a href="#1-6-发射" class="headerlink" title="1.6.发射"></a>1.6.发射</h3><h4 id="1-6-1-发射方式"><a href="#1-6-1-发射方式" class="headerlink" title="1.6.1.发射方式"></a>1.6.1.发射方式</h4><ul>
<li>Emission：匀速发射<br>Rate over Time:按时间发射（一般用于静止）<br>Rate over Distance：按距离发射（一般用于运动物体）<br>Max Particles：最大存在粒子数</li>
<li>Brusts：爆发式发射<br>Time：爆炸发生时间<br>Count：爆出多少个粒子<br>Cycles&#x2F;Interval：爆炸次数&#x2F;间隔<br>Probability：爆炸的可能概率，0表示不会爆炸</li>
</ul>
<h4 id="1-6-2-发射器形状"><a href="#1-6-2-发射器形状" class="headerlink" title="1.6.2.发射器形状"></a>1.6.2.发射器形状</h4><ul>
<li>Shape模块<br>Cone：锥形<br>Sphere：球形<br>Hemisphere：半球形<br>Box：盒形<br>Circle：圆形<br>Rectangle：长方形</li>
</ul>
<h3 id="1-7-渐变"><a href="#1-7-渐变" class="headerlink" title="1.7.渐变"></a>1.7.渐变</h3><h4 id="1-7-1-颜色渐变"><a href="#1-7-1-颜色渐变" class="headerlink" title="1.7.1.颜色渐变"></a>1.7.1.颜色渐变</h4><ul>
<li>Color over Lifetime模块<br>上面是透明度，下面是颜色，可以在上面设置多个透明度，以达到淡入淡出的效果<br>颜色的最终值 &#x3D; 初始颜色 * Color over Time设置的颜色（RGB分别相乘）</li>
</ul>
<h4 id="1-7-2-大小渐变"><a href="#1-7-2-大小渐变" class="headerlink" title="1.7.2.大小渐变"></a>1.7.2.大小渐变</h4><ul>
<li>Size over Lifetime模块<br>曲线变化：横坐标lifetime，纵坐标size</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/Blog/2024/02/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy  </span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>实现Unity中UI的拖拽</title>
    <url>/Blog/2024/03/15/%E5%AE%9E%E7%8E%B0Unity%E4%B8%ADUI%E7%9A%84%E6%8B%96%E6%8B%BD/</url>
    <content><![CDATA[<h1 id="实现Unity中UI的拖拽"><a href="#实现Unity中UI的拖拽" class="headerlink" title="实现Unity中UI的拖拽"></a>实现Unity中UI的拖拽</h1><ul>
<li>需要将屏幕坐标转换为世界坐标<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UIElements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerControal</span> : <span class="title">MonoBehaviour</span>,<span class="title">IBeginDragHandler</span>,<span class="title">IDragHandler</span>,<span class="title">IEndDragHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isDragging = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector3 offset;</span><br><span class="line">    <span class="keyword">private</span> Vector2 position;</span><br><span class="line">    <span class="keyword">private</span> RectTransform rectTransform;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        rectTransform = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;开始拖拽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 pos;</span><br><span class="line">        RectTransformUtility.ScreenPointToWorldPointInRectangle(rectTransform, eventData.position, eventData.enterEventCamera, <span class="keyword">out</span> pos);</span><br><span class="line">        rectTransform.position = pos;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;结束拖拽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/Blog/2024/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-概论"><a href="#1-概论" class="headerlink" title="1.概论"></a>1.概论</h2><h3 id="1-1-网络、互联网以及因特网"><a href="#1-1-网络、互联网以及因特网" class="headerlink" title="1.1.网络、互联网以及因特网"></a>1.1.网络、互联网以及因特网</h3><ul>
<li>网络由若干个结点和连接这些结点的链路组成</li>
<li>多个网络可以用路由器互连起来，构成一个更大的网络，也就是互联网</li>
<li>因特网就是最大的互联网</li>
</ul>
<h3 id="1-2-因特网组成"><a href="#1-2-因特网组成" class="headerlink" title="1.2.因特网组成"></a>1.2.因特网组成</h3><ul>
<li>边缘部分：由所有连接到网络的主机构成，是用户直接使用的，作为通信和资源共享</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成的，用于向边缘部分提供服务</li>
</ul>
<h3 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3.三种交换方式"></a>1.3.三种交换方式</h3><p>交换：按照某种方式动态分配传输线路的资源  </p>
<ul>
<li>电路交换：电话交换机接通电话线的方式<br>1.建立连接（分配通信资源）<br>2.通话（建立的资源始终被占用）<br>3.释放连接（归还通信资源）</li>
<li>分组交换<br>1.发送方：构造分组，发送分组<br>2.路由器：缓存分组，转发分组<br>3.接收方：接受分组，还原报文</li>
<li>报文交换：已经被分组交换替代</li>
<li>后两者都引起了转发时延，但是都提高了线路利用率，并且可以提供多目标服务</li>
</ul>
<h3 id="1-4-定义和分类"><a href="#1-4-定义和分类" class="headerlink" title="1.4.定义和分类"></a>1.4.定义和分类</h3><ul>
<li>定义：一些互相连接、自治的计算机集合</li>
<li>分类：<br>1.按交换技术分类：电路交换网络、报文交换网络、分组交换网络<br>2.按使用者分类：公用网、专用网<br>3.传输介质：有线网络、无线网络<br>4.覆盖网络：广域网（WAN）、城域网（MAN）、局域网（LAN）、个域网（PAN）<br>5.拓扑结构：总线型网络、星型网络、环形网络、网状型网络</li>
</ul>
<h3 id="1-5-计算机网络性能指标"><a href="#1-5-计算机网络性能指标" class="headerlink" title="1.5.计算机网络性能指标"></a>1.5.计算机网络性能指标</h3><ul>
<li>速率：传输数据的速度</li>
<li>带宽：信号所包含的各种不同频率成分所占据的频率范围；网络的通信线路所能传输数据的能力，也就是单位时间内，从网络的某个点到另一个点所能通过的最高数据率</li>
<li>吞吐量：单位时间内，通过某个网络的数据量。吞吐量受到网络带宽或者额定速率的限制</li>
<li>时延：发送时延（分组长度&#x2F;发送速率）、传播时延（信道长度&#x2F;电磁波在不同介质中的传输速率）、处理时延（无法计算）</li>
<li>时延带宽积：乘以的是传播时延和带宽乘积。也就是第一个比特到终点时，已经发送了的数据量</li>
<li>往返时间（RTT，Round-Trip Time）：双向交互时间</li>
<li>利用率：信道利用率、网络利用率。D0表示空闲时的时延，D表示当前时延，利用率U，则D&#x3D;D0&#x2F;（1-U）</li>
<li>丢包率：传输过程中丢失的分组数量与总分组数量比值。丢包原因：误码或网络拥塞</li>
</ul>
<h3 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6.计算机网络体系结构"></a>1.6.计算机网络体系结构</h3><ul>
<li>OSI模型：<br>物理层、数据链路层、网络层、运输层、会话层、表示层、应用层</li>
<li>TCP&#x2F;IP模型：<br>网络接口层、网际层、运输层、应用层</li>
<li>原理模型：<br>物理层：解决用何种信号传输比特的问题<br>链路层：解决分组在一个网络里面（或者一段链路里面）上传输的问题<br>网络层：解决分组在多个网络上传输（路由）的问题<br>运输层：解决进程之间基于网络的通信问题<br>应用层：解决通过应用进程的交互来实现特定网络应用的问题</li>
</ul>
<h2 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h2><h3 id="2-1-传输方式"><a href="#2-1-传输方式" class="headerlink" title="2.1.传输方式"></a>2.1.传输方式</h3><p>串行传输：数据一个比特一个比特发送<br>并行传输：一次发送多个比特<br>同步：字节同步<br>异步：字节间异步，但是字节中的比特流依然同步<br>单工：只能单向传输<br>半双工：双向不同时（对讲机）<br>全双工：双向且同时（电话）</p>
<h3 id="2-2-编码与调制"><a href="#2-2-编码与调制" class="headerlink" title="2.2.编码与调制"></a>2.2.编码与调制</h3><ul>
<li>码元：在时间域中，用波形表示数字信号时，代表不同数值的离散波形</li>
<li>基带信号分为<strong>数字基带信号</strong>和<strong>模拟基带信号</strong></li>
<li>编码和调制：将基带信号转换到数字信道的过程为编码；将基带信号转换到模拟信道的过程称为调制</li>
</ul>
<h4 id="2-2-1-常用编码方式"><a href="#2-2-1-常用编码方式" class="headerlink" title="2.2.1.常用编码方式"></a>2.2.1.常用编码方式</h4><p>不归零编码：需要额外一个时钟信号<br>归零编码：不需要额外时钟信号，会实现自同步，但是效率低<br>曼切斯特码：跳变表示了时钟以及数据<br>差分曼切斯特码：跳变仅表示时钟，码元开始是否发生变化来表示数据</p>
<h4 id="2-2-2-基本调制方法"><a href="#2-2-2-基本调制方法" class="headerlink" title="2.2.2.基本调制方法"></a>2.2.2.基本调制方法</h4><p>调幅（AM）<br>调频（FM）<br>调相（PM）<br>正交振幅调制（QAM）：通过格雷码使得每一个码元都表示一个比特</p>
<h3 id="2-3-信道极限容量"><a href="#2-3-信道极限容量" class="headerlink" title="2.3.信道极限容量"></a>2.3.信道极限容量</h3><ul>
<li>奈氏准则：为了避免码间串扰，码元的传输速率应该有上限<br>理想低通信道的最高码元速率 &#x3D; 2W Baud &#x3D; 2W 码元&#x2F;秒<br>理想带通信道的最高码元速率 &#x3D; W Baud &#x3D; W 码元&#x2F;秒   </li>
<li>香浓公式<br>极限传输速率C &#x3D; W * log2（1+S&#x2F;N）<br>W为带宽，S为信道平均速率，N为高斯噪声功率，S&#x2F;N为信噪比</li>
<li>数据传输速率 &#x3D; 波特率 * 每个码元携带信息量</li>
</ul>
<h2 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h2><ul>
<li>链路：就是从一个结点到相邻一个结点的一段物理线路，中间没有任何的交换结点</li>
<li>数据链路：是指把实现通信协议的硬件和软件加到链路上，数据链路层以帧为单位传输和处理数据</li>
</ul>
<h3 id="3-1-封装成帧"><a href="#3-1-封装成帧" class="headerlink" title="3.1.封装成帧"></a>3.1.封装成帧</h3><ul>
<li>封装成帧：数据链路层给上层交付的协议数据单元（PDU）添加帧头和帧尾的操作<br>帧头帧尾里面有重要控制信息，作用之一就是帧界定  </li>
<li>透明传输：数据链路层对上层交付的传输数据没有任何限制，好像数据链路层不存在一样<br>这就需要对帧界定进行保护<br>面向字节的物理链路使用字节填充<br>面向比特的物理链路使用比特填充</li>
</ul>
<h3 id="3-2-差错检测"><a href="#3-2-差错检测" class="headerlink" title="3.2.差错检测"></a>3.2.差错检测</h3><ul>
<li>比特差错：比特可能会0变成1，或者1变成0</li>
<li>误码率BER：传输错误的比特占总比特的比例</li>
<li>差错检测码：<br>奇偶校验（只能检测奇数误码）：添加一位奇偶校验位，使得整个数据中，1的个数为奇数或者偶数<br>循环冗余校验（CRC）：双方约定多项式，并且用待发送的数据除以<strong>生成多项式</strong>（使待发数据后面添加0，0个数为生成多项式的最高次），然后将余数作为冗余码（同样与生成多项式最高次相同，不够在前面添加0），添加到数据后面作为校验；接收方就将接收到的数据（连同余数冗余码）除以生成多项式（异或运算），如果余数为0，说明没有误码，否则有误码</li>
</ul>
<h3 id="3-3-可靠传输"><a href="#3-3-可靠传输" class="headerlink" title="3.3.可靠传输"></a>3.3.可靠传输</h3><h4 id="3-3-1-可靠传输基本概念"><a href="#3-3-1-可靠传输基本概念" class="headerlink" title="3.3.1.可靠传输基本概念"></a>3.3.1.可靠传输基本概念</h4><ul>
<li>数据链路层向上提供的服务<br>不可靠传输：如果有误码，就直接将误码帧丢弃<br>可靠传输：想办法实现发送端发送什么，接收端就收到什么<br>一般情况下，有线链路误码率低，只要不可靠传输即可；无线链路误码率高，需要提供可靠传输服务</li>
<li>可靠传输在其他层也可以实现<br>TCP为面向连接的可靠服务、UDP为无连接不可靠服务、IP为无连接不可靠服务</li>
</ul>
<h4 id="3-3-2-可靠传输实现机制"><a href="#3-3-2-可靠传输实现机制" class="headerlink" title="3.3.2.可靠传输实现机制"></a>3.3.2.可靠传输实现机制</h4><ul>
<li>停止-等待协议（SW）<br>发送方发送数据，接收方接受并且检测没有误码之后，发送一个确认信号ACK给到发送方，否则发送一个NAK；发送方发送之后进入等待，接收到ACK之后发送下一个分组，如果是NAK则重新发送上一个分组（因此上一个分组数据缓存始终在发送方，直到确认接收）<br>因为有可能第一次发送就直接丢失，接收方不会发送ACK或者NAK，发送方就会陷入等待，所以加入一个超时计时器，定时为略大于正常往返时间，如果超过重传时间没有收到信号，就重新发送上一个分组，这就叫做<strong>超时重传</strong><br>如果ACK或者NAK有丢失，那么会导致发送方接收不到信号，就会重新发送，而为了可以让接收端判断这是分组重复，所以需要对分组进行序号编号；同理也需要对ACK或者NAK进行编号，确保分别对应分组来确认收到或者否定收到</li>
<li>回退N帧协议（GBN）<br>使用多个发送窗口，使得可以一次发送多个分组。例如使用3个比特给分组编号，则发送窗口尺寸为1&lt;Wt&lt;2^n - 1,接收窗口为1.<br>累计确认：连续收到好几个按序到达且误码的分组后，针对最后一个分组发送确认分组<br>如果发送窗口中第一个分组误码，则后面的也不会接收，因为只有一个接收窗口，需要按序接收。<br>不能一次发送超过2^n - 1个分组，因为这样接收方就不能区分是新帧还是旧帧</li>
<li>选择重传协议（SR）：不再是一个接收窗口，而是Wr &#x3D; Wt个窗口，而1&lt;Wt&lt;2^(n-1)<br>发送窗口或者接收窗口在尺寸内的分组被发送成功或者接收成功后才会继续向后滑动，按序不空缺</li>
</ul>
<h3 id="3-4-点对点协议（PPP）"><a href="#3-4-点对点协议（PPP）" class="headerlink" title="3.4.点对点协议（PPP）"></a>3.4.点对点协议（PPP）</h3><ul>
<li>PPP：数据链路层中建立点对点协议<br>F-A-C-P-Data-FCS-F<br>F：Flag，标志位，通常为7E<br>A：Adress，地址位，通常为FF<br>C：Control，控制位，通常03<br>P：协议位，0021表示为IP数据报；C021表示为LCP分组；8021表示为NCP分组<br>Data：数据<br>FCS：帧检验字段（CRC结果）</li>
<li>透明传输：<br>面向字节：加入在与F重复前添加7D<br>面向比特：在每5个1后面加上一个0</li>
</ul>
<h3 id="3-5-媒体介入控制"><a href="#3-5-媒体介入控制" class="headerlink" title="3.5.媒体介入控制"></a>3.5.媒体介入控制</h3><h4 id="3-5-1-静态划分信道"><a href="#3-5-1-静态划分信道" class="headerlink" title="3.5.1.静态划分信道"></a>3.5.1.静态划分信道</h4><ul>
<li>不太灵活，只用在物理层，不用在数据链路层</li>
<li>复用：通过一条物理线路同时传输多路用户的信号</li>
<li>频分复用（FDM）（包含波形复用（WDM）、时分复用（TDM）、码分复用（CDM）</li>
<li>码分复用（CDM&#x2F;CDMA）<br>通过各用户使用经过特殊挑选的不同码型，允许用户在同样的时间使用同样的频带通信（实际上就是在内容上做出适应）<br>CDMA中每一个比特时间再划分m个短的时间间隔，称为码片（chip），每一个站使用唯一m bit码片序列。如果要表示1，发出m序列；如果要表示0，发出m序列的二进制反码<br>码片挑选原则：<br>1.每个站的码片序列必须不同<br>2.每个站的码片必须相互正交（规格化内积为0）</li>
</ul>
<h4 id="3-5-2-动态接入控制—-随机接入"><a href="#3-5-2-动态接入控制—-随机接入" class="headerlink" title="3.5.2.动态接入控制—-随机接入"></a>3.5.2.动态接入控制—-随机接入</h4><ul>
<li>载波监听多址接入&#x2F;碰撞检测（CSMA&#x2F;CD）：多址接入（MA）就是多个站在一条总线上，竞争使用总线；载波监听（CS）就是发送前，检测总线上是否有其他站点要发送帧；碰撞检测（CD），每一个发送中的帧边发送边检测碰撞<br>争用期（碰撞窗口）：最多经过2t(t为端到端的传播时延)时间检测到本次是否发生碰撞。因此，总线长度越大越容易发生碰撞、主机越多也越不顺利<br>最小帧长：不能太短（导致不能碰撞检测，数据会丢失），以太网64字节（数据很短就补上其他字节，保证原始数据不会丢失）。最小帧长 &#x3D; 争用期 * 数据传播速率<br>最大帧长：不能太长，占用总线太久导致其他站缓存溢出<br>截断二进制指数退避算法：退避时间 &#x3D; 基本退避时间 * 随机数r（r为2的指数）<br>信道利用率：S &#x3D; 发送成功时间&#x2F;发送成功时间+端到端的传播时延，所以发送成功时间应该长一些，端到端距离应该短一些  </li>
<li>载波监听多址接入&#x2F;碰撞避免（CSMA&#x2F;CA）：碰撞避免，采用了数据链路层的SW协议。<br>所有站点必须在持续检测信道空闲后一段时间才开始发送帧，这个帧间间隔为IFS<br>IFS长度取决于要发送的帧类型，高优先级帧IFS短，低优先级帧IFS长。IFS有DIFS（长）和SIFS（短）<br>1.工作原理：源站检测信道空闲，等待一个DIFS然后发送（避免有高优先级发送），发送第一帧到目的站，目的站等待SIFS后（分隔开属于一次对话的各帧，让一个站点可以从发送方式转换到接收方式），发送ACK给回源站；其他站点在这个过程中检测到信道忙，当检测空闲后，等待一个DIFS，然后再来一个退避算法（防止多个站点同时发送数据产生碰撞），接着发送下一帧<br>当站点检测到信道是空闲的，并且所要发送的帧不是在上一帧发送完之后立即发送的，就可以不使用退避算法；否则都要使用退避算法<br>2.CSMA&#x2F;CA的退避算法：退避时间减小到0时，开始发送数据；退避时间还没有到0就检测到信道忙时，将退避时间冻结，等到检测信道空闲的时候，一个DIFS之后才开始继续之前退避时间数值的倒计时。第i次退避，用的是2^i乘以基本退避时间，避免退避时间重复(第6次之后不再增加）。<br>3.CSMA&#x2F;CA的信道预约和虚拟载波监听：<br>信道预约：在帧发送前，一个DIFS后发送RTC（Request To Send），目的站收到后等待SIFS，发送CTS（Clear To Send），源站收到后等待SIFS，发送数据，其他站收到CTS，知道此时不会发送，避免碰撞<br>虚拟载波监听：只需要监听RTS或者CTS或者数据帧任意一个，就可以知道信道被占用时间，可以减少屏蔽站带来的碰撞问题</li>
</ul>
<h3 id="3-6-MAC地址、IP地址和ARP协议"><a href="#3-6-MAC地址、IP地址和ARP协议" class="headerlink" title="3.6.MAC地址、IP地址和ARP协议"></a>3.6.MAC地址、IP地址和ARP协议</h3><ul>
<li>MAC地址用于是以太网的MAC子层所使用的地址（数据链路层）</li>
<li>IP地址是TCP&#x2F;IP体系结构中的网际层所使用的地址（网际层）</li>
<li>ARP协议属于TCP&#x2F;IP体系结构中的网际层，作用是：已知设备的IP地址，通过ARP协议可以通过IP地址获取到设备的MAC地址（网际层）</li>
</ul>
<h4 id="3-6-1-MAC地址"><a href="#3-6-1-MAC地址" class="headerlink" title="3.6.1.MAC地址"></a>3.6.1.MAC地址</h4><ul>
<li>通过点对点通信的数据链路不需要地址，因为不需要判断数据传播对象</li>
<li>在共享信道的局域网上就需要数据链路层地址，MAC（Media Access Control）地址，又称物理地址&#x2F;硬件地址</li>
<li>MAC地址是一个网络适配器在全球的唯一标识，是网络各个接口的唯一标识，而非网络上各个设备的唯一标识</li>
<li>MAC地址：主机发送的每一个帧里面都包含<strong>目的地址</strong>和<strong>源地址</strong><br>IEEE 802局域网的MAC地址格式：<br>1.地址构成：48个比特，每8个比特为1个字节，一共6字节。前三个字节称为<strong>组织唯一标识符OUI</strong>，后三个字节称为<strong>网络接口标识符</strong><br>2.发送顺序：从第一字节到第六字节，从第0比特到第7比特<br>3.单播MAC地址实例：主机B要给主机C发送单播帧，构建帧的时候包含目的地址和源地址，发送后，同一信道的主机A也收到帧，但是发现目的地址与自己的MAC地址不匹配，于是丢弃该帧；主机C收到帧后，发现目的地址与自己的MAC地址相匹配，就接受该帧，并且将该帧交给上层处理<br>4.广播MAC地址实例：构建帧，目的地址为广播地址（全是F），AC接收到后确认是广播地址，知道了是广播帧，于是接受该帧，并且上交上层处理<br>5.多播MAC地址实例：构建帧时，第一个字节的第一个比特如果为1，说明是多播（十六进制就是单数），而其他主机收到帧时，确定是多播帧后，将帧的目的地址与自己的多播组列表进行比对，如果列表中存在改地址，则接受，否则丢弃。</li>
</ul>
<h4 id="3-6-2-IP地址（网络层）"><a href="#3-6-2-IP地址（网络层）" class="headerlink" title="3.6.2.IP地址（网络层）"></a>3.6.2.IP地址（网络层）</h4><ul>
<li>IP地址是因特网上的主机和路由器所使用的地址，用于标识两个部分：<br>网络部分：标识因特网上数以百万的网络<br>主机部分：每一个网络上的不同主机（或者路由器各个接口）</li>
<li>IP地址与MAC地址的区别：<br>1.IP地址属于网络层范畴，MAC地址属于数据链路层范畴<br>2.如果是一个单独的网络，不接入因特网，就不需要IP地址，只需要MAC地址；否则，一定需要MAC地址和IP地址<br>3.数据包发送时，IP地址始终不变（目的主机不变），但是MAC因为链路中的路由器而产生转发现象，MAC地址发生改变。并且前一个主机或者路由器知道下一个的IP地址，但是不知道他们的MAC地址，这就需要ARP协议进行解析，从IP地址获取MAC地址</li>
</ul>
<h4 id="3-6-3-ARP协议（通过IP地址来获取MAC地址）"><a href="#3-6-3-ARP协议（通过IP地址来获取MAC地址）" class="headerlink" title="3.6.3.ARP协议（通过IP地址来获取MAC地址）"></a>3.6.3.ARP协议（通过IP地址来获取MAC地址）</h4><ul>
<li>主机都有一个ARP高速缓存表，里面记录了IP地址和MAC地址的对应关系。里面有动态（通过ARP协议获取，一般生命周期为两分钟）和静态（人工设置）类型。</li>
<li>主机ABC简单实例：<br>1.主机B要发送帧给到主机C，先在自己的ARP高速缓存表里面遍历查找IP，如果有就可以获取到MAC地址；如果没有就发送一个ARP请求报文（广播地址），里面封装了自己的IP地址和MAC地址，并且将目的IP地址写入以获得其MAC地址；<br>2.当A收到该广播地址，发现目的IP地址不是自己，就丢弃该帧，C收到后发现是自己的IP地址，于是将自己的MAC地址以单播MAC地址发送给到B，这也被称为ARP响应报文。<br>3.B将这个IP和MAC对应动态类型存入ARP高速缓存表中。然后B将所要转发的报文发送给C</li>
<li>ARP协议只能用在一段链路或者一个网络上使用，不能跨网络使用</li>
</ul>
<h3 id="3-7-集线器与交换机"><a href="#3-7-集线器与交换机" class="headerlink" title="3.7.集线器与交换机"></a>3.7.集线器与交换机</h3><h4 id="3-7-1-集线器"><a href="#3-7-1-集线器" class="headerlink" title="3.7.1.集线器"></a>3.7.1.集线器</h4><ul>
<li>从以前的总线型以太网，如今演变成了双绞线和集线器HUB的星型以太网</li>
<li>星型以太网实际上还是一个总线网，各站共享总线资源，使用的还是CSMA&#x2F;CD协议</li>
<li>集线器只工作在物理层，它的每个接口仅仅简单转发比特流，不进行碰撞检测</li>
<li>集线器一般具有少量容错能力和网络管理功能</li>
<li>集线器可以在物理层上扩展以太网，也就是将不同的碰撞域集合成更大的碰撞域</li>
</ul>
<h4 id="3-7-2-交换机"><a href="#3-7-2-交换机" class="headerlink" title="3.7.2.交换机"></a>3.7.2.交换机</h4><ul>
<li><p>集线器HUB的单播帧是从主机发送到集线器，然后集线器将单播帧发送给每一个主机；而交换机SWITCH是将单播帧发送给目的主机</p>
</li>
<li><p>以太网交换机通常具有多个接口。每个接口都可以直接与一台主机或者另外一台交换机相连，工作方式为全双工模式</p>
</li>
<li><p>以太网交换机具有并行性，可以同时连通多对接口，使多对主机同时通信，无碰撞（不使用CSMA&#x2F;CD协议）</p>
</li>
<li><p>以太网交换机是一种随插随用的设备，内部的帧交换表是通过自学习算法自动逐渐建立起来的</p>
</li>
<li><p>帧的两种转发方式：<br>1.存储转发<br>2.直接交换：采用基于硬件的交叉矩阵（交换时延小，但是不能检查帧是否出现差错）</p>
</li>
<li><p>集线器和交换机的异同：<br>1.当广播时，两者效果相同<br>2.单播时，集线器会发给所有主机，而交换机通过交换表获取唯一要接收帧的主机并且发送<br>3.多个主机同时向一个主机发送帧时，集线器可能会产生碰撞，导致帧受损地发送到对象主机，而交换机采用存储转发地方式，不会产生碰撞<br>4.集线器扩展是同时扩大广播域和碰撞域，交换机地扩展是扩大广播域而不扩大碰撞域<br>5.集线器扩展是在物理层，而交换机扩展是在数据链路层</p>
</li>
</ul>
<h3 id="3-8-以太网交换机自学习和转发帧流程"><a href="#3-8-以太网交换机自学习和转发帧流程" class="headerlink" title="3.8.以太网交换机自学习和转发帧流程"></a>3.8.以太网交换机自学习和转发帧流程</h3><ul>
<li>以太网交换机工作在数据链路层</li>
<li>接收到帧后，以太网交换机查找自身的帧交换表，找到帧目的地址的MAC地址所对应的接口号，然后通过该接口转发帧。</li>
<li>以太网交换机是一种即插即用的设备，刚刚上电的时候，内部的帧交换表是空的，随着网络中各主机的通信，以太网交换机通过自学习算法自动建立起帧交换表<br>自学习算法和转发帧：</li>
<li>以太网交换机就是最开始为空，然后每一个接口第一次出现的时候都会进行登记MAC地址和交换机的对应关系（不同交换机也是如此，记录那一个MAC地址和对应的接口），某个接口第一次转发都是盲目泛洪，也就是将帧转发给除发帧接口外的所有接口。此后该接口再次出现的时候，就是明确转发了。</li>
<li>每条记录都有有效时间，因为MAC地址和接口的对应关系不是永久性的</li>
<li>泛洪是不论该接口是否已经被知道了，依然会转发到该接口，因为一个接口可能通过集线器连接其他的MAC地址</li>
</ul>
<h3 id="3-9-以太网交换机的生成树协议STP"><a href="#3-9-以太网交换机的生成树协议STP" class="headerlink" title="3.9.以太网交换机的生成树协议STP"></a>3.9.以太网交换机的生成树协议STP</h3><ul>
<li>当交换机相连的时候，如果链路出现故障，那么容易导致交换机之间无法正常通信，成为封闭的小型网络<br>1.添加冗余链路来增加交换机可靠性<br>但是冗余链路随之带来问题——<strong>网络环路</strong>：<br>广播风暴、主机收到重复广播帧、交换机的帧交换表震荡（漂移）<br>2.以太网交换机使用生成树协议STP（Spanning Tree Protocol），可以使得保证网络可靠性，并且避免网络环路带来的各种问题<br>设置了三种接口状态，正常、堵塞、故障<br>不论交换机之间如何物理连接，生成树总能自动计算并且构建一个逻辑上没有环路的网络，其拓扑结构一定是树型的<br>最终生成的树型逻辑拓扑必须要保证连通整个网络<br>首次连接或者网络物理拓扑发生变化时，就重新进行生成树计算</li>
</ul>
<h3 id="3-10-虚拟局域网VLAN"><a href="#3-10-虚拟局域网VLAN" class="headerlink" title="3.10.虚拟局域网VLAN"></a>3.10.虚拟局域网VLAN</h3><ul>
<li>交换式以太网扩大后，形成一个巨大的广播域，但是同时也导致一些问题：<br>广播风暴（ARP协议请求报文时）、难以管理和维护、潜在安全问题  </li>
<li>分割广播域的方法：<br>1.使用路由器（路由器默认情况下不对广播数据转发），但是路由器成本较高<br>2.<strong>虚拟局域网VLAN</strong>（Virtual Local Area Network）：将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组有着共同的需求</li>
</ul>
<h4 id="3-10-1-虚拟局域网VLAN"><a href="#3-10-1-虚拟局域网VLAN" class="headerlink" title="3.10.1.虚拟局域网VLAN"></a>3.10.1.虚拟局域网VLAN</h4><ul>
<li>VLAN在交换机上实现的  </li>
<li>VLAN实现需要交换机实现的功能：<br>1.IEEE 802.1Q帧：<br>对以太网MAC帧进行扩展，添加4字节的VLAN标记，其中的最后12比特为VLAN标识符VID，唯一标志了以太网属于哪个VLAN<br>802。1Q帧是由交换机处理的，而不是用户主机，进行“打标签”和“去标签”操作<br>2.交换机的端口类型  </li>
<li>Access端口：用于在交换机和主机之间进行通信连接<br>Access端口只能属于一个VLAN，端口的PVID和端口所属VID相同<br>发送方法：一般只接受未打标签的普通以太网MAC帧，然后根据接受该帧的PVID给帧打标签；<br>转发方法：如果VID和端口PVID相同，就去标签转发，否则就不转发</li>
<li>Trunk端口：用于在交换机和交换机或者交换机和路由器之间进行通信连接<br>Trunk可以属于多个VLAN，用户可以手动设置Trunk端口的PVID值，默认情况下为1<br>发送方法：VID等于PVID的帧，去标签再转发；否则直接转发（确保这一个端口被集线器连接的其他主机能够收到帧)<br>接收方法：未打标签的帧，进行打标签；接受已经打标签的帧</li>
<li>Hybrid端口：可以结合Access和Trunk的功能<br>发送方法和Trunk不同：有一个去标签表，如果要发送的帧存在于去标签表里，则去标签发送；否则直接发送<br>接收方法：同Trunk方法</li>
</ul>
<h2 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h2><ul>
<li>主要任务：实现网络互联，进而实现数据包在不同网络之间的传输</li>
<li>主要研究问题：<br>1.向运输层提供什么服务（可靠还是不可靠）<br>2.寻址问题<br>3.路由选择问题</li>
</ul>
<h3 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1.网络层提供的两种服务"></a>4.1.网络层提供的两种服务</h3><ul>
<li>面向连接的虚电路服务<br>可靠通信由网络保证<br>必须建立网络层连接—虚电路VC（Virtual Circuit）<br>通信双方需要沿着VC进行数据传输<br>目的主机地址只会在连接建立的阶段使用，此后分组都只需要带上一条虚电路的编号即可<br>如果再加上可靠传输的网络协议，那么就可以使分组最终正确到达接收方（无差错按序到达，不丢失，不重复）<br>通信结束后要将VC释放  </li>
<li>无连接的数据报服务<br>可靠通信由用户主机确保<br>不需要建立网络层连接<br>每一个分组可以走不同路径<br>每个分组首部必须携带目的主机的完整地址<br>分组传输很可能误码、丢失、重复和失序<br>网络不提供可靠传输，所以路由器可以制作简单，节约成本</li>
</ul>
<p>因特网采用这种设计思想，将复杂的网络处理功能置于因特网边缘（用户主机和其内部的运输层），将相对简单的尽最大努力的分组交付功能置于因特网核心</p>
<h3 id="4-2-IPV4地址"><a href="#4-2-IPV4地址" class="headerlink" title="4.2.IPV4地址"></a>4.2.IPV4地址</h3><ul>
<li>IPV4地址就是给每一个主机的每一个接口分配一个在全世界范围的唯一32比特标识符</li>
<li>IPV4经历了：分类编址—划分子网—无分类编址</li>
<li>IPV4采用点分十进制进行表示，32比特，每8位为一个字节，每个字节转化为十进制</li>
</ul>
<h4 id="4-2-1-分类编址"><a href="#4-2-1-分类编址" class="headerlink" title="4.2.1.分类编址"></a>4.2.1.分类编址</h4><ul>
<li>A类0开头，B类10开头，C类110开头，D类1110开头，E类1111开头（保留为今后使用）</li>
<li>其中只有ABC可以给用户使用，D为多播地址</li>
<li>主机号全0为网络地址，主机号全1为广播地址，都不能分给主机或者路由器</li>
</ul>
<h4 id="4-2-2-子网划分"><a href="#4-2-2-子网划分" class="headerlink" title="4.2.2.子网划分"></a>4.2.2.子网划分</h4><ul>
<li>为了避免过多浪费使用子网划分</li>
<li>将主机号的比特网作为子网划分，子网掩码用连续的1作为网络号和子网号，用连续的0作为主机号</li>
<li>将子网掩码和IPV4进行逻辑与运算就可以得到所在子网地址</li>
</ul>
<h4 id="4-2-3-无分类编址"><a href="#4-2-3-无分类编址" class="headerlink" title="4.2.3.无分类编址"></a>4.2.3.无分类编址</h4><ul>
<li>消除了网络分类，子网掩码等</li>
<li>使用CIDR记法，也就是斜线记法，在IPV4后面加上斜线，斜线后面表示用多少位作为网络前缀所占比特数，例如128.14.35.7&#x2F;20</li>
<li>路由聚合：将网络从路由器转发给另外一个路由器，路由聚合就是将所有网络的前缀相同部分集合，然后CIDR就是取相同前缀部分的位数</li>
</ul>
<h4 id="4-2-4-IPV4地址的应用规划"><a href="#4-2-4-IPV4地址的应用规划" class="headerlink" title="4.2.4.IPV4地址的应用规划"></a>4.2.4.IPV4地址的应用规划</h4><ul>
<li>定长的子网掩码FLSM（Fixed Length Subnet Mask）<br>使用一个子网掩码来划分子网<br>每个子网所分配的IP地址数量相同，造成IP地址的浪费</li>
<li>变长的子网掩码VLSM（Variable Length Subnet Mask）<br>使用不同的子网掩码来划分子网<br>每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费</li>
</ul>
<h3 id="4-3-IP数据报的发送和转发过程"><a href="#4-3-IP数据报的发送和转发过程" class="headerlink" title="4.3.IP数据报的发送和转发过程"></a>4.3.IP数据报的发送和转发过程</h3><ul>
<li>主机发送IP数据报<br>首先判断是直接交付还是间接交付（需要通过路由器转发），将发送主机的网络地址和子网掩码相与，然后将目的地址的网络地址和子网掩码相与，两者进行比较。如果相同说明在一个网络里，可以直接交付；否则需要路由器间接交付。</li>
<li>路由器转发IP数据报<br>路由器的每个接口有地址号，将每个接口地址号作为该网络的默认网关<br>路由器检查数据包首部是否出错，如果错了，丢弃分组并且通告源主机；没有错就继续转发<br>根据IP数据报的目的地址在路由表中查找匹配条目，找到了就转发给下一跳；否则丢弃IP数据报并且通告源主机</li>
</ul>
<h3 id="4-4-静态路由配置以及可能产生的路由环路问题"><a href="#4-4-静态路由配置以及可能产生的路由环路问题" class="headerlink" title="4.4.静态路由配置以及可能产生的路由环路问题"></a>4.4.静态路由配置以及可能产生的路由环路问题</h3><ul>
<li>静态路由配置也就是使用路由器命令对路由器进行人工配置路由表<br>配置方式简单，开销小，但是不能及时适应网络状态（流量、拓扑）的变化，因此只会在小规模网络里面使用</li>
<li>路由条目的类型：直连网络、静态路由（人工配置）、动态路由（路由选择协议）</li>
<li>特殊的静态路由条目：<br>默认路由：0.0.0.0，地址掩码为0.0.0.0<br>特定主机路由：目的网络为特定主机的IP地址，地址掩码为255.255.255.255<br>黑洞路由：下一跳为null0</li>
<li>使用静态路由配置可能出现以下导致产生<strong>路由环路</strong>的错误：<br>1.配置错误：<br>为了防止数据报在路由器环路中永久兜圈，在IP首部添加了生存时间TTL字段，IP数据报进入路由器之后就会将TTL减一，如果减一后不等于0，就可以继续转发<br>2.聚合了不存在的网络：<br>直接聚合有可能将不存在的聚合子网包含进路由器，所以可以在路由表里面添加黑洞路由，将不存在的网络地址的下一跳设置为null0，这样IP数据报进去就不再转发<br>3.网络故障：<br>某一个网络故障，同样将这个网络设置为黑洞路由</li>
</ul>
<h3 id="4-5-路由选择"><a href="#4-5-路由选择" class="headerlink" title="4.5.路由选择"></a>4.5.路由选择</h3><ul>
<li>静态路由选择：<br>由人工配置的网络路由、默认路由、特定主机路由和黑洞路由都是静态路由<br>人工配置方式简单，开销小，但是不能及时适应网络状态变化<br>适用于小规模网络</li>
<li>动态路由选择：<br>路由器通过路由选择协议<strong>自动获取路由信息</strong><br>比较复杂，开销大，可以适应网络状态变化<br>适用于大规模网络</li>
</ul>
<h3 id="4-6-路由选择协议"><a href="#4-6-路由选择协议" class="headerlink" title="4.6.路由选择协议"></a>4.6.路由选择协议</h3><ul>
<li>因特网的主要三个特点：<br>1.自适应：动态路由选择，可以自适应网络状态变化<br>2.分布式：路由器之间交换路由信息<br>3.分层次：将整个因特网划分为许多较小的自治系统AS（Autonomous System），有内部网关协议IGP（IRP），外部网关协议EGP（ERP）  </li>
<li>路由选择协议：<br>1.内部网关协议IGP：<br>路由信息协议RIP<br>内部网关路由协议IGRP<br>增强型内部网关路由协议EIGRP<br>开放式最短路径优先OSPF<br>中间系统到中间系统IS-IS<br>2.外部网关协议EGP：<br>边界网关协议BGP</li>
<li>路由器基本结构：路由选择部分和分组转发部分，其中分组转发部分又分为输入、输出、交换结构。分组转发部分依次有物理层、数据链路层、网络层的数据处理<br>路由报文携带的是网络地址和下一跳的信息，就会从分组转发部分传递给路由选择部分<br>路由表需要对网络拓扑变化的计算最优化</li>
</ul>
<h4 id="4-6-1-路由信息协议RIP"><a href="#4-6-1-路由信息协议RIP" class="headerlink" title="4.6.1.路由信息协议RIP"></a>4.6.1.路由信息协议RIP</h4><ul>
<li>RIP要求自治系统AS内的每一个路由器都要维护它到AS中的每一个网络的距离记录。这一组距离叫做<strong>距离向量D-V（Distance-Vector）</strong></li>
<li>RIP使用跳数来衡量一个到达目的网络的距离<br>路由器到直连网络距离为一<br>路由器到非直连网络的距离为经过的路由器数+1<br>允许一条路径最多包含15个路由器，也就是路径不能大于等于16。因此只适合小型网络</li>
<li>RIP认为好的路由就是通过路由器数量最少的路由，不管它们分别的带宽为多少</li>
<li>对于到达目的网络有多条等距离的路由时，可以进行等价负载均衡</li>
<li>RIP的三个要点：<br>1.和相邻的路由器交换信息<br>2.交换的信息为各自的路由表<br>3.周期性交换信息</li>
<li>RIP路由条目更新规则：<br>发现了新的目的网络，添加；<br>到达目的网络，同样下一跳，最新消息，更新；<br>到达目的网络，不同下一跳，新路由优势，更新，新路由劣势，不更新，新路由等距离，进行等价负载均衡</li>
<li>RIP存在“坏消息传得慢”问题：路由R1到网络N1发生故障，R1就将N1设置为跳数16，但是R2将先前的路由表发送过来给R1，导致R1更新错误的路由信息。两者一起递增跳数，直到最后两者都知道N1链路发生故障<br>解决办法：<br>1.限制最大路径为15<br>2.采用触发更新，而不是周期性更新<br>3.让路由器记录收到特定路由信息的接口，而不让同一路由信息再通过此接口反方向传送（也就是<strong>水平分割</strong>）</li>
</ul>
<h4 id="4-6-2-开放最短路径优先OSPF（Open-Shortest-Path-First）"><a href="#4-6-2-开放最短路径优先OSPF（Open-Shortest-Path-First）" class="headerlink" title="4.6.2.开放最短路径优先OSPF（Open Shortest Path First）"></a>4.6.2.开放最短路径优先OSPF（Open Shortest Path First）</h4><ul>
<li>OSPF是基于链路状态的，会考虑链路的带宽</li>
<li>OSPF利用SPF算法，计算路由，算法上保证了不会产生路由环路</li>
<li>OSPF不会限制网络规模，更新效率高，收敛速率快</li>
<li>OSPF的五种分组：<br>1.问候（Hello）分组：发现和维护邻居路由器可达性<br>2.数据库描述（Database Description）分组：向邻居路由给出自己链路状态数据库中所有链路状态项目的摘要信息<br>3.链路状态请求（Link State Request）分组：向邻居路由器请求发送某些链路状态项目的详细信息<br>4.链路状态更新（Link State Update）分组：使用该分组对其链路状态进行洪泛发送，也就是用洪泛法对全网更新链路状态<br>5.链路状态确认（Link State Acknowledgment）分组：这是对链路更新分组的确认分组</li>
</ul>
<h4 id="4-6-3-边界网关协议BGP"><a href="#4-6-3-边界网关协议BGP" class="headerlink" title="4.6.3.边界网关协议BGP"></a>4.6.3.边界网关协议BGP</h4><ul>
<li>边界网关考虑的就不仅是代价，而是有着经济、安全等等</li>
<li>配置BGP时，每个系统管理员需要将至少一个路由器设置为</li>
<li>BGP-4的报文类型：<br>1.OPEN报文：用来与相邻另一个BGP发言人建立关系，使通信初始化<br>2.UPDATE报文：用来通告某一路由的信息，以及列出要撤销的多条路由<br>3.KEEPALIVE报文：用来周期性证实邻站连通性<br>4.NOTIFICATION报文：用来发送检测到的差错</li>
<li>BGP报文被封装在TCP报文中传输，RIP用UDP，OSPF用IP</li>
</ul>
<h3 id="4-7-IPV4的数据报格式"><a href="#4-7-IPV4的数据报格式" class="headerlink" title="4.7.IPV4的数据报格式"></a>4.7.IPV4的数据报格式</h3><ul>
<li>固定部分（每一个IP数据报必须包含的部分）和可变部分（可选字段加上填充字段）</li>
<li>MTU，允许的最大字节数</li>
<li>固定部分有20字节<br>1.版本字段，4比特，表示IP协议的版本<br>2.首部长度字段，4比特，表示IP数据报首部长度<br>3.区分服务字段：8比特，用于获得更好服务<br>4.总长度字段：16比特，表示IP数据报总长度（首部+数据载荷）<br>5.标识字段：16比特，属于同一个数据报的各分片数据报应该有相同的标识字段<br>6.标志字段：3比特，各比特具有含义。DF：1表示不允许分片，0表示允许；MF：1表示后面还有分片，0表示这是最后一个分片；保留位：始终为0<br>7.片偏移：占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。片偏移以8字节为单位，必须为整数<br>8.生存时间字段（TTL）：8比特，路由器转发时，将IP数据报首部的该字段减去IP数据报在本路由器上所花费的时间，不为0就转发，否则就丢弃。<br>9.协议字段：8比特，指明IP数据报文的数据部分是何种协议单元<br>10.首部检验和字段：16比特，用来检测首部在传输过程中是否出现差错，比CRC简单，IP数据报每经过一个路由器，就要重新计算首部检验和，因为某些字段的值会发生改变。<br>11.源IP地址和目的地址字段：共64比特<br>标识、标志、片段偏移：共同用于IP数据报分片</li>
<li>可变部分40个字节<br>1.可选字段，1到40字节不等，用于排错、测量及安全等措施。增加了IP数据报的功能，也使IP首部长度成为可变的。增大了开销<br>2.填充字段：全为0，用于确保首部长度为4字节的整数倍</li>
</ul>
<h3 id="4-8-网际控制报文协议ICMP"><a href="#4-8-网际控制报文协议ICMP" class="headerlink" title="4.8.网际控制报文协议ICMP"></a>4.8.网际控制报文协议ICMP</h3><ul>
<li>为了更高效转发IP数据报和提高交付成功的机会，在网际层使用网际控制报文协议ICMP（Internet Control Message Protocol）</li>
<li>主机或者路由器使用ICMP发送差错报告报文和询问报文</li>
<li>ICMP报文被封装在IP数据报中发送</li>
<li>五种ICMP差错报告报文：<br>1.终点不可达：路由或者主机不能交付数据时，就向源点发送ICMP终点不可达报文<br>2.源点抑制：路由器或者主机因为拥塞而丢弃数据报文时，就向源点发送源点抑制报文，使得源点发送报文数据速度放慢<br>3.时间超过：路由器收到一个数据后，如果这个IP目的地址不是自己，就要将TTL减一，不为0就转发出去；为0就丢弃并且发送时间超过报文给到源点<br>4.参数问题：当路由器检测首部出错时，丢弃数据并且发送参数问题报文给到源点<br>5.改变路由（重定向）：路由器把改变路由报文发送给源点，让源点主机知道可以下次发送给其他更近的路由</li>
<li>不发送ICMP差错报文的情况：<br>1.对ICMP差错报告报文不发送ICMP报告报文<br>2.对第一个分片后的其他分片不会再次发送ICMP报告报文<br>3.对具有多播地址的数据报不会发送ICMP报告报文<br>4.对具有特殊地址的数据报不会发送ICMP报告报文（如：127.0.0.0，0.0.0.0）</li>
<li>ICMP询问报文：<br>1.回送请求和回答：用来测试目的站是否可达及了解有关状态<br>2.时间戳请求和回答：请求某个特定主机或路由器回答当前时间日期。用来进行时钟同步和测量时间</li>
<li>ICMP实际应用举例：<br>1.分组网间探测PING（Packet InterNet Groper):<br>用来测试主机或者路由器的连通性<br>应用层直接使用网际层的ICMP（没有通过运输层的TCP和UDP）<br>使用ICMP回送请求和回答报文<br>PING命令：ping 网站<br>2.跟踪路由<br>用来测试数据报从源主机到目的主机要经过哪些路由器<br>Windows：tracert命令直接应用层使用网际层ICMP，使用ICMP回送请求和回答报文以及差错报告报文</li>
</ul>
<h3 id="4-9-虚拟专用网VPN和网络地址转换NAT"><a href="#4-9-虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="4.9.虚拟专用网VPN和网络地址转换NAT"></a>4.9.虚拟专用网VPN和网络地址转换NAT</h3><ul>
<li>虚拟专用网VPN（Virtual Private Network）：利用公用的因特网，作为本机构各个专用网之间的通信载体<br>由于IPV4地址紧缺，所以一个主机所分配的地址是本机构可以自由分配的专用地址，而不是需要申请的、在因特网上使用的公有地址。<br>同一个机构的主机A要发送数据给主机B，将数据报封装成内部数据报，对数据报进行加密。主机B的路由器收到后解密，得到私有地址，发送给到B。  </li>
<li>网络地址转换NAT（Network Adress Translation）：使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源<br>NAT软件拥有NAT路由器（存在一个NAT转换表），有至少一个全球IP地址，可以给专用网络用户使用。有多少个全球IP地址，就能同时给多少内网主机使用。</li>
</ul>
<h2 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5.运输层"></a>5.运输层</h2><ul>
<li>前面物理层、数据链路层、网络层都是实现了主机到主机的通信</li>
<li>但是实际上计算机网络中进行通信的实体是位于通信两端主机的进程，运输层就是实现端到端的通信。</li>
<li>运输层对上层透明，运输层主要有两种协议：面向连接的TCP和无连接的UDP</li>
</ul>
<h3 id="5-1-运输层端口号、复用和分用"><a href="#5-1-运输层端口号、复用和分用" class="headerlink" title="5.1.运输层端口号、复用和分用"></a>5.1.运输层端口号、复用和分用</h3><ul>
<li><p>运行在计算机上的进程使用进程标识符PID标志</p>
</li>
<li><p>TCP&#x2F;IP体系运输层使用端口号区分应用层不同应用进程<br>端口号使用16比特表示，取值范围是0~65535<br>三种端口号：<br>1.熟知端口号：0-1023，IANA把这些端口号指派给了TCP&#x2F;IP一些重要协议。<br>2.登记端口号：1024-49151，为没有熟知端口号的应用进程使用<br>3.短暂端口号：49152-65535，留给客户进程短暂使用</p>
</li>
<li><p>端口号具有本地意义，用于标识计算机应用层的各进程。不同主机相同端口号没有联系</p>
</li>
<li><p>发送方的复用和接收方的分用<br>使用UDP&#x2F;TCP&#x2F;IP协议进行封装，称之为UDP&#x2F;TCP&#x2F;IP复用；用UDP&#x2F;TCP&#x2F;IP协议将他们分别上交给上层处理，叫做UDP&#x2F;TCP&#x2F;IP分用<br>TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号：<br>UDP：<br>RIP-520，DNS-53，TFTP-69，SNMP-161，DHCP-67&#x2F;68<br>TCP：<br>SMTP-25，FTP-21&#x2F;20，BGP-179，HTTP-80，HTTPS-443</p>
</li>
</ul>
<h3 id="5-2-UDP（User-Datagram-Protocol）和TCP（Transmission-Control-Protocol）的对比"><a href="#5-2-UDP（User-Datagram-Protocol）和TCP（Transmission-Control-Protocol）的对比" class="headerlink" title="5.2.UDP（User Datagram Protocol）和TCP（Transmission Control Protocol）的对比"></a>5.2.UDP（User Datagram Protocol）和TCP（Transmission Control Protocol）的对比</h3><ul>
<li>UDP随时可以发送信息，属于无连接；TCP需要三次握手、四次挥手，属于面向连接</li>
<li>UDP支持单播、多播、广播；TCP仅支持单播</li>
<li>UDP对数据块直接添加UDP首部，属于面向应用报文；TCP将数据块拆分，属于面向字节流</li>
<li>UDP向上层提供无连接不可靠传输服务；TCP向上层提供连接可靠传输服务</li>
<li>UDP数据报首部仅有8字节，包含源端口、目的端口、长度和检验和；TCP数据报首部最小为20字节，最大为60字节</li>
</ul>
<h3 id="5-3-TCP的流量控制"><a href="#5-3-TCP的流量控制" class="headerlink" title="5.3.TCP的流量控制"></a>5.3.TCP的流量控制</h3><ul>
<li>让发送方的发送速率不要太快，让接收方来得及接收，否则数据会丢失</li>
<li>TCP使用滑动窗口实现流量控制</li>
<li>TCP接收方有接收窗口，发送方有发送窗口，接收窗口在对发送方发送的数据接收后，会发送一个确认段，里面包含ACK &#x3D; 1表示这是确认段，ack &#x3D; 201，表示此前数据都已经接收成功，rwnd &#x3D; 200，表示接收窗口为200.发送放就会将发送窗口调整为这个大小。如果数据发送后，就会启动计时器，到时间重新发送。如果接收方的确认段丢失，发送方也有相应的计时器，计时器结束后会发送一个1字节的零窗口探测报文（对此同样也有计时器）。接收方接收窗口即便是0，也必须接收零窗口探测报文以及一些紧急报文</li>
</ul>
<h3 id="5-4-TCP的拥塞控制"><a href="#5-4-TCP的拥塞控制" class="headerlink" title="5.4.TCP的拥塞控制"></a>5.4.TCP的拥塞控制</h3><ul>
<li><strong>拥塞</strong>：对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏（带宽、交换结点中的缓存、处理机）。如果不处理拥塞，那么网络的吞吐量容易随着输入负载的增大而降低</li>
<li>发送方维护叫做<strong>拥塞窗口cwnd</strong>，取值取决于网络拥塞程度，动态变化；发送方将<strong>拥塞窗口</strong>作为<strong>发送窗口swnd</strong>，即swnd &#x3D; cwnd；还维护一个<strong>慢开始门限ssthresh</strong>，通过cwnd和ssthresh的值进行比对来判断哪个算法</li>
<li>TCP四种算法：<br>慢开始：发送字节数以指数型增长<br>拥塞避免：发送字节数以正比型增长<br>快重传：如果有丢失，三个重复确认字节后，立马进行重传<br>快恢复：超时重传，则从当前最大cwnd&#x2F;2开始，以拥塞避免算法增加  </li>
<li>原本超时重传，应该是将cwnd重新减小为1，ssthresh设置为刚才最大cwnd&#x2F;2，重新开始慢开始+拥塞避免算法（也就是TCP拥塞控制算法TCP Tahoe）。但是快重传+快恢复（TCP Reno）使得TCP性能改进</li>
</ul>
<h3 id="5-5-TCP可靠传输的实现"><a href="#5-5-TCP可靠传输的实现" class="headerlink" title="5.5.TCP可靠传输的实现"></a>5.5.TCP可靠传输的实现</h3><ul>
<li>TCP基于以字节为单位的滑动窗口来实现可靠传输。<br>发送方在未收到接收方的确认时，可将发送窗口内还未发送的数据全部发送出去;<br>接收方只接收序号落入发送窗口内的数据;</li>
<li>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。<br>网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。<br>发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸  </li>
<li>对于不按序到达的数据应如何处理，TCP并无明确规定<br>如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。<br>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。  </li>
<li>TCP要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上<br>接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认[RFC 1122]。<br>捎带确认实际上井不经常发生，因为大多数应用程序很少同时在两个方向上发送数据  </li>
<li>TCP的通信是全双工通信。通信中的每一方都在发送和接收报文段，因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗只时，一定要弄清楚是哪一方的窗口。</li>
</ul>
<h3 id="5-6-TCP运输连接管理"><a href="#5-6-TCP运输连接管理" class="headerlink" title="5.6.TCP运输连接管理"></a>5.6.TCP运输连接管理</h3><ul>
<li>TCP运输连接管理包含三个阶段：<br>建立TCP连接 - 数据传输 - 释放TCP连接</li>
</ul>
<h4 id="5-6-1-TCP建立连接"><a href="#5-6-1-TCP建立连接" class="headerlink" title="5.6.1.TCP建立连接"></a>5.6.1.TCP建立连接</h4><ul>
<li>三个TCP解决的问题：<br>1.使TCP通信双方确知对方存在<br>2.使TCP通信双方协商一些参数<br>3.使TCP通信双方能够对运输实体资源进行分配</li>
<li><strong>三报文握手</strong>过程：<br>初始阶段，TCP服务器进程首先创建传输控制块（存储一些TCP连接中的重要信息），之后就开始准备接收TCP客户进程的连接请求，进入<strong>监听状态</strong> 。TCP客户端发送TCP连接请求，请求报文首部中的同步位SYN被设置为1，表示这是TCP连接请求报文，序号seq被设置为x，作为TCP客户进程所选择的初始序号，此时TCP客户进程进入<strong>同步已发送状态</strong> 。服务器接收到后，发送针对TCP连接请求的确认，其中同步位SYN &#x3D; 1，确认位ACK &#x3D; 1，表明这是一个TCP请求确认报文段，序号字段seq&#x3D;y，确认号字段ack &#x3D; x+1，这是对TCP客户进程所选择的初始序号的确认，此时服务器进入<strong>同步已接收状态</strong> 。客户进程收到TCP确认报文段后，还要发送一个普通的TCP确认报文段，确认位ACK&#x3D;1，表明这是个普通的TCP确认报文段，序号字段seq&#x3D;x+1，确认号字段ack&#x3D;y+1，此时客户进程进入<strong>连接已建立状态</strong> 。服务器进程接收到也进入<strong>连接已建立状态</strong>。</li>
<li>SYN &#x3D; 1的报文段不能携带数据，消耗一个序号；TCP普通确认报文段可以携带数据，但是如果不携带数据，则不消耗序号</li>
<li>三次握手而不是两次握手的原因：<br>假设是两次握手，如果第一次发送的TCP连接请求报文延误送达，第二次发送顺利到达，数据传输完成并且结束TCP连接后，客户进程进入关闭状态，而服务进程进入关闭状态下收到延误报文，就会误认为一个新的TCP连接请求，于是发送针对连接请求的确认报文段，客户进程关闭状态下不做出回应，而服务进程就进入等待状态，浪费资源。</li>
</ul>
<h4 id="5-6-2-TCP的连接释放"><a href="#5-6-2-TCP的连接释放" class="headerlink" title="5.6.2.TCP的连接释放"></a>5.6.2.TCP的连接释放</h4><ul>
<li>TCP通信双方都可以关闭连接</li>
<li>TCP<strong>四报文挥手</strong>：<br>客户进程发送TCP连接释放报文段，进入<strong>终止等待1状态</strong> ，报文首部中的终止位FIN&#x3D;1，表明这是一个TCP连接释放报文段，确认位ACK&#x3D;1，seq&#x3D;u,等于前面发送过的序号值加一，ack&#x3D;v,等于前面接收过的序号值加一。服务进程接收到后发送一个普通TCP确认报文段，进入<strong>关闭等待状态</strong> ，确认位ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1。此时TCP连接属于半关闭状态，客户进程已经没有数据要发送了。但是如果服务进程还有数据要发送，则客户进程依然接收。TCK客户进程接收到普通TCP确认报文段之后，进入<strong>终止等待2状态</strong> ，等待服务进程将所有数据发送。服务进程发送完毕之后，向客户进程发送TCP连接释放报文段，并且服务进程进入<strong>最后确认状态</strong> ，终止位FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w(此前所发送过的数据序号+1）,ack&#x3D;u+1。客户进程接收到后，发送一个普通TCP连接报文段，进入<strong>时间等待状态</strong> ，确认位ACK&#x3D;1，序号seq&#x3D;u+1，确认号ack&#x3D;w+1。服务进程收到后，进入<strong>关闭状态</strong> ，而客户进程需要等待2MSL，MSL为2分钟，然后进入<strong>关闭状态</strong>。</li>
<li>保活计时器<br>服务进程每次收到客户进程的数据，就重新设置并启动保活计时器（2h）<br>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接</li>
</ul>
<h3 id="5-7-TCP报文段的首部格式"><a href="#5-7-TCP报文段的首部格式" class="headerlink" title="5.7.TCP报文段的首部格式"></a>5.7.TCP报文段的首部格式</h3><ul>
<li>TCP采用面向字节流的方式实现可靠传输</li>
<li>一个TCP报文段由首部+数据载荷构成。TCP全部功能体现在它的首部各字段作用</li>
<li>首部格式：固定首部（20字节）+扩展首部（最大40字节）<br>1.源端口：16比特，写入源端口号，用来标识发送该TCP应用报文段的应用进程<br>2.目的端口：16比特，写入目的端口号，用来标识接收该TCP应用报文段的应用进程<br>3.序号（seq）：32比特，序号增加到最后一个后，重新回到0。用来指出本TCP报文数据载荷的第一个字节的序号<br>4.确认号（ack）：32比特，序号增加到最后一个后，重新回到0。用来表示期望收到对方下一个TCP报文段的数据载荷第一个字节的序号，同时也是对此前所有数据的确认<br>5.确认标志位（ACK）：ACK&#x3D;1，确认号才有作用，ACK&#x3D;0时，确认号无效。所以TCP协议规定，所有建立连接后的TCP数据报文段都要把ACK&#x3D;1<br>6.数据偏移：4比特，以4字节为单位。用来指出TCP数据载荷部分的起始位置距离TCP报文段的起始处有多远。实际上就是表示TCP报文段的首部长度<br>7.窗口：16比特，指出发送本报文段的一方的接收窗口。也就是流量控制的工具<br>8.检验和：16比特，检查首部和数据载荷<br>9.同步标志位(SYN）：在TCP建立连接时同步序号<br>10.终止标志位（FIN）：用来释放TCP连接<br>11.复位标志位（RST）：用来复位TCP连接。当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接.<br>12.推送标志位（PSH）：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。<br>13.紧急标志位（URG）：取1时紧急指针字段有效，0时无效<br>14.紧急指针：16比特，以字节为单位，用来指明紧急数据的长度</li>
</ul>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/Blog/2024/03/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><p>将无序序列中的值与有序序列中每一个值进行比较并且插入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">insertionSort(arr)</span><br><span class="line"> n = arr.length</span><br><span class="line"> </span><br><span class="line"> // 从第二个元素开始遍历数组</span><br><span class="line"> for i from 1 to n-1 do</span><br><span class="line">   // 将当前元素插入已排序部分的合适位置</span><br><span class="line">   key = arr[i]</span><br><span class="line">   j = i - 1</span><br><span class="line">   </span><br><span class="line">   // 将比当前元素大的元素向后移动</span><br><span class="line">   while j &gt;= 0 and arr[j] &gt; key do</span><br><span class="line">     arr[j + 1] = arr[j]</span><br><span class="line">     j = j - 1</span><br><span class="line">   </span><br><span class="line">   // 将当前元素插入到正确位置</span><br><span class="line">   arr[j + 1] = key</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2.希尔排序"></a>2.希尔排序</h2><ul>
<li>通过缩小增量进行排序，达到排序结果<br>第一趟排序： 设 gap1 &#x3D; N &#x2F; 2 &#x3D; 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。<br>第二趟排序：将上次的 gap 缩小一半，即 gap2 &#x3D; gap1 &#x2F; 2 &#x3D; 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为2组。按照直接插入排序的方法对每个组进行排序。<br>第三趟排序：再次把 gap 缩小一半，即gap3 &#x3D; gap2 &#x2F; 2 &#x3D; 1。 这样相隔距离为1的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。  </li>
<li>平均时间复杂度：O(Nlog2N)<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function shellSort(arr)</span><br><span class="line">    n = arr.length</span><br><span class="line">    gap = n / 2</span><br><span class="line">    while gap &gt; 0</span><br><span class="line">        for i = gap to n - 1</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            j = i</span><br><span class="line">            while j &gt;= gap and arr[j - gap] &gt; temp</span><br><span class="line">                arr[j] = arr[j - gap]</span><br><span class="line">                j = j - gap</span><br><span class="line">            arr[j] = temp</span><br><span class="line">        gap = gap / 2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h2><p>从第一个开始两两比较，进行两两排序，每排完一个循环，总有一个大值从后往前归到正确位置，所以叫冒泡法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure bubbleSort(arr)</span><br><span class="line">    n = length(arr)</span><br><span class="line">    for i from 0 to n-1</span><br><span class="line">        for j from 0 to n-i-1</span><br><span class="line">            if arr[j] &gt; arr[j+1]</span><br><span class="line">                swap(arr[j], arr[j+1])</span><br></pre></td></tr></table></figure></div>
<h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h2><ol>
<li>在待排序表L[1…n]中任取⼀个元素pivot作为枢轴（或基准）  </li>
<li>通过⼀趟排序将待排序表划分为独⽴的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于 pivot，则pivot放在了其最终位置L(k)上，这个过程称为⼀次“划分”。  </li>
<li>然后分别递归地对两个⼦表重复上述过程，直每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function quickSort(arr, low, high)</span><br><span class="line"> if low &lt; high</span><br><span class="line">     pi = partition(arr, low, high)</span><br><span class="line">     quickSort(arr, low, pi - 1) // Before pi</span><br><span class="line">     quickSort(arr, pi + 1, high) // After pi</span><br><span class="line"></span><br><span class="line">function partition(arr, low, high)</span><br><span class="line"> pivot = arr[high]</span><br><span class="line"> i = low - 1 //保证 i 指向的是小于等于基准值的元素的最后一个位置</span><br><span class="line"> for j from low to high - 1</span><br><span class="line">     if arr[j] &lt;= pivot</span><br><span class="line">         i = i + 1</span><br><span class="line">         swap(arr[i], arr[j])</span><br><span class="line"> swap(arr[i + 1], arr[high])</span><br><span class="line"> return i + 1</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="5-选择排序（逻辑最简单，最稳定）"><a href="#5-选择排序（逻辑最简单，最稳定）" class="headerlink" title="5.选择排序（逻辑最简单，最稳定）"></a>5.选择排序（逻辑最简单，最稳定）</h2><p>每一次将无序序列中最小的数追加到有序序列的里面</p>
<h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h2><ul>
<li>时间复杂度：O(n * logn)<br>1.构建最大堆O(n)<br>2.排序O(logn)<br>3.所以结果为相乘O(n * logn)</li>
<li>原理<br>大根堆：根节点是最大的<br>小根堆：根节点是最小的<br>建立堆，然后使用堆排序调整堆。简而言之就是每次把未排序中最大数，放到有序序列的最小处<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">heapSort(arr)</span><br><span class="line">    n = arr.length</span><br><span class="line">    </span><br><span class="line">    // 构建最大堆，将最大的放到堆顶（此时左右子节点还是无序的）</span><br><span class="line">    for i from n/2 - 1 down to 0 do</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    </span><br><span class="line">    // 从堆顶开始逐步将最大值移到数组末尾，并进行调整（也就是每一次都把最大的数放到堆底）</span><br><span class="line">    for i from n - 1 down to 1 do</span><br><span class="line">        swap(arr[0], arr[i]) // 将堆顶元素（最大值）与当前未排序部分的末尾元素交换</span><br><span class="line">        heapify(arr, i, 0)   // 对剩余元素重新进行堆调整，保持最大堆性质</span><br><span class="line"></span><br><span class="line">// 调整堆，保持最大堆性质</span><br><span class="line">heapify(arr, n, i)</span><br><span class="line">    largest = i   // 初始化父节点索引为最大值索引</span><br><span class="line">    left = 2 * i + 1   // 左子节点索引</span><br><span class="line">    right = 2 * i + 2  // 右子节点索引</span><br><span class="line">    </span><br><span class="line">    // 检查左子节点是否大于父节点</span><br><span class="line">    if left &lt; n and arr[left] &gt; arr[largest] then</span><br><span class="line">        largest = left</span><br><span class="line">    </span><br><span class="line">    // 检查右子节点是否大于父节点或左子节点</span><br><span class="line">    if right &lt; n and arr[right] &gt; arr[largest] then</span><br><span class="line">        largest = right</span><br><span class="line">    </span><br><span class="line">    // 如果最大值不是父节点，则进行交换，并递归调整受影响的子树</span><br><span class="line">    if largest != i then</span><br><span class="line">        swap(arr[i], arr[largest])</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h2><ul>
<li>先将序列分成两个序列，分别进行排序，随后将两个序列进行合并<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mergeSort(arr)</span><br><span class="line">  n = arr.length</span><br><span class="line">  // 如果数组只有一个元素，直接返回</span><br><span class="line">  if n &lt; 2 then</span><br><span class="line">    return</span><br><span class="line">  </span><br><span class="line">  // 计算中间索引</span><br><span class="line">  mid = n / 2</span><br><span class="line">  </span><br><span class="line">  // 创建左右子数组</span><br><span class="line">  left = arr[0...mid-1]</span><br><span class="line">  right = arr[mid...n-1]</span><br><span class="line">  </span><br><span class="line">  // 递归地对左右子数组进行排序</span><br><span class="line">  mergeSort(left)</span><br><span class="line">  mergeSort(right)</span><br><span class="line">  </span><br><span class="line">  // 合并左右两个有序子数组</span><br><span class="line">  merge(arr, left, right)</span><br><span class="line"></span><br><span class="line">merge(arr, left, right)</span><br><span class="line">  nL = left.length</span><br><span class="line">  nR = right.length</span><br><span class="line">  i = 0, j = 0, k = 0</span><br><span class="line">  </span><br><span class="line">  // 合并左右两个有序子数组</span><br><span class="line">  while i &lt; nL and j &lt; nR do</span><br><span class="line">    if left[i] &lt;= right[j] then</span><br><span class="line">      arr[k] = left[i]</span><br><span class="line">      i = i + 1</span><br><span class="line">    else</span><br><span class="line">      arr[k] = right[j]</span><br><span class="line">      j = j + 1</span><br><span class="line">    k = k + 1</span><br><span class="line">  </span><br><span class="line">  // 处理剩余元素</span><br><span class="line">  while i &lt; nL do</span><br><span class="line">    arr[k] = left[i]</span><br><span class="line">    i = i + 1</span><br><span class="line">    k = k + 1</span><br><span class="line">  </span><br><span class="line">  while j &lt; nR do</span><br><span class="line">    arr[k] = right[j]</span><br><span class="line">    j = j + 1</span><br><span class="line">    k = k + 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8.基数排序"></a>8.基数排序</h2><ul>
<li>非比较序列，并不直接进行数的大小比较，而是对每一位进行比较<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取数组中最大元素的位数</span><br><span class="line">function getMax(arr):</span><br><span class="line">    max = arr[0]</span><br><span class="line">    for i from 1 to arr.length - 1 do</span><br><span class="line">        if arr[i] &gt; max then</span><br><span class="line">            max = arr[i]</span><br><span class="line">    return max</span><br><span class="line"></span><br><span class="line">// 对数组按照指定位数进行计数排序</span><br><span class="line">function countingSort(arr, exp):</span><br><span class="line">    n = arr.length</span><br><span class="line">    output = new Array(n)</span><br><span class="line">    count = new Array(10)</span><br><span class="line">    for i from 0 to 9 do</span><br><span class="line">        count[i] = 0</span><br><span class="line"></span><br><span class="line">    // 统计每个桶中元素的个数</span><br><span class="line">    for i from 0 to n - 1 do</span><br><span class="line">        index = (arr[i] / exp) % 10</span><br><span class="line">        count[index]++</span><br><span class="line"></span><br><span class="line">    // 将计数数组转换为位置索引数组</span><br><span class="line">    for i from 1 to 9 do</span><br><span class="line">        count[i] += count[i - 1]</span><br><span class="line"></span><br><span class="line">    // 将元素按照当前位的值放置到输出数组中</span><br><span class="line">    for i from n - 1 down to 0 do</span><br><span class="line">        index = (arr[i] / exp) % 10</span><br><span class="line">        output[count[index] - 1] = arr[i]</span><br><span class="line">        count[index]--</span><br><span class="line"></span><br><span class="line">    // 将输出数组复制回原数组</span><br><span class="line">    for i from 0 to n - 1 do</span><br><span class="line">        arr[i] = output[i]</span><br><span class="line"></span><br><span class="line">// 基数排序函数</span><br><span class="line">function radixSort(arr):</span><br><span class="line">    max = getMax(arr)</span><br><span class="line">    exp = 1</span><br><span class="line">    while max / exp &gt; 0 do</span><br><span class="line">        countingSort(arr, exp)</span><br><span class="line">        exp *= 10</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
  </entry>
</search>
